'Author:        Alex Nolan, Juan Chong
'Date:          05/16/2019
'Description:   Main interfacing library for the Cypress FX3 based eval platform. FX3Connection implements
'               IRegInterface and IPinFcns, and can be used in place of iSensorSpi in most applications.

Imports CyUSB
Imports AdisApi
Imports System.Threading
Imports System.Collections.Concurrent

''' <summary>
''' Class for interfacing with the FX3 based eval platform. Implements IRegInterface and IPinFcns, in addition
''' to a superset of extra FX3 specific interfacing functions.
''' </summary>
Public Class FX3Connection
    Implements IRegInterface, IPinFcns

#Region "Interface Variable Initialization"

    'Constant definitions

    'Friendly Name for the Cypress bootloader
    Const CypressBootloaderName As String = "Cypress FX3 USB BootLoader Device"

    'Friendly name for the ADI bootloader
    Const ADIBootloaderName As String = "Cypress FX3 USB BulkloopExample Device"

    'Friendly name for the ADI Application Firmware
    Const ApplicationName As String = "Cypress FX3 USB StreamerExample Device"

    'Timeout (in ms) for programming a board with the application firmware
    Const ProgrammingTimeout As Integer = 10000

    'Delay (in ms) in polling the cypress USB driver for new devices connected
    Const DeviceListDelay As Integer = 200

    'Private member variables

    'Thread to program the FX3 with the bootloader as needed
    Private BootloaderThread As Thread

    'Blocking queue to tell the bootloader thread a new board needs to be programmed
    Private BootloaderQueue As BlockingCollection(Of CyFX3Device)

    'Bool to track if the FX3 is currently connected
    Private m_FX3Connected As Boolean

    'SPI config struct for tracking the current FX3 configuration
    Private m_FX3_SpiConfig As SPIConfig

    'CyUSB object for the active FX3 board
    Private m_ActiveFX3 As CyUSB.CyFX3Device = Nothing

    'Serial number of the active FX3 board
    Private m_ActiveFX3SN As String = Nothing

    'CyUSB Control Endpoint
    Private FX3ControlEndPt As CyUSB.CyControlEndPoint

    'CyUSB Bulk Endpoint for streaming real time data from FX3 to PC
    Private StreamingEndPt As CyUSB.CyBulkEndPoint

    'CyUSB bulk endpoint for streaming register data from FX3 to PC
    Private DataInEndPt As CyUSB.CyBulkEndPoint

    'CyUSB bulk endpoint for streaming register data from the PC to the FX3
    Private DataOutEndPt As CyUSB.CyBulkEndPoint

    'Member variable to track the stream timeout time
    Private m_StreamTimeout As Integer

    'Member variable to track firmware path
    Private m_FirmwarePath As String = "PathNotSet"

    'Member variable to track blink firmware path
    Private m_BlinkFirmwarePath As String = "PathNotSet"

    'String to track the current board communication status
    Private m_status As String = "Not Connected"

    'Data ready polarity
    Private m_DrPolarity As Boolean = True

    'Thread safe queue to store real time data frames as UShort arrrays
    Private StreamData As ConcurrentQueue(Of UShort())

    'Tracks the number of frames read in from DUT in real time mode
    Private FramesRead As Long = 0

    'Thread for pulling real time data off the DUT
    Private StreamThread As Thread

    'Boolean to track if the streaming thread is currently running
    Private StreamThreadRunning As Boolean

    'Boolean to track if current thread has exited
    Private ThreadTerminated As Boolean

    'The total number of buffers to read in real time stream (AdcmXLx021 or IMU)
    Private TotalBuffersToRead As Integer = 0

    'Total number of bytes to read between data ready's (when DrActive = True)
    Private BytesPerBulkRead As UInt16

    'List of available SPI clock frequencies
    Private m_SPIFrequencies As List(Of Double)

    'USB device list generated by the driver libraries
    Private m_usbList As USBDeviceList

    'Tracks the number of bad frames in a given read from the ADcmXLx021
    Private numBadFrames As Long

    'Timer for tracking stream timeouts
    Private streamTimeoutTimer As Stopwatch

    'Tracks enable/disable pin exit post-RT capture
    Private m_pinExit As UInteger = 0

    'Tracks enable/disable pin start configuration for RT capture
    Private m_pinStart As UInteger = 0

    'Tracks the selected sensor type
    Private m_sensorType As DeviceType

    'Tracks how many bytes should be captured in burst mode
    Private m_burstMode As UInteger = 0

    'Global Timer for measuring disconnect event time
    Private m_disconnectTimer As Stopwatch

    'String to track the serial number of the last board which was disconnected
    Private m_disconnectedFX3SN As String

    'Events

    ''' <summary>
    ''' This event is raised when the active board is disconnected unexpectedly (ie unplugged)
    ''' </summary>
    ''' <param name="FX3SerialNum">Serial number of the board which was disconnected</param>
    Event UnexpectedDisconnect(ByVal FX3SerialNum As String)

    ''' <summary>
    ''' This event is raised when the disconnect event for a board has finished, and it is reprogrammed with the ADI bootloader
    ''' </summary>
    ''' <param name="FX3SerialNum">Serial number of the board</param>
    ''' <param name="DisconnectTime">Time (in ms) elapsed between the disconnect call and board re-enumeration</param>
    Event DisconnectFinished(ByVal FX3SerialNum As String, ByVal DisconnectTime As Integer)

#End Region

#Region "Class Constructors"

    ''' <summary>
    ''' Class Constructor. Loads SPI settings and default values for the interface.
    ''' </summary>
    ''' <param name="FX3FirmwarePath">The path to the FX3 Application Firmware</param>
    ''' <param name="FX3BlinkFirmwarePath">The path to the ADI FX3 Bootloader</param>
    ''' <param name="SensorType">The sensor type. Valid inputs are IMU and ADcmXL. Default is IMU.</param>
    Public Sub New(ByVal FX3FirmwarePath As String, ByVal FX3BlinkFirmwarePath As String, Optional ByVal SensorType As DeviceType = DeviceType.IMU)
        'Store sensor type in a local variable
        m_sensorType = SensorType
        'Set the firmware path
        FirmwarePath = FX3FirmwarePath
        'Set the firmware path
        BlinkFirmwarePath = FX3BlinkFirmwarePath
        'Initialize default values for the interface and look for connected boards
        SetDefaultValues(m_sensorType)
        'Start the bootloader programmer thread
        BootloaderQueue = New BlockingCollection(Of CyFX3Device)
        BootloaderThread = New Thread(AddressOf ProgramBootloader_Thread)
        BootloaderThread.IsBackground = True
        BootloaderThread.Start()
        'Initialize the board list
        InitBoardList()
    End Sub

    ''' <summary>
    ''' Sets the default values for the interface. Used in constructor and after FX3 reset.
    ''' </summary>
    ''' <param name="SensorType">Parameter to specify default device SPI settings. Valid options are IMU and ADcmXL</param>
    Private Sub SetDefaultValues(ByVal SensorType As DeviceType)

        'Set the default SPI config
        If SensorType = DeviceType.IMU Then
            m_FX3_SpiConfig = New SPIConfig(FX3Interface.DeviceType.IMU)
        Else
            m_FX3_SpiConfig = New SPIConfig(FX3Interface.DeviceType.ADcmXL)
        End If

        'Set the status
        m_status = "Not Connected"

        'Set the board connection
        m_FX3Connected = False
        m_ActiveFX3 = Nothing
        m_ActiveFX3SN = Nothing

        'Reinitialize the thread safe queue 
        StreamData = New ConcurrentQueue(Of UShort())

        'Set streaming variables
        StreamThreadRunning = False
        ThreadTerminated = True
        TotalBuffersToRead = 0
        numBadFrames = 0
        m_StreamTimeout = 5

        'Set the SPI frequencies list
        m_SPIFrequencies = New List(Of Double) From {12.39, 12.8, 13.24}
        m_SPIFrequencies.Sort()

        'Set timer
        streamTimeoutTimer = New Stopwatch

    End Sub

#End Region

#Region "SPI Configuration"

    ''' <summary>
    ''' Property to get or set the FX3 SPI clock frequency setting.
    ''' </summary>
    ''' <returns>The current SPI clock frequency, in MHZ</returns>
    Public Property SclkFrequency As Int32
        'Reqcode:   B2
        'Value:     Don't Care
        'Index:     0    
        'Length:    4
        'Data:      Clock Frequency to be set
        Get
            Return m_FX3_SpiConfig.ClockFrequency
        End Get
        Set(value As Int32)
            'Throw an exception if the value is out of the range of frequencies supported by the board
            If value > 40000000 Or value < 1 Then
                Throw New Exception("ERROR: Invalid Sclk Frequency entered")
            End If
            m_FX3_SpiConfig.ClockFrequency = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 0
                ConfigureSPI(m_FX3_SpiConfig.ClockFrequency)
            End If
        End Set
    End Property


    ''' <summary>
    ''' Property to get or set the FX3 SPI controller clock polarity setting (True - Idles High, False - Idles Low)
    ''' </summary>
    ''' <returns>The current polarity setting</returns>
    Public Property Cpol As Boolean
        'Reqcode:   B2
        'Value:     Polarity (0 active low, 1 active high)
        'Index:     1    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.Cpol
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.Cpol = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 1
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.Cpol
                ConfigureSPI()
            End If

        End Set
    End Property

    ''' <summary>
    ''' Property to get or set the FX3 SPI controller chip select phase
    ''' </summary>
    ''' <returns>The current chip select phase setting</returns>
    Public Property Cpha As Boolean
        'Reqcode:   B2
        'Value:     Polarity (0 active low, 1 active high)
        'Index:     2    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.Cpha
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.Cpha = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 2
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.Cpha
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' Property to get or set the FX3 SPI chip select polarity (True - Active High, False - Active Low)
    ''' </summary>
    ''' <returns>The current chip select polarity</returns>
    Public Property ChipSelectPolarity As Boolean
        'Reqcode:   B2
        'Value:     Polarity (0 active low, 1 active high)
        'Index:     3    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.ChipSelectPolarity
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.ChipSelectPolarity = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 3
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.ChipSelectPolarity
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' Property to get or set the FX3 SPI controller chip select setting. Should be left on hardware control.
    ''' </summary>
    ''' <returns>The current chip select control mode</returns>
    Public Property ChipSelectControl As SpiChipselectControl
        'Reqcode:   B2
        'Value:     Desired setting ( as SpiChipselectControl )
        'Index:     4    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.ChipSelectControl
        End Get
        Set(value As SpiChipselectControl)
            m_FX3_SpiConfig.ChipSelectControl = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 4
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.ChipSelectControl
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The number of SPI clock cycles before the SPI transaction that chip select is toggled to active.
    ''' </summary>
    ''' <returns>The current chip select lead time setting</returns>
    Public Property ChipSelectLeadTime As SpiLagLeadTime
        'Reqcode:   B2
        'Value:     Desired Setting ( as SpiLagLeadTime )
        'Index:     5    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.ChipSelectLeadTime
        End Get
        Set(value As SpiLagLeadTime)
            m_FX3_SpiConfig.ChipSelectLeadTime = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 5
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.ChipSelectLeadTime
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The number of SPI clock cycles after the transaction ends that chip select is toggled to idle.
    ''' </summary>
    ''' <returns>The current chip select lag time setting</returns>
    Public Property ChipSelectLagTime As SpiLagLeadTime
        'Reqcode:   B2
        'Value:     Desired Setting ( as SpiLagLeadTime )
        'Index:     6    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.ChipSelectLagTime
        End Get
        Set(value As SpiLagLeadTime)
            m_FX3_SpiConfig.ChipSelectLagTime = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 6
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.ChipSelectLagTime
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The FX3 SPI Controller LSB setting. The controller flips the bits depending on this setting.
    ''' </summary>
    ''' <returns>The current LSB First setting, as a boolean</returns>
    Public Property IsLSBFirst As Boolean
        'Reqcode:   B2
        'Value:     Polarity (0 MSB first, 1 LSB first)
        'Index:     7    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.IsLSBFirst
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.IsLSBFirst = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 7
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.IsLSBFirst
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The FX3 SPI controller word length. Default is 8 (1 byte per word)
    ''' </summary>
    ''' <returns>The current word length</returns>
    Public Property WordLength As Byte
        'Reqcode:   B2
        'Value:     Word length (as int8)
        'Index:     8    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.WordLength
        End Get
        Set(value As Byte)
            If Not (value Mod 8 = 0) Then
                Throw New Exception("ERROR: Word length must by a multiple of 8 bits")
            End If
            m_FX3_SpiConfig.WordLength = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 8
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.WordLength
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' Property to get/set the number of microseconds between words
    ''' </summary>
    ''' <returns>The current stall time, in microseconds</returns>
    Public Property StallTime As UInt16
        'Reqcode:   B2
        'Value:     Stall time in microseconds (as int16)
        'Index:     9    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.StallTime
        End Get
        Set(value As UInt16)
            m_FX3_SpiConfig.StallTime = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 9
                'Send the stall time in microseconds to the FX3 board
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.StallTime
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The DUT Type (single axis or three axis)
    ''' </summary>
    ''' <returns>Returns the DUTType. Defaults to 3 axis</returns>
    Public Property PartType As DUTType
        'Reqcode:   B2
        'Value:     Part type to set
        'Index:     10    
        'Length:    4
        'Data:      None
        Get
            Return m_FX3_SpiConfig.DUTType
        End Get
        Set(value As DUTType)
            m_FX3_SpiConfig.DUTType = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 10
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.DUTType
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' The Data Ready polarity for streaming mode
    ''' </summary>
    ''' <returns>The data ready polarity, as a boolean (True - low to high, False - high to low)</returns>
    Public Property DrPolarity As Boolean
        Get
            Return m_FX3_SpiConfig.DrPolarity
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.DrPolarity = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 11
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.DrPolarity
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' If the data ready is used for register reads
    ''' </summary>
    ''' <returns>The current data ready usage setting</returns>
    Public Property DrActive As Boolean Implements AdisApi.IRegInterface.DrActive
        Get
            Return m_FX3_SpiConfig.DrActive
        End Get
        Set(value As Boolean)
            m_FX3_SpiConfig.DrActive = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 12
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.DrActive
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' Property to get or set the DUT data ready pin
    ''' </summary>
    ''' <returns>The IPinObject of the pin currently configured as the data ready</returns>
    Public Property ReadyPin As IPinObject
        Get
            Return m_FX3_SpiConfig.DataReadyPin
        End Get
        Set(value As IPinObject)
            'throw an exception if the pin object is not an FX3PinObject
            If Not value.ToString().Substring(0, 3) = "FX3" Then
                Throw New Exception("ERROR: FX3 Connection must take an FX3 pin object")
            End If
            m_FX3_SpiConfig.DataReadyPin = value
            If m_FX3Connected Then
                m_ActiveFX3.ControlEndPt.Index = 13
                m_ActiveFX3.ControlEndPt.Value = m_FX3_SpiConfig.DataReadyPinFX3GPIO
                ConfigureSPI()
            End If
        End Set
    End Property

    ''' <summary>
    ''' Read only property to get the timer tick scale factor used for converting ticks to ms
    ''' </summary>
    ''' <returns></returns>
    Public ReadOnly Property TimerTickScaleFactor As UInteger
        Get
            Return m_FX3_SpiConfig.TimerTickScaleFactor
        End Get
    End Property

    ''' <summary>
    ''' Gets the real SPI frequencies available with the FX3 SPI controller
    ''' </summary>
    ''' <returns>Returns a list of available frequencies, in MHz</returns>
    Public ReadOnly Property SpiClockFrequencies As IEnumerable(Of Double)
        Get
            Return m_SPIFrequencies
        End Get
    End Property

    ''' <summary>
    ''' Function to read the current SPI parameters from the FX3 board
    ''' </summary>
    ''' <returns>Returns a SPIConfig struct representing the current board configuration</returns>
    Private Function GetBoardSpiParameters() As SPIConfig

        'Output buffer
        Dim buf(22) As Byte

        'Variables to store output config
        Dim returnConfig As New SPIConfig
        Dim tempValue As UInteger
        Dim newClock As Integer
        Dim newStall As UInteger
        Dim newTimerTick As UInteger
        Dim drPinNumber As UInteger

        'Configure control end point for vendor command to read SPI settings
        m_ActiveFX3.ControlEndPt.Target = CyConst.TGT_DEVICE
        m_ActiveFX3.ControlEndPt.Direction = CyConst.DIR_FROM_DEVICE
        m_ActiveFX3.ControlEndPt.ReqType = CyConst.REQ_VENDOR
        m_ActiveFX3.ControlEndPt.ReqCode = &HB3
        m_ActiveFX3.ControlEndPt.Value = 0
        m_ActiveFX3.ControlEndPt.Index = 0

        'Transfer data from the part
        XferControlData(buf, 23, 2000)

        'Get the SPI Clock from buf 0 - 3
        newClock = buf(0)
        tempValue = buf(1)
        tempValue = tempValue << 8
        newClock = newClock + tempValue
        tempValue = buf(2)
        tempValue = tempValue << 16
        newClock = newClock + tempValue
        tempValue = buf(3)
        tempValue = tempValue << 24
        newClock = newClock + tempValue
        returnConfig.ClockFrequency = newClock

        'Get Cpha from buf 4
        returnConfig.Cpha = buf(4)

        'Get Cpol from buf 5
        returnConfig.Cpol = buf(5)

        'Get LSB first setting from buf 6
        returnConfig.IsLSBFirst = buf(6)

        'Get CS lag time from buf 7
        returnConfig.ChipSelectLagTime = buf(7)

        'Get CS lead time from buf 8
        returnConfig.ChipSelectLeadTime = buf(8)

        'Get CS control type from buf 9
        returnConfig.ChipSelectControl = buf(9)

        'Get CS polarity from buf 10
        returnConfig.ChipSelectPolarity = buf(10)

        'Get word length from buf 11
        returnConfig.WordLength = buf(11)

        'Get stall time from buf 12 - 13
        newStall = buf(12)
        tempValue = buf(13)
        tempValue = tempValue << 8
        newStall = newStall + tempValue
        returnConfig.StallTime = newStall

        'Get DUT Type from buf 14
        returnConfig.DUTType = buf(14)

        'GEt data ready active setting from buf 15
        returnConfig.DrActive = buf(15)

        'Get data ready polarity setting from buf 16
        returnConfig.DrPolarity = buf(16)

        'Get data ready GPIO number from buf 17 - 18
        drPinNumber = buf(17)
        tempValue = buf(18)
        tempValue = tempValue << 8
        drPinNumber = drPinNumber + tempValue
        returnConfig.DataReadyPinFX3GPIO = drPinNumber

        'Get timer tick scale factor from buf 19 - 22
        'Note: the timer tick setting in read-only, so there is no accompanying write function
        newTimerTick = buf(19)
        tempValue = buf(20)
        tempValue = tempValue << 8
        newTimerTick = newTimerTick + tempValue
        tempValue = buf(21)
        tempValue = tempValue << 16
        newTimerTick = newTimerTick + tempValue
        tempValue = buf(22)
        tempValue = tempValue << 24
        newTimerTick = newTimerTick + tempValue
        returnConfig.StallTime = newTimerTick

        Return returnConfig

    End Function

    ''' <summary>
    ''' Function which writes the current SPI config to the FX3
    ''' </summary>
    Private Sub WriteBoardSpiParameters()

        'Get the current FX3 config
        Dim boardConfig As SPIConfig = GetBoardSpiParameters()

        'Updating each of the properties invokes their setter, which writes the values to the FX3
        If Not boardConfig.ClockFrequency = m_FX3_SpiConfig.ClockFrequency Then
            SclkFrequency = m_FX3_SpiConfig.ClockFrequency
        End If

        If Not boardConfig.Cpha = m_FX3_SpiConfig.Cpha Then
            Cpha = m_FX3_SpiConfig.Cpha
        End If

        If Not boardConfig.Cpol = m_FX3_SpiConfig.Cpol Then
            Cpol = m_FX3_SpiConfig.Cpol
        End If

        If Not boardConfig.StallTime = m_FX3_SpiConfig.StallTime Then
            StallTime = m_FX3_SpiConfig.StallTime
        End If

        If Not boardConfig.ChipSelectLagTime = m_FX3_SpiConfig.ChipSelectLagTime Then
            ChipSelectLagTime = m_FX3_SpiConfig.ChipSelectLagTime
        End If

        If Not boardConfig.ChipSelectLeadTime = m_FX3_SpiConfig.ChipSelectLeadTime Then
            ChipSelectLeadTime = m_FX3_SpiConfig.ChipSelectLeadTime
        End If

        If Not boardConfig.ChipSelectControl = m_FX3_SpiConfig.ChipSelectControl Then
            ChipSelectControl = m_FX3_SpiConfig.ChipSelectControl
        End If

        If Not boardConfig.ChipSelectPolarity = m_FX3_SpiConfig.ChipSelectPolarity Then
            ChipSelectPolarity = m_FX3_SpiConfig.ChipSelectPolarity
        End If

        If Not boardConfig.DUTType = m_FX3_SpiConfig.DUTType Then
            PartType = m_FX3_SpiConfig.DUTType
        End If

        If Not boardConfig.IsLSBFirst = m_FX3_SpiConfig.IsLSBFirst Then
            IsLSBFirst = m_FX3_SpiConfig.IsLSBFirst
        End If

        If Not boardConfig.WordLength = m_FX3_SpiConfig.WordLength Then
            WordLength = m_FX3_SpiConfig.WordLength
        End If

        If Not boardConfig.DataReadyPinFX3GPIO = m_FX3_SpiConfig.DataReadyPinFX3GPIO Then
            ReadyPin = m_FX3_SpiConfig.DataReadyPin
        End If

        If Not boardConfig.DrActive = m_FX3_SpiConfig.DrActive Then
            DrActive = m_FX3_SpiConfig.DrActive
        End If

        If Not boardConfig.DrPolarity = m_FX3_SpiConfig.DrPolarity Then
            DrPolarity = m_FX3_SpiConfig.DrPolarity
        End If

    End Sub

    ''' <summary>
    ''' Function which performs the SPI configuration option based on the current control endpoint setting
    ''' </summary>
    ''' <param name="clockFrequency">The SPI clock frequency, if it needs to be set</param>
    Private Sub ConfigureSPI(Optional ByVal clockFrequency As Integer = 0)

        'Create buffer for transfer
        Dim buf(3) As Byte

        'Exit if the board is not yet set
        If Not m_FX3Connected Then
            Exit Sub
        End If

        'Configure the control end point
        m_ActiveFX3.ControlEndPt.Target = CyConst.TGT_DEVICE
        m_ActiveFX3.ControlEndPt.Direction = CyConst.DIR_TO_DEVICE
        m_ActiveFX3.ControlEndPt.ReqType = CyConst.REQ_VENDOR
        m_ActiveFX3.ControlEndPt.ReqCode = &HB2

        'Store the clock frequency in the buffer
        If Not clockFrequency = 0 Then
            buf(0) = (clockFrequency >> 24) And &HFF
            buf(1) = (clockFrequency >> 16) And &HFF
            buf(2) = (clockFrequency >> 8) And &HFF
            buf(3) = (clockFrequency >> 0) And &HFF
        End If

        'Transfer data from the FX3
        XferControlData(buf, 4, 2000)

    End Sub


#End Region

#Region "FX3 Other Functions"

    'The functions in this region are not a part of the IDutInterface, and are specific to the FX3 board

    ''' <summary>
    ''' Readonly property to get the number of bad frames purged with a call to PurgeBadFrameData
    ''' </summary>
    ''' <returns>Number of frames purged from data array</returns>
    Public ReadOnly Property NumFramesPurged As Long
        Get
            Return numBadFrames
        End Get
    End Property

    ''' <summary>
    ''' Readonly property to get the device type the FX3Interface was initialized for
    ''' </summary>
    ''' <returns>The current device mode, as an FX3Interface.DeviceType</returns>
    Public ReadOnly Property SensorType As DeviceType
        Get
            Return m_sensorType
        End Get
    End Property

    ''' <summary>
    ''' Gets and sets the pin exit configuration for exiting real-time stream mode. 
    ''' </summary>
    ''' <returns>Pin exit configuration (0 = Pin Exit Disabled, 1 = Pin Exit Enabled)</returns>
    Public Property PinExit As Boolean
        Get
            Return m_pinExit
        End Get
        Set
            m_pinExit = Convert.ToUInt32(Value)
        End Set
    End Property

    ''' <summary>
    ''' Gets and sets the pin start configuration for starting real-time stream mode.
    ''' </summary>
    ''' <returns>Pin start configuration (0 = Pin Start Disabled, 1 = Pin Start Enabled</returns>
    Public Property PinStart As Boolean
        Get
            Return m_pinStart
        End Get
        Set
            m_pinStart = Convert.ToByte(Value)
        End Set
    End Property

    ''' <summary>
    ''' Reads the measured DR value
    ''' </summary>
    ''' <param name="pin">The DR pin to measure</param>
    ''' <param name="polarity">The edge to measure from. 1 - low to high, 0 - high to low</param>
    ''' <param name="timeoutInMs">The timeout from when the pin measurement starts to when the function returns if the signal cannot be found</param>
    ''' <returns>The DR frequency in Hz</returns>
    Public Function ReadDRFreq(pin As IPinObject, polarity As UInteger, timeoutInMs As UInteger) As Double

        Dim buf(10) As Byte
        Dim freq As Double
        Dim deltat, shiftedValue, shiftedConversionFactor As UInteger
        Dim transferStatus As Boolean
        Dim timeoutTimer As New Stopwatch
        Dim totalTime As Double
        Dim conversionFactor As UInteger
        Dim convertedDt As Double
        Dim returnLength As Integer = 6
        Dim timeoutFlag As UInteger = 0

        totalTime = timeoutInMs

        'Set the pin
        buf(0) = pin.pinConfig And &HFF
        buf(1) = 0

        'Set the polarity
        buf(2) = polarity

        'set the timeout to 0 if its greater than the allowable timer value
        If timeoutInMs > UInt32.MaxValue / 1000 Then
            timeoutInMs = 0
        End If

        'Set the timeout time
        buf(7) = timeoutInMs And &HFF
        buf(8) = (timeoutInMs And &HFF00) >> 8
        buf(9) = (timeoutInMs And &HFF0000) >> 16
        buf(10) = (timeoutInMs And &HFF000000) >> 24

        'Start stopwatch
        timeoutTimer.Start()

        'Send vendor command to request DR frequency
        ConfigureControlEndpoint(&HC8, True)
        If Not XferControlData(buf, 11, 2000) Then
            Throw New Exception("ERROR: DR frequency read timed out")
        End If

        'Start bulk transfer
        transferStatus = False
        If totalTime = 0 Then
            transferStatus = DataInEndPt.XferData(buf, 9)
        Else
            While ((Not transferStatus) And (timeoutTimer.ElapsedMilliseconds() < totalTime))
                transferStatus = DataInEndPt.XferData(buf, 9)
            End While
        End If

        'stop stopwatch
        timeoutTimer.Stop()

        'Read the time value from the buffer
        deltat = buf(0)
        shiftedValue = buf(1)
        shiftedValue = shiftedValue << 8
        deltat = deltat + shiftedValue
        shiftedValue = buf(2)
        shiftedValue = shiftedValue << 16
        deltat = deltat + shiftedValue
        shiftedValue = buf(3)
        shiftedValue = shiftedValue << 24
        deltat = deltat + shiftedValue

        'Read the scale factor (MS to ticks)
        conversionFactor = buf(4)
        shiftedConversionFactor = buf(5)
        shiftedConversionFactor = shiftedConversionFactor << 8
        conversionFactor = conversionFactor + shiftedConversionFactor
        shiftedConversionFactor = buf(6)
        shiftedConversionFactor = shiftedConversionFactor << 16
        conversionFactor = conversionFactor + shiftedConversionFactor
        shiftedConversionFactor = buf(7)
        shiftedConversionFactor = shiftedConversionFactor << 24
        conversionFactor = conversionFactor + shiftedConversionFactor

        'Read the timeout flag
        timeoutFlag = buf(8)

        'Scale dt to MS
        convertedDt = Convert.ToDouble(deltat)
        convertedDt = Math.Round(convertedDt / conversionFactor, 3)

        'Convert scaled dt to freq
        freq = (1 / convertedDt) * 1000

        'If the transfer failed return infinity
        If Not transferStatus Then
            freq = Double.PositiveInfinity
        End If

        'Return infinity if a timeout occured on the fx3
        If timeoutFlag > 0 Then
            freq = Double.PositiveInfinity
        End If

        'If operation failed on FX3 throw an exception
        If deltat = &HFFFFFFFF Then
            Throw New Exception("ERROR: Pin read on FX3 failed")
        End If

        'Return freq measured on specified DIO
        Return freq

    End Function

    ''' <summary>
    ''' Gets one frame from the thread safe queue. Waits to return until a frame is available
    ''' </summary>
    ''' <returns>The frame, as a byte array</returns>
    Public ReadOnly Property GetBuffer As UShort()
        Get
            If (StreamData.Count = 0) And (Not StreamThreadRunning) Then
                Return Nothing
            End If
            Dim buffer() As UShort = Nothing
            Dim validData As Boolean = False
            'Wait for a buffer to be avialable and dequeue
            streamTimeoutTimer.Restart()
            While (Not validData) And (streamTimeoutTimer.ElapsedMilliseconds < 1000)
                validData = StreamData.TryDequeue(buffer)
            End While
            Return buffer
        End Get
    End Property

    ''' <summary>
    ''' Readonly property to get the number of buffers read in from the DUT in buffered streaming mode
    ''' </summary>
    ''' <returns>The current buffer read count</returns>
    Public ReadOnly Property GetNumBuffersRead As Long
        Get
            'Interlocked is used to ensure atomic integer read operation
            Return Interlocked.Read(FramesRead)
        End Get
    End Property

    ''' <summary>
    ''' Checks if a frame is available, or will be available soon in thread safe queue
    ''' </summary>
    ''' <returns>The frame availability</returns>
    Public ReadOnly Property BufferAvailable As Boolean
        Get
            Dim goodBuffer As Boolean = False
            streamTimeoutTimer.Restart()
            While (streamTimeoutTimer.ElapsedMilliseconds() < (1000 * StreamTimeoutSeconds)) And (Not goodBuffer)
                If Not IsNothing(StreamData) Then
                    If StreamData.Count > 0 Or StreamThreadRunning Then
                        goodBuffer = True
                    End If
                End If
            End While
            streamTimeoutTimer.Reset()
            Return goodBuffer
        End Get
    End Property

#End Region

#Region "Burst Stream Functions"

    ''' <summary>
    ''' Function to start a burst read using the BurstStreamManager
    ''' </summary>
    ''' <param name="numBuffers">The number of buffers to read in the stream operation</param>
    Private Sub StartBurstStream(ByVal numBuffers As UInteger)

        'Buffer to store command data
        Dim buf(8) As Byte

        'Wait for previous stream thread to exit, if any
        StreamThreadRunning = False
        While Not ThreadTerminated
        End While

        'Send number of buffers to read
        buf(0) = numBuffers And &HFF
        buf(1) = (numBuffers And &HFF00) >> 8
        buf(2) = (numBuffers And &HFF0000) >> 16
        buf(3) = (numBuffers And &HFF000000) >> 24

        'Send word to trigger burst
        buf(4) = (m_TriggerReg.Address And &HFF)
        buf(5) = (m_TriggerReg.Address And &HFF00) >> 8

        'Send number of words to capture
        buf(6) = (m_WordCount And &HFF)
        buf(7) = (m_WordCount And &HFF00) >> 8

        'Reinitialize the thread safe queue
        StreamData = New ConcurrentQueue(Of UShort())

        ConfigureControlEndpoint(&HC1, True)
        m_ActiveFX3.ControlEndPt.Value = 0 'DNC
        m_ActiveFX3.ControlEndPt.Index = 1 'Start stream
        'Send start stream command to the DUT
        XferControlData(buf, 8, 2000)

        'Reset number of frames read
        FramesRead = 0

        'Set the total number of frames to read
        TotalBuffersToRead = numBuffers

        'Set the thread control bool
        StreamThreadRunning = True

        'Spin up a BurstStreamManager thread
        StreamThread = New Thread(AddressOf BurstStreamManager)
        StreamThread.Start()

    End Sub

    ''' <summary>
    ''' Stops a burst stream by setting the stream state variables
    ''' </summary>
    Public Sub StopBurstStream()

        'Buffer to store command data
        Dim buf(3) As Byte

        ConfigureControlEndpoint(&HC1, False)
        m_ActiveFX3.ControlEndPt.Value = 0
        m_ActiveFX3.ControlEndPt.Index = 0

        'Send command to the DUT to stop streaming data
        XferControlData(buf, 4, 2000)

        'Stop the stream manager thread
        StreamThreadRunning = False

    End Sub

    ''' <summary>
    ''' This function reads burst stream data from the DUT over the streaming endpoint. It is intended to operate in its own thread, and should not be called directly.
    ''' </summary>
    Private Sub BurstStreamManager()

        'The length of one frame, in bytes
        Dim frameLength As Integer
        'The index in the current raw buffer
        Dim index As Integer
        'The index in the current frame
        Dim frameIndex As Integer = 0
        'Temporary value for converting two bytes to a UShort
        Dim shortValue As UShort
        'The USB transfer size (from the FX3)
        Dim transferSize As Integer
        'List used to construct frames out of the output buffer
        Dim frameBuilder As New List(Of UShort)
        'Bool to track the transfer status
        Dim transferStatus As Boolean
        'Int to track number of frames read
        Dim framesCounter As Integer
        'Buffer to hold data from the FX3
        Dim buf(transferSize - 1) As Byte

        If m_ActiveFX3.bSuperSpeed Then
            transferSize = 1024
        ElseIf m_ActiveFX3.bHighSpeed Then
            transferSize = 512
        Else
            Throw New Exception("ERROR: Streaming application requires USB 2.0 or 3.0 connection to function")
        End If

        'Set total frames (infinite if less than 1)
        If TotalBuffersToRead < 1 Then
            TotalBuffersToRead = Int32.MaxValue
        End If

        'Determine the frame length (in bytes) based on configured word count plus trigger word
        frameLength = (m_WordCount * 2) + 2

        'Set the stream thread running state variable
        StreamThreadRunning = True
        ThreadTerminated = False
        framesCounter = 0

        While StreamThreadRunning
            'Configured transfer size bytes from the FX3
            transferStatus = StreamingEndPt.XferData(buf, transferSize)
            'Parse bytes into frames and add to StreamData if transaction was successful
            If transferStatus Then
                For index = 0 To transferSize - 2 Step 2
                    'Append every two bytes into words
                    shortValue = buf(index)
                    shortValue = shortValue << 8
                    shortValue = shortValue + buf(index + 1)
                    frameBuilder.Add(shortValue)
                    frameIndex = frameIndex + 2
                    'Once the end of each frame is reached add it to the queue
                    If frameIndex >= frameLength Then
                        'Remove trigger word entry
                        frameBuilder.RemoveAt(0)
                        'Enqueue data into thread-safe queue
                        StreamData.Enqueue(frameBuilder.ToArray())
                        'Increment the shared frame counter
                        Interlocked.Increment(FramesRead)
                        'Increment the local frame counter
                        framesCounter = framesCounter + 1
                        'Reset frame builder list and counter
                        frameIndex = 0
                        frameBuilder.Clear()
                        'Exit if the total number of buffers has been read
                        If framesCounter >= TotalBuffersToRead Then
                            'Stop streaming
                            Exit While
                        End If
                    End If
                Next
            Else
                'Exit streaming mode if the transfer fails
                Exit While
            End If
        End While

        'Update streamThreadRunning state variable
        StreamThreadRunning = False
        ThreadTerminated = True

    End Sub

#End Region

#Region "Generic Stream Functions"

    ''' <summary>
    ''' Stops a generic stream by setting the stream state variables
    ''' </summary>
    Public Sub StopGenericStream()

        'Buffer to hold command data
        Dim buf(3) As Byte

        ConfigureControlEndpoint(&HD0, False)
        m_ActiveFX3.ControlEndPt.Value = 0
        m_ActiveFX3.ControlEndPt.Index = 0

        'Send command to the DUT to stop streaming data
        XferControlData(buf, 4, 2000)

        'Stop the stream manager thread
        StreamThreadRunning = False

    End Sub

    ''' <summary>
    ''' This function pulls generic stream data from the FX3 over a bulk endpoint (DataIn). It is intended to run in its own thread,
    ''' and should not be called by itself.
    ''' </summary>
    ''' <param name="addr"></param>
    ''' <param name="numBuffers"></param>
    ''' <param name="numCaptures"></param>
    Private Sub RunGenericStream(addr As IEnumerable(Of AddrDataPair), numCaptures As UInteger, numBuffers As UInteger)

        'Buffer to store control data
        Dim buf As New List(Of Byte)
        'Number of bytes per buffer
        Dim wordsPerTransfer As Integer = (addr.Count() * numCaptures)
        'Reset frame counter
        FramesRead = 0
        'Set the total number of frames to read
        TotalBuffersToRead = numBuffers
        'Get the number of bytes per transfer from the DUT
        Dim bytesPerTransfer As Integer = (wordsPerTransfer * 2)
        'Buffer to store data from the FX3
        'Dim dataBuffer(bytesPerTransfer - 1) As Byte
        Dim dataBuffer(1023) As Byte
        'Bool to track if transfer from FX3 board is successful
        Dim validTransfer As Boolean = True
        'Variable to track number of buffers read
        Dim numBuffersRead As Integer = 0
        'List to build output buffer in USHORT format
        Dim bufferBuilder As New List(Of UShort)
        'Int to track buffer index
        Dim bufIndex As Integer = 0
        'Int to track frame index
        Dim frameIndex As Integer = 0
        'Short value for flipping bytes
        Dim shortValue As UShort

        'Add numBuffers
        buf.Add(numBuffers And &HFF)
        buf.Add((numBuffers And &HFF00) >> 8)
        buf.Add((numBuffers And &HFF0000) >> 16)
        buf.Add((numBuffers And &HFF000000) >> 24)

        'Add numCaptures
        buf.Add(numCaptures And &HFF)
        buf.Add((numCaptures And &HFF00) >> 8)
        buf.Add((numCaptures And &HFF0000) >> 16)
        buf.Add((numCaptures And &HFF000000) >> 24)

        'Add address list
        For Each item In addr
            If item.data Is Nothing Then
                buf.Add(item.addr And &HFF)
                buf.Add(&H0)
            Else
                buf.Add(item.addr And &HFF)
                buf.Add(item.data And &HFF)
            End If
        Next

        'Configure the control endpoint
        ConfigureControlEndpoint(&HC0, True)

        'Configure settings to enable/disable streaming
        m_ActiveFX3.ControlEndPt.Value = 0
        m_ActiveFX3.ControlEndPt.Index = 1

        'Send start command to the FX3
        If Not XferControlData(buf.ToArray(), buf.Count, 5000) Then
            Throw New Exception("ERROR: Control Endpoint transfer timed out")
        End If

        'Set the thread state flags
        ThreadTerminated = False
        StreamThreadRunning = True

        While StreamThreadRunning
            'Read data from FX3
            validTransfer = DataInEndPt.XferData(dataBuffer, 1024)
            'Exit the loop if transfer fails
            If validTransfer Then
                'Build the output buffer
                For bufIndex = 0 To (((1024 / bytesPerTransfer) * bytesPerTransfer) - 2) Step 2
                    'Flip bytes
                    shortValue = dataBuffer(bufIndex)
                    shortValue = shortValue << 8
                    shortValue = shortValue + dataBuffer(bufIndex + 1)
                    bufferBuilder.Add(shortValue)
                    frameIndex = frameIndex + 2
                    'Once the end of each frame is reached add it to the queue
                    If frameIndex >= bytesPerTransfer Then
                        StreamData.Enqueue(bufferBuilder.ToArray())
                        Interlocked.Increment(FramesRead)
                        bufferBuilder.Clear()
                        numBuffersRead = numBuffersRead + 1
                        frameIndex = 0
                        'Exit if the total number of buffers has been read
                        If numBuffersRead >= TotalBuffersToRead Then
                            Exit While
                        End If
                    End If
                Next
            Else
                Exit While
            End If
        End While

        'Set thread state flags
        ThreadTerminated = True
        StreamThreadRunning = False

    End Sub

#End Region

#Region "Real-Time Stream Functions"

    ''' <summary>
    ''' This function starts real time streaming on the ADcmXLx021 (interface and FX3). Specifying pin exit is optional and must be 0 (disabled) or 1 (enabled)
    ''' </summary>
    Public Sub StartRealTimeStreaming(ByVal numFrames As UInteger)

        'Buffer to store command data
        Dim buf(4) As Byte

        'Wait for previous stream thread to exit, if any
        StreamThreadRunning = False
        While Not ThreadTerminated
        End While

        buf(0) = numFrames And &HFF
        buf(1) = (numFrames And &HFF00) >> 8
        buf(2) = (numFrames And &HFF0000) >> 16
        buf(3) = (numFrames And &HFF000000) >> 24
        buf(4) = (m_pinStart)

        'Reinitialize the thread safe queue
        StreamData = New ConcurrentQueue(Of UShort())

        ConfigureControlEndpoint(&HD0, True)
        m_ActiveFX3.ControlEndPt.Value = m_pinExit
        m_ActiveFX3.ControlEndPt.Index = 1
        'Send start stream command to the DUT
        XferControlData(buf, 5, 2000)

        'Set the thread control bool
        StreamThreadRunning = True

        'Reset number of frames read
        FramesRead = 0
        numBadFrames = 0

        'Set the total number of frames to read
        TotalBuffersToRead = numFrames

        'Spin up a RealTimeStreamManager thread
        StreamThread = New Thread(AddressOf RealTimeStreamManager)
        StreamThread.Start()

    End Sub

    ''' <summary>
    ''' This function stops real time streaming on the ADcmXLx021 (interface and FX3)
    ''' </summary>
    Public Sub StopRealTimeStreaming()

        'Buffer to hold command data
        Dim buf(3) As Byte

        ConfigureControlEndpoint(&HD0, False)
        m_ActiveFX3.ControlEndPt.Value = m_pinExit
        m_ActiveFX3.ControlEndPt.Index = 0
        'Send command to the DUT to stop streaming data
        XferControlData(buf, 4, 2000)

        'Stop the stream manager thread
        StreamThreadRunning = False

    End Sub

    ''' <summary>
    ''' This function pulls real time data from the DUT over the streaming endpoint. It is intended to operate in its own thread, and should not be called directly
    ''' </summary>
    Private Sub RealTimeStreamManager()

        'The length of one frame, in bytes
        Dim frameLength As Integer
        'The index in the current 1KB buffer
        Dim index As Integer
        'The index in the current frame
        Dim frameIndex As Integer = 0
        'The total number of frames read so far
        Dim totalFrames As Integer = 0
        'Temporary value for converting two bytes to a UShort
        Dim shortValue As UShort
        'The USB transfer size (from the FX3)
        Dim transferSize As Integer
        'List used to construct frames out of the output buffer
        Dim frameBuilder As New List(Of UShort)
        'Bool to track the transfer status
        Dim TransferStatus As Boolean
        'Int to track number of frames read
        Dim framesCounter As Integer

        If m_ActiveFX3.bSuperSpeed Then
            transferSize = 1024
        ElseIf m_ActiveFX3.bHighSpeed Then
            transferSize = 512
        Else
            Throw New Exception("ERROR: Streaming application requires USB 2.0 or 3.0 connection to function")
        End If

        'Buffer to hold data from the FX3
        Dim buf(transferSize - 1) As Byte

        'Set total frames (infinite if less than 1)
        If TotalBuffersToRead < 1 Then
            TotalBuffersToRead = Int32.MaxValue
        End If

        'Determine the frame length based on DUTType
        If m_FX3_SpiConfig.DUTType = DUTType.ADcmXL1021 Then
            'Single Axis
            frameLength = 64 * 1 + 16 + 8 '88
        ElseIf m_FX3_SpiConfig.DUTType = DUTType.ADcmXL2021 Then
            'Two Axis
            frameLength = 64 * 2 + 16 + 8 '152
        Else
            'Three Axis (Default)
            frameLength = 64 * 3 + 8 '200
        End If

        'Set the stream thread running state variable
        StreamThreadRunning = True
        ThreadTerminated = False
        framesCounter = 0

        While StreamThreadRunning
            'Pull 1024 bytes from the DUT
            TransferStatus = StreamingEndPt.XferData(buf, transferSize)
            'Parse the 1024 bytes into frames and add to StreamData if transaction was successful
            If TransferStatus Then
                For index = 0 To transferSize - 2 Step 2
                    'Flip bytes
                    shortValue = buf(index)
                    shortValue = shortValue << 8
                    shortValue = shortValue + buf(index + 1)
                    frameBuilder.Add(shortValue)
                    frameIndex = frameIndex + 2
                    'Once the end of each frame is reached add it to the queue
                    If frameIndex >= frameLength Then
                        StreamData.Enqueue(frameBuilder.ToArray())
                        'Increment shared frame counter
                        Interlocked.Increment(FramesRead)
                        framesCounter = framesCounter + 1
                        'Reset frame builder list
                        frameIndex = 0
                        frameBuilder.Clear()
                        'Check that the total number of specified frames hasn't been read
                        If framesCounter >= TotalBuffersToRead Then
                            'Stop streaming
                            Exit While
                        End If
                    End If
                Next
            Else
                'Exit streaming mode if the transfer fails
                Exit While
            End If
        End While

        'Update streamThreadRunning state variable
        StreamThreadRunning = False
        ThreadTerminated = True

    End Sub


    ''' <summary>
    ''' This function checks the CRC of each frame stored in the Stream Data Queue, and purges the bad ones
    ''' </summary>
    ''' <returns>The success of the data purge operation</returns>
    Public Function PurgeBadFrameData() As Boolean


        Dim purgeSuccess As Boolean = True
        Dim frameDequeued As Boolean = False
        Dim tempQueue As New ConcurrentQueue(Of UShort())
        Dim frame() As UShort = Nothing

        'Only works for ADcmXLx021
        If Not (PartType = DUTType.ADcmXL1021 Or PartType = DUTType.ADcmXL2021 Or PartType = DUTType.ADcmXL3021) Then
            purgeSuccess = False
            Return purgeSuccess
        End If

        'Cannot run while streaming data
        If StreamThreadRunning Then
            purgeSuccess = False
            Return purgeSuccess
        End If

        'Pull data from queue
        numBadFrames = 0
        If purgeSuccess Then
            While Not StreamData.Count = 0
                'Dequeue the frame
                frameDequeued = False
                While Not frameDequeued And StreamData.Count > 0
                    frameDequeued = StreamData.TryDequeue(frame)
                End While
                'Check the CRC
                If CheckDUTCRC(frame) Then
                    tempQueue.Enqueue(frame)
                Else
                    numBadFrames = numBadFrames + 1
                End If
            End While
        End If

        'Set the output queue equal to the temp queue
        StreamData = tempQueue
        FramesRead = StreamData.Count

        Return purgeSuccess

    End Function

#End Region

#Region "Checksum Calculations"
    ''' <summary>
    '''Expecteds bytes in the order they are clocked out of ADcmXLx021
    '''CRC-16-CCITT, initialized with crc = 0xFFFF, No final XOR.
    '''Limit crc accumulation to 16 bits to prevent U32 overflow.
    ''' </summary>
    ''' <param name="ByteData">The input data set to calculate the CRC of</param>
    ''' <returns>The CRC value for the input array</returns>
    Private Function calcCCITT16(ByteData() As Byte) As UInteger
        Dim crc As UInteger = &HFFFF
        Dim poly As UInteger = &H1021
        Dim dat As UInteger
        Dim i As Integer = 0
        Dim j As Integer = 0
        Dim offset As Integer

        For i = 0 To ByteData.Count - 1 Step 2
            For offset = 1 To 0 Step -1
                dat = ByteData(i + offset)
                crc = crc Xor (dat << 8)
                For j = 1 To 8
                    If ((crc And &H8000) = &H8000) Then
                        crc = crc * 2
                        crc = crc Xor poly
                    Else
                        crc = crc * 2
                    End If
                    crc = crc And &HFFFF
                Next
            Next
        Next

        Return crc
    End Function

    ''' <summary>
    ''' Overload for CRC calculation which takes UShort array
    ''' </summary>
    ''' <param name="UShortData">The data to calculate CRC for</param>
    ''' <returns>The CRC value</returns>
    Private Function calcCCITT16(UShortData() As UShort) As UInteger
        'Variable initialization
        Dim crc As UInteger = &HFFFF
        Dim poly As UInteger = &H1021
        Dim dat As UInteger
        Dim i As Integer = 0
        Dim j As Integer = 0
        Dim offset As Integer

        For i = 0 To UShortData.Count - 1
            For offset = 0 To 1
                'get the data
                If offset = 1 Then
                    dat = (UShortData(i) And &HFF00) >> 8
                Else
                    dat = (UShortData(i) And &HFF)
                End If
                crc = crc Xor (dat << 8)
                For j = 1 To 8
                    If ((crc And &H8000) = &H8000) Then
                        crc = crc * 2
                        crc = crc Xor poly
                    Else
                        crc = crc * 2
                    End If
                    crc = crc And &HFFFF
                Next
            Next
        Next

        Return crc

    End Function

    ''' <summary>
    ''' Checks the CRC for a real time frame
    ''' </summary>
    ''' <param name="frame">The frame to check</param>
    ''' <returns>A boolean indicating if the accel. data CRC matches the frame CRC</returns>
    Private Function CheckDUTCRC(ByRef frame() As UShort) As Boolean
        'Read CRC from frame
        Dim DUTCRC As UShort = frame(frame.Count - 1)
        Dim temp As UShort = DUTCRC >> 8
        DUTCRC = DUTCRC << 8
        DUTCRC = DUTCRC + temp
        Dim CRCData As New List(Of UShort)
        'Calculate the CRC
        CRCData.Clear()
        For index = 1 To frame.Count - 4
            CRCData.Add(frame(index))
        Next
        Dim expectedCRC = calcCCITT16(CRCData.ToArray)
        Return (expectedCRC = DUTCRC)
    End Function

#End Region

End Class