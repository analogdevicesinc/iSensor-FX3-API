/*
 ## Analog Devices Inc. FX3 Interface Firmware (AdiFX3Firmware.c)
 ## ===========================
 ##
 ##  Copyright Analog Devices Incorporated, 2018-2019,
 ##  All Rights Reserved
 ##
 ##  THIS SOFTWARE IS BUILT AROUND LIBRARIES DEVELOPED
 ##	 AND MAINTAINED BY CYPRESS INC.
 ##
 ##  Use of this file is governed
 ##  by the license agreement included
 ##	 in this repository.
 ##
 ##	 Juan Chong (juan.chong@analog.com), Alex Nolan (alex.nolan@analog.com)
 ##
 ## ===========================
 */

#include "AdiFX3Firmware.h"

/*
 * Thread and Thread Management Definitions
 */
//Thread for real time streaming function
CyU3PThread streamingThread;

//Thread for generic data capture function
CyU3PThread dataCaptureThread;

//Thread for the main application
CyU3PThread appThread;

//ADI event structure
CyU3PEvent eventHandler;

//ADI GPIO event structure
CyU3PEvent gpioHandler;


/*
 * DMA Channel Definitions
 */
//DMA channel for real time streaming (SPI to USB BULK-IN 0x81)
CyU3PDmaChannel StreamingChannel;

//DMA channel for BULK-OUT endpoint 0x1 (PC to FX3)
CyU3PDmaChannel ChannelFromPC;

//DMA channel for BULK-IN endpoint 0x82 (FX3 to PC)
CyU3PDmaChannel ChannelToPC;


/*
 * Buffer Definitions
 */
//USB Data buffer
uint8_t USBBuffer[4096] __attribute__ ((aligned (32)));

//Bulk endpoint output buffer
uint8_t BulkBuffer[12288] __attribute__ ((aligned (32)));


/*
 * Application Configuration Definitions
 */
//Global variable to track the SPI configuration
CyU3PSpiConfig_t spiConfig;

//DMA buffer structure for output buffer
CyU3PDmaBuffer_t ManualDMABuffer;

//Global to track the part type
PartType DUTType;


/*
 * Application constants
 */
//Constant firmware ID string. Manually updated when building new firmware.
const uint8_t FirmwareID[32] __attribute__ ((aligned (32))) = { 'A', 'D', 'I', ' ', 'F', 'X', '3', ' ', 'R', 'E', 'V', ' ', '1', '.', '9','\0' };

//Constant error string used to write "ERROR" to output buffer
const uint8_t ErrorString[16] __attribute__ ((aligned (16))) = { 'E', 'R', 'R', 'O', 'R', '\0'};


/*
 * Runtime Global Variables
 */
//Track the number of errors which have occurred during FX3 boot process
uint32_t errorCount = 0;

//Flag to track main application execution (True = active, False = inactive)
CyBool_t appActive = CyFalse;

//Track the number of real-time captures to record (0 = Infinite)
uint32_t numRealTimeCaptures = 0;

//Track the number of bytes per real time frame
uint32_t bytesPerFrame = 200;

//Track the stall time in ticks
uint32_t stallTime;

//Track the busy pin number
uint16_t busyPin = 4;

//Track the data ready pin number
uint16_t dataReadyPin = 3;

//Track if data ready is active (True = active, False = inactive)
CyBool_t DrActive = CyFalse;

//Track data ready polarity (True = rising, False = falling)
CyBool_t DrPolarity = CyTrue;

//Track the pin exit setting for RT stream mode (True = enabled, False = disabled)
CyBool_t pinExitEnableDisable = CyFalse;

//Track the pin start setting for RT stream mode (True = enabled, False = disabled)
CyBool_t pinStartEnableDisable = CyFalse;

//Signal RT thread to kill data capture early (True = kill thread signaled, False = allow execution)
CyBool_t killEarly = CyFalse;

//Track the total size of generic stream transfer
uint16_t transferLength = 0;

//Track the number of captures requested for the generic data stream
uint32_t numCaptures = 0;

//Track the number of buffers requested for the generic data stream
uint32_t numBuffers = 0;

//Track the number of bytes to be read per buffer
uint16_t bytesPerBuffer = 0;

//Pointer to byte array of registers needing to be read by the generic data stream
uint8_t *regList;


/*
 * Function: AdiControlEndpointHandler (uint32_t setupdat0, uint32_t setupdat1)
 *
 * This function handles events generated by the control endpoint. All vendor requests are handled
 * in this function.
 *
 * setupdat0: The first set of setup data
 *
 * setupdat1: The second set of setup data
 *
 * Returns: A boolean indicating if the control endpoint event was handled properly
 */
CyBool_t AdiControlEndpointHandler (uint32_t setupdat0, uint32_t setupdat1)
{
    /* Fast enumeration is used. Only requests addressed to the interface, class,
     * vendor and unknown control requests are received by this function. */

    uint8_t  bRequest, bReqType;
    uint8_t  bType, bTarget;
    uint16_t wValue, wIndex, wLength;
    CyBool_t isHandled = CyFalse;
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
    uint16_t *bytesRead = 0;

    //Parse the control request data from the packets received
    bReqType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
    bType    = (bReqType & CY_U3P_USB_TYPE_MASK);
    bTarget  = (bReqType & CY_U3P_USB_TARGET_MASK);
    bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
    wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
    wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
    wLength   = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)   >> CY_U3P_USB_LENGTH_POS);

    //Handle vendor requests
    if (bType == CY_U3P_USB_VENDOR_RQT)
    {
        isHandled = CyTrue;

        switch (bRequest)
        {
        	//Bulk register read/write using RegReadArray
        	case ADI_BULK_REGISTER_TRANSFER:
        		CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
        		status = AdiBulkByteTransfer(wIndex, wValue);
        		break;

        	//Read bytes for IRegInterface
        	case ADI_READ_BYTES:
        		status = AdiReadRegBytes(wIndex);
        		break;

        	//Write single byte for IRegInterface
        	case ADI_WRITE_BYTE:
        		status = AdiWriteRegByte(wIndex, wValue & 0xFF);
        		USBBuffer[0] = status & 0xFF;
        		USBBuffer[1] = (status & 0xFF00) >> 8;
        		USBBuffer[2] = (status & 0xFF0000) >> 16;
        		USBBuffer[3] = (status & 0xFF000000) >> 24;
        		CyU3PUsbSendEP0Data (wLength, USBBuffer);
        		break;

        	//Pulse drive for a specified amount of time
        	case ADI_PULSE_DRIVE:
        		//Read config data into USBBuffer
        		CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
        		//Run pulse drive function
        		status = AdiPulseDrive();
        		//Send back status over the BULK-In endpoint
            	USBBuffer[0] = status & 0xFF;
            	USBBuffer[1] = (status & 0xFF00) >> 8;
            	USBBuffer[2] = (status & 0xFF0000) >> 16;
            	USBBuffer[3] = (status & 0xFF000000) >> 24;
            	ManualDMABuffer.buffer = USBBuffer;
            	ManualDMABuffer.size = 4096;
            	ManualDMABuffer.count = 4;
            	CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);
        		break;

        	//Wait on an edge, with timeout
        	case ADI_PULSE_WAIT:
        		//Read config data into USBBuffer
        		CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
        		//Run pulse wait function
        		status = AdiPulseWait();
        		USBBuffer[0] = status & 0xFF;
				USBBuffer[1] = (status & 0xFF00) >> 8;
				USBBuffer[2] = (status & 0xFF0000) >> 16;
				USBBuffer[3] = (status & 0xFF000000) >> 24;
				CyU3PUsbSendEP0Data (wLength, USBBuffer);
        		break;

        	//Set a pin
        	case ADI_SET_PIN:
        		status = AdiSetPin(wIndex, (CyBool_t) wValue);
            	USBBuffer[0] = status & 0xFF;
            	USBBuffer[1] = (status & 0xFF00) >> 8;
            	USBBuffer[2] = (status & 0xFF0000) >> 16;
            	USBBuffer[3] = (status & 0xFF000000) >> 24;
            	CyU3PUsbSendEP0Data (wLength, USBBuffer);
        		break;

        	//ID Check
            case ADI_FIRMWARE_ID_CHECK:
                status = CyU3PUsbSendEP0Data (32, (uint8_t *)FirmwareID);
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
                break;

            //Firmware Reset
            case ADI_FIRMWARE_RESET:
            	CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
            	CyU3PDeviceReset(CyFalse);
            	break;

            //Set the SPI config
            case ADI_SET_SPI_CONFIG:
            	isHandled = AdiSpiUpdate(wIndex, wValue, wLength);
            	break;

            //Read a GPIO pin specified by index
            case ADI_READ_PIN:
            	status = AdiPinRead(wIndex);
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Read the current SPI config
            case ADI_READ_SPI_CONFIG:
            	status = AdiGetSpiSettings();
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Real time stream control. Index will start(1)/stop(0) the stream, and value will enable(1)/disable(0) pin exit
            case ADI_STREAM_REALTIME:
            	if (wIndex)
            	{
            		pinExitEnableDisable = (CyBool_t) wValue;
            		status = CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_START, CYU3P_EVENT_OR);
            	}
            	else
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_STOP, CYU3P_EVENT_OR);
            	}
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Read the value from the complex GPIO timer
            case ADI_READ_TIMER_VALUE:
            	status = AdiReadTimerValue();
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Command to do nothing
            case ADI_NULL_COMMAND:
            	isHandled = CyTrue;
            	break;

            //Get the current status of the FX3
            case ADI_GET_STATUS:
            	USBBuffer[0] = status & 0xFF;
            	USBBuffer[1] = (status & 0xFF00) >> 8;
            	USBBuffer[2] = (status & 0xFF0000) >> 16;
            	USBBuffer[3] = (status & 0xFF000000) >> 24;
            	CyU3PUsbSendEP0Data (4, USBBuffer);
            	break;

            //Start a register stream triggered on data ready
            case ADI_STREAM_GENERIC_DATA:
            	if (wIndex)
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_DATA_STREAMING_START, CYU3P_EVENT_OR);
            		transferLength = wLength;
            	}
            	else
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_DATA_STREAMING_STOP, CYU3P_EVENT_OR);
            	}
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

			//Burst stream control. Index will start(1)/stop(0) the stream
			case ADI_STREAM_BURST_DATA:
				if (wIndex)
				{
					status = CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_START, CYU3P_EVENT_OR);
				}
				else
				{
					status = CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_STOP, CYU3P_EVENT_OR);
				}
				if (status != CY_U3P_SUCCESS)
				{
					isHandled = CyFalse;
				}
				break;

			//Get the measured DR frequency
            case ADI_MEASURE_DR:
            	//Read config data into USBBuffer
				CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
				//Run pulse drive function
				status = AdiMeasureDR();
				break;

            default:
                // This is unknown request
                isHandled = CyFalse;
                break;
        }

        if (bType == CY_U3P_USB_STANDARD_RQT)
        {
            /* Handle SET_FEATURE(FUNCTION_SUSPEND) and CLEAR_FEATURE(FUNCTION_SUSPEND)
             * requests here. It should be allowed to pass if the device is in configured
             * state and failed otherwise. */
            if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
                        || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
            {
                if (appActive)
                    CyU3PUsbAckSetup ();
                else
                    CyU3PUsbStall (0, CyTrue, CyFalse);

                isHandled = CyTrue;
            }

            if(bTarget == CY_U3P_USB_TARGET_ENDPT)
            {
            	isHandled = CyTrue;
            }
        }

        //If there was an error return false to stall the request
        if (status != CY_U3P_SUCCESS)
        {
            isHandled = CyFalse;
        }
    }
    return isHandled;
}

/*
 * Function: AdiReadRegBytes(uint16_t addr)
 *
 * This function reads a single word over SPI
 *
 * addr: The address to send to the DUT in the first SPI transaction
 *
 * Returns: The status of the SPI register read operation
 */
CyU3PReturnStatus_t AdiReadRegBytes(uint16_t addr)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t tempBuffer[2];

	//Set the address
	tempBuffer[0] = (0x7F) & addr;
	//Set the second byte to 0's
	tempBuffer[1] = 0;
	//Send SPI Read command
	status = CyU3PSpiTransmitWords(tempBuffer, 2);
	//Check that the transfer was successful, end function if failed
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Stall
	AdiWaitForTimerTicks(stallTime);

	//Receive the data in the next frame
	status = CyU3PSpiReceiveWords(tempBuffer, 2);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Send data back via control endpoint
	status = CyU3PUsbSendEP0Data(2, tempBuffer);

	return status;
}

/*
 * Function: AdiWriteRegByte(uint16_t addr, uint8_t data)
 *
 * This function writes a single byte of data over the SPI bus
 *
 * addr: The address to write data to
 *
 * data: The byte of data to write to the address
 *
 * Returns: The success of the SPI write operation
 */
CyU3PReturnStatus_t AdiWriteRegByte(uint16_t addr, uint8_t data)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t buffer[2];
	buffer[0] = 0x80 | addr;
	buffer[1] = data;
	status = CyU3PSpiTransmitWords(buffer, 2);
	return status;
}

/*
 * Function: AdiPulseDrive()
 *
 * This function drives a GPIO pin for a specified number of milliseconds. If the
 * selected GPIO pin is not configured as an output, this function configures the pin.
 *
 * pin: The GPIO pin number to drive
 *
 * polarity: The polarity of the pin (True - High, False - Low)
 *
 * driveTime: The number of milliseconds to drive the pin for
 *
 * Returns: The status of the pin drive operation
 */
CyU3PReturnStatus_t AdiPulseDrive()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pin;
	CyBool_t polarity, timerRollover;
	uint32_t driveTime, endTime, currentTime, startTime;

	//Parse request data from USBBuffer
	pin = USBBuffer[0];
	pin = pin + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	driveTime = USBBuffer[3];
	driveTime = driveTime + (USBBuffer[4] << 8);
	driveTime = driveTime + (USBBuffer[5] << 16);
	driveTime = driveTime + (USBBuffer[6] << 24);

	//Configure the GPIO pin as a driven output
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = polarity;
	gpioConfig.inputEn = CyFalse;
	gpioConfig.driveLowEn = CyTrue;
	gpioConfig.driveHighEn = CyTrue;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	//Get the start time
	CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &startTime);
	currentTime = startTime;

	status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

	//If config fails try to override and reconfigure
	if(status != CY_U3P_SUCCESS)
	{
		status = CyU3PDeviceGpioOverride (pin, CyTrue);
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);
	}

	//Check that the pin is configured to act as an output, return if not
	status = CyU3PGpioSimpleSetValue(pin, polarity);
	if(status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Convert ms to ticks
	driveTime = AdiMStoTicks(driveTime);

	//Calculate if rollover will occur on system timer
	timerRollover = (driveTime > 0 && (startTime > (0xFFFFFFFF - driveTime)));

	//Drive the pin for the specified time
	if(timerRollover)
	{
		//Calculate the end time given that overflow will occur
		endTime = driveTime - (0xFFFFFFFF - startTime);
		while(currentTime <= endTime || currentTime >= startTime)
		{
			//Read the timer value
			CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
			//Drive the GPIO pin
			CyU3PGpioSimpleSetValue(pin, polarity);
		}
	}
	else
	{
		endTime = startTime + driveTime;
		while(currentTime <= endTime)
		{
			//Read the timer value
			CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
			//Drive the GPIO pin
			CyU3PGpioSimpleSetValue(pin, polarity);
		}
	}

	//Reset pin to original state
	CyU3PGpioSimpleSetValue(pin, !polarity);

	//Stop pin output drive and enable as input
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

	//return the status
	return status;
}

/*
 * Function: AdiBulkByteTransfer()
 *
 * This function performs a bulk register transfer using the bulk in and out endpoints.
 * It handles function calls in the IRegInterface which require more than one register
 * read/write operation.
 *
 * Returns: The status of the transfer operation
 */
CyU3PReturnStatus_t AdiBulkByteTransfer(uint16_t numBytes, uint16_t bytesPerCapture)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t loopCounter = 0;
	uint8_t buffValue;
	uint8_t *bufPntr;
	uint8_t TxBuffer[2];
	uint32_t transferStatus = 0;
	CyU3PGpioIntrMode_t waitType = CY_U3P_GPIO_INTR_POS_EDGE;

	//Transfer in data via ChannelFromPC
	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = numBytes;
	ManualDMABuffer.status = 0;

	status = CyU3PDmaChannelSetupRecvBuffer(&ChannelFromPC, &ManualDMABuffer);

	//Wait for the DMA channel to finish (20ms timeout)
	while(transferStatus != CY_U3P_DMA_CB_RECV_CPLT && loopCounter < 4)
	{
		CyU3PEventGet(&(ChannelFromPC.flags), CY_U3P_DMA_CB_RECV_CPLT,  CYU3P_EVENT_OR, &transferStatus, 5);
		loopCounter++;
	}

	//Reset the DMA channel
	CyU3PDmaChannelReset(&ChannelFromPC);

	//Set the bytesPerCapture depending on DrActive
	if(!DrActive)
	{
		bytesPerCapture = numBytes;
	}
	else
	{
		//Set the transition type depending on the DrPolarity
		if(DrPolarity)
		{
			waitType = CY_U3P_GPIO_INTR_POS_EDGE;;
		}
		else
		{
			waitType = CY_U3P_GPIO_INTR_NEG_EDGE;
		}
	}

	//Loop through rest of the transfers
	bufPntr = BulkBuffer;
	loopCounter = 0;
	while(loopCounter < numBytes)
	{
		//Wait for data ready if needed and run through one set of registers
		if(DrActive)
		{
			AdiWaitForPin(dataReadyPin, waitType, CYU3P_WAIT_FOREVER);
		}
		//For first transfer don't read back
		if(BulkBuffer[loopCounter] & 0x80)
		{
			//Case of a SPI write
			TxBuffer[0] = BulkBuffer[loopCounter];
			TxBuffer[1] = BulkBuffer[loopCounter + 1];
			CyU3PSpiTransmitWords(TxBuffer, 2);
			BulkBuffer[loopCounter] = 0;
			BulkBuffer[loopCounter + 1] = 0;
		}
		else
		{
			//Case of a SPI read
			TxBuffer[0] = BulkBuffer[loopCounter];
			TxBuffer[1] = 0;
			CyU3PSpiTransmitWords(TxBuffer, 2);
		}
		loopCounter+=2;
		AdiWaitForTimerTicks(stallTime);

		//Loop through rest of the reads
		while(loopCounter < bytesPerCapture)
		{
			//Get the value out of the bulk buffer
			buffValue = BulkBuffer[loopCounter];

			if(buffValue & 0x80)
			{
				//If its a write command, perform write
				//perform SPI write
				TxBuffer[0] = buffValue;
				TxBuffer[1] = BulkBuffer[loopCounter + 1];
				CyU3PSpiTransmitWords(TxBuffer, 2);
				//Store 0 in the Bulk Buffer
				BulkBuffer[loopCounter] = 0;
				BulkBuffer[loopCounter + 1] = 0;
			}
			else
			{
				//If it's a read command, perform SPI read and write and store value in bulk buffer
				TxBuffer[0] = buffValue;
				TxBuffer[1] = 0;
				CyU3PSpiTransferWords(TxBuffer, 2, bufPntr, 2);
			}
			bufPntr += 2;
			loopCounter += 2;
			AdiWaitForTimerTicks(stallTime);
		}
		//Receive the last two bytes
		if(buffValue & 0x80)
		{
			BulkBuffer[loopCounter] = 0;
			BulkBuffer[loopCounter + 1] = 0;
		}
		else
		{
			CyU3PSpiReceiveWords(bufPntr, 2);
		}
		//Increment loop counter
		loopCounter += 2;
	}

	//Send the data back over ChannelToPC
	status = CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}

/*
 * Function: AdiPulseWait(uint16_t pin, CyBool_t polarity, uint32_t driveTime)
 *
 * This function drives a GPIO pin for a specified number of milliseconds. If the
 * selected GPIO pin is not configured as an output, this function configures the pin.
 *
 * pin: The GPIO pin number to drive
 *
 * polarity: The polarity of the pin (True - High, False - Low)
 *
 * driveTime: The number of milliseconds to drive the pin for
 *
 * Returns: The status of the pin drive operation
 */
CyU3PReturnStatus_t AdiPulseWait()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pin;
	CyBool_t polarity, validPin, pinValue, delayRollover, sampleRollover;
	uint32_t timeWaited = 0;
	uint32_t startTime, currentTime, sampleStartTime, sampleEndTime, delay, timeout;

	//Get the operation start time
	CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &startTime);
	currentTime = startTime;

	//Parse request data from USBBuffer
	pin = USBBuffer[0];
	pin = pin + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	delay = USBBuffer[3];
	delay = delay + (USBBuffer[4] << 8);
	delay = delay + (USBBuffer[5] << 16);
	delay = delay + (USBBuffer[6] << 24);
	timeout = USBBuffer[7];
	timeout = timeout + (USBBuffer[8] << 8);
	timeout = timeout + (USBBuffer[9] << 16);
	timeout = timeout + (USBBuffer[10] << 24);

	//Convert ms to timer ticks
	delay = AdiMStoTicks(delay);
	timeout = AdiMStoTicks(timeout);

	//Calculate if timer rollover is going to occur for sample period
	sampleRollover = ((delay + timeout) > 0 && (startTime > (0xFFFFFFFF - (delay + timeout))));

	//Calculate the sample period end time
	if(sampleRollover)
	{
		sampleEndTime = (delay + timeout) - (0xFFFFFFFF - startTime);
	}
	else
	{
		sampleEndTime = delay + timeout + startTime;
	}

	//Calculate if delay rollover will occur
	delayRollover = (delay > 0 && (startTime > (0xFFFFFFFF - delay)));

	//Calculate the delay period end time
	if(delayRollover)
	{
		sampleStartTime = delay - (0xFFFFFFFF - startTime);
	}
	else
	{
		sampleStartTime = startTime + delay;
	}

	//Check that input pin specified is configured as input
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	validPin = CyTrue;
	if(status != CY_U3P_SUCCESS)
	{
		//If initial pin read fails try and configure as input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

		//get the pin value again after configuring
		status = CyU3PGpioSimpleGetValue(pin, &pinValue);

		//If pin setup not successful skip wait operation and return -1
		if(status != CY_U3P_SUCCESS)
		{
			validPin = CyFalse;
		}
	}

	//If the pin is properly configured the wait for edge
	if(validPin)
	{
		//Wait for the delay, if needed
		if(delay)
		{
			if(delayRollover)
			{
				while(currentTime >= startTime || currentTime <= sampleStartTime)
				{
					CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
				}
			}
			else
			{
				while(currentTime <= sampleStartTime)
				{
					CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
				}
			}
		}

		//Poll the input pin until reaches polarity or timer runs out
		if(timeout)
		{
			if(sampleRollover)
			{
				while(pinValue != polarity && (currentTime >= startTime || currentTime <= sampleEndTime))
				{
					CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
					CyU3PGpioSimpleGetValue(pin, &pinValue);
				}
			}
			else
			{
				while(pinValue != polarity && currentTime < sampleEndTime)
				{
					CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
					CyU3PGpioSimpleGetValue(pin, &pinValue);
				}
			}
		}
		//If timeout is 0 treat it like there is no timeout
		else
		{
			while(pinValue != polarity)
			{
				CyU3PGpioSimpleGetValue(pin, &pinValue);
			}
		}
		//Calculate the time waited
		CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
		if (currentTime > startTime)
		{
			timeWaited = currentTime - startTime;
		}
		else
		{
			timeWaited = currentTime + (0xFFFFFFFF - startTime);
		}

	}
	else
	{
		//Set the wait time to max when invalid pin is specified
		timeWaited = 0xFFFFFFFF;
	}

	//Return time waited over ChannelToPC
	BulkBuffer[0] = timeWaited & 0xFF;
	BulkBuffer[1] = (timeWaited & 0xFF00) >> 8;
	BulkBuffer[2] = (timeWaited & 0xFF0000) >> 16;
	BulkBuffer[3] = (timeWaited & 0xFF000000) >> 24;
	BulkBuffer[4] = MS_TO_TICKS_MULT & 0xFF;
	BulkBuffer[5] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	BulkBuffer[6] = (MS_TO_TICKS_MULT & 0xFF00) >> 16;
	BulkBuffer[7] = (MS_TO_TICKS_MULT & 0xFF00) >> 24;

	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = 8;

	//Send the data to PC
	CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}


/*
 * Function: AdiSetPin(uint16_t pinNumber, CyBool_t polarity)
 *
 * This function configures the specified pin as an output and sets the value
 *
 * pinNumber: The GPIO index of the pin to be set
 *
 * polarity: The polarity of the pin to be set (True - High, False - Low)
 *
 * Returns: The status of the operation
 */
CyU3PReturnStatus_t AdiSetPin(uint16_t pinNumber, CyBool_t polarity)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	//Configure pin as output and set the drive value
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = polarity;
	gpioConfig.inputEn = CyFalse;
	gpioConfig.driveLowEn = CyTrue;
	gpioConfig.driveHighEn = CyTrue;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);
	return status;
}

/*
 * Function: AdiWaitForTimerTicks(uint32_t numTicks)
 *
 * This function blocks thread execution for a specified number of timer ticks.
 * It uses a complex GPIO timer which is based on the system clock.
 *
 * numTicks: The number of timer ticks to wait for.
 *
 * Returns: void
 */
void AdiWaitForTimerTicks(uint32_t numTicks)
{
	uint32_t startTime, endTime, currentTime, initialRegValue;
	CyBool_t timerRollover = CyFalse;
	uint8_t pinIndex;

	//Get the pin index
	pinIndex = ADI_TIMER_PIN % 8;
	//Get the initial pin config
	initialRegValue = (GPIO->lpp_gpio_pin[pinIndex].status & ~CY_U3P_LPP_GPIO_INTR);
	//Set the pin config for sample now mode
	GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
	//wait for sample to finish
	while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
	//read timer value
	startTime = GPIO->lpp_gpio_pin[pinIndex].threshold;
	//set current time to start time
	currentTime = startTime;

	//Check for overflow
	timerRollover = (numTicks > 0 && (startTime > (0xFFFFFFFF - numTicks)));

	//Calculate the end time
	if(timerRollover)
	{
		endTime = numTicks - (0xFFFFFFFF - startTime);
		while(currentTime <= endTime || currentTime >= startTime)
		{
			//Get the initial pin config
			initialRegValue = (GPIO->lpp_gpio_pin[pinIndex].status & ~CY_U3P_LPP_GPIO_INTR);
			//Set the pin config for sample now mode
			GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
			//wait for sample to finish
			while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
			//read timer value
			currentTime = GPIO->lpp_gpio_pin[pinIndex].threshold;
		}
	}
	else
	{
		endTime = startTime + numTicks;
		while(CyTrue)
		{
			//Get the initial pin config
			initialRegValue = (GPIO->lpp_gpio_pin[pinIndex].status & ~CY_U3P_LPP_GPIO_INTR);
			//Set the pin config for sample now mode
			GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
			//wait for sample to finish
			while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
			//read timer value
			currentTime = GPIO->lpp_gpio_pin[pinIndex].threshold;
			//Return if timer elapsed
			if(currentTime > endTime)
			{
				return;
			}
		}
	}
}

/*
 * Function: AdiWaitForPin(uint32_t pinNumber, PinWaitType waitType)
 *
 * This function blocks the execution of the current thread until an event happens on the
 * specified GPIO pin.
 *
 * pinNumber: The GPIO pin number to poll
 *
 * waitType: The event type to wait for, as a PinWaitType
 *
 * Returns: void
 */
CyU3PReturnStatus_t AdiWaitForPin(uint32_t pinNumber, CyU3PGpioIntrMode_t interruptSetting, uint32_t timeoutTicks)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t gpioEventFlag;
	CyU3PGpioSimpleConfig_t gpioConfig;

	//Configure the specified pin as an input and attach the correct pin interrupt
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = interruptSetting;

	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);

	//Catch unspecified timeout
	if (timeoutTicks == 0)
	{
		timeoutTicks = CYU3P_WAIT_FOREVER;
	}

	if (status == CY_U3P_SUCCESS)
	{
		//Enable GPIO interrupts (in case it's not enabled)
		CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
		//Wait for GPIO interrupt flag
		status = CyU3PEventGet(&gpioHandler, pinNumber, CYU3P_EVENT_OR_CLEAR, &gpioEventFlag, timeoutTicks);
		//Disable GPIO interrupts until we need them again
		CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	}
	return status;
}

/*
 * Function: AdiMStoTicks(uint32_t timeInMS)
 *
 * Converts milliseconds to number of ticks and adjusts the resulting offset if below the
 * measurable minimum.
 *
 * timeInMS: The real stall time (in ms) desired. Minimum measurable ticks is 14 microseconds.
 */
uint32_t AdiMStoTicks(uint32_t timeInMS)
{
	uint32_t tempTicks = (timeInMS * MS_TO_TICKS_MULT);

	if(tempTicks > ADI_STALL_OFFSET)
	{
		tempTicks = tempTicks - ADI_STALL_OFFSET;
	}

	return tempTicks;
}

/*
 * Function: AdiPinRead(uint16_t pin)
 *
 * This function handles Pin read control end point requests. It reads the value of a specified
 * GPIO pin, and sends that value over the control endpoint, along with the pin read status.
 *
 * Returns: The success of the pin read operation
 */
CyU3PReturnStatus_t AdiPinRead(uint16_t pin)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyBool_t pinValue = CyFalse;

	//get the pin value
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	if(status != CY_U3P_SUCCESS)
	{
		//If the initial pin read fails reconfigure the pin as in input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);
		//If the config is successful, read the pin value
		if(status == CY_U3P_SUCCESS)
		{
			status = CyU3PGpioSimpleGetValue(pin, &pinValue);
		}
	}

	//Put pin register value in output buffer
	USBBuffer[0] = pinValue;
	USBBuffer[1] = status & 0xFF;
	USBBuffer[2] = (status & 0xFF00) >> 8;
	USBBuffer[3] = (status & 0xFF0000) >> 16;
	USBBuffer[4] = (status & 0xFF000000) >> 24;
	//Send the pin value
	CyU3PUsbSendEP0Data (5, (uint8_t *)USBBuffer);
	//Send a packet terminate
	CyU3PUsbSendEP0Data (0, NULL);
	return status;
}

/*
 * Function: AdiReadTimerValue()
 *
 * This function handles Timer read control endpoint requests. It reads the current value from the
 * complex GPIO timer and then sends the value over the control endpoint.
 *
 * Returns: The success of the timer read operation
 */
CyU3PReturnStatus_t AdiReadTimerValue()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t timerValue;
	status = CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &timerValue);
	if(status != CY_U3P_SUCCESS)
	{
		return status;
	}
	USBBuffer[0] = timerValue & 0xFF;
	USBBuffer[1] = (timerValue & 0xFF00) >> 8;
	USBBuffer[2] = (timerValue & 0xFF0000) >> 16;
	USBBuffer[3] = (timerValue & 0xFF000000) >> 24;
	status = CyU3PUsbSendEP0Data (4, USBBuffer);
	return status;
}

/*
 * Function: AdiRealTimeStart()
 *
 * This function kicks off a real-time stream by configuring interrupts, SPI, and end points.
 * It also optionally toggles the SYNC/RTS pin if requested. At the end of the function, the
 * bit assigned to enable the capture thread is toggled to signal the streaming thread to start producing data.
 *
 * Returns: The status of starting a real-time stream.
 */
CyU3PReturnStatus_t AdiRealTimeStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;
	uint8_t tempWriteBuffer[2];
	uint8_t tempReadBuffer[2];

	//Make sure the BUSY pin is configured as input (DIO2)
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyFalse;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	CyU3PGpioSetSimpleConfig(dataReadyPin, &gpioConfig);

	//Disable GPIO ISR
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	//Disable VBUS ISR
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	//Get number of frames to capture from control endpoint
	CyU3PUsbGetEP0Data(5, USBBuffer, &bytesRead);
	numRealTimeCaptures = USBBuffer[0];
	numRealTimeCaptures += (USBBuffer[1] << 8);
	numRealTimeCaptures += (USBBuffer[2] << 16);
	numRealTimeCaptures += (USBBuffer[3] << 24);

	//Get pin start setting
	pinStartEnableDisable = (CyBool_t) USBBuffer[4];

	//Clear the DMA buffers
	CyU3PDmaChannelReset(&StreamingChannel);

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	if(pinExitEnableDisable)
	{
		//Disable starting the capture by raising SYNC/RTS
		//If this is not done before setting SYNC/RTS high, things will break

		//If pin start is disabled (we're starting the capture with GLOB_CMD)
		if(!pinStartEnableDisable)
		{
			//Read MSC_CTRL register
			tempReadBuffer[0] = (0x64);
			tempReadBuffer[1] = (0x00);
			status = CyU3PSpiTransmitWords(tempReadBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
						return status;
			}
			AdiWaitForTimerTicks(stallTime);
			status = CyU3PSpiReceiveWords(tempReadBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiWaitForTimerTicks(stallTime);

			//Clear bit 12 (bit enables/disables starting a capture using SYNC pin)
			tempReadBuffer[0] = tempReadBuffer[0] & (0xEF);

			//Write modified buffer to MSC_CTRL
			tempWriteBuffer[0] = (0x80) | (0x64);
			tempWriteBuffer[1] = tempReadBuffer[1];
			status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiWaitForTimerTicks(stallTime);
			tempWriteBuffer[0] = (0x80) | (0x65);
			tempWriteBuffer[1] = tempReadBuffer[0];
			status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiWaitForTimerTicks(stallTime);

			//Configure SYNC/RTS as an output and set high
			CyU3PGpioSimpleConfig_t gpioConfig;
			gpioConfig.outValue = CyTrue;
			gpioConfig.inputEn = CyFalse;
			gpioConfig.driveLowEn = CyTrue;
			gpioConfig.driveHighEn = CyTrue;
			gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
			status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

			//If config fails try to override and reconfigure
			if(status != CY_U3P_SUCCESS)
			{
				status = CyU3PDeviceGpioOverride (busyPin, CyTrue);
				status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);
			}

			//Check that the pin is configured to act as an output, return if not
			status = CyU3PGpioSimpleSetValue(busyPin, CyTrue);
			if(status != CY_U3P_SUCCESS)
			{
				return status;
			}
		}
	}

	//If pin start is enabled, set bit 12 in MISC_CTRL and toggle SYNC, otherwise send 0x0800 to COMMAND
	if(pinStartEnableDisable)
	{
		//Read MSC_CTRL register
		tempReadBuffer[0] = (0x64);
		tempReadBuffer[1] = (0x00);
		status = CyU3PSpiTransmitWords(tempReadBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
					return status;
		}
		AdiWaitForTimerTicks(stallTime);
		status = CyU3PSpiReceiveWords(tempReadBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiWaitForTimerTicks(stallTime);

		//Set bit 12 (bit enables/disables starting a capture using SYNC pin)
		tempReadBuffer[0] = tempReadBuffer[0] | (0x10);

		//Write modified buffer to MSC_CTRL
		tempWriteBuffer[0] = (0x80) | (0x64);
		tempWriteBuffer[1] = tempReadBuffer[1];
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiWaitForTimerTicks(stallTime);
		tempWriteBuffer[0] = (0x80) | (0x65);
		tempWriteBuffer[1] = tempReadBuffer[0];
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiWaitForTimerTicks(stallTime);

		//Configure SYNC/RTS as an output and set high
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyTrue;
		gpioConfig.inputEn = CyFalse;
		gpioConfig.driveLowEn = CyTrue;
		gpioConfig.driveHighEn = CyTrue;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

		//If config fails try to override and reconfigure
		if(status != CY_U3P_SUCCESS)
		{
			status = CyU3PDeviceGpioOverride (busyPin, CyTrue);
			status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);
		}

		//Check that the pin is configured to act as an output, return if not
		status = CyU3PGpioSimpleSetValue(busyPin, CyTrue);
		if(status != CY_U3P_SUCCESS)
		{
			return status;
		}
	}
	else
	{
		//Send COMMAND 0x800
		//Command is Page 0, Address 62
		tempWriteBuffer[0] = (0x80) | (0x3E);
		tempWriteBuffer[1] = 0;
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiWaitForTimerTicks(stallTime);
		tempWriteBuffer[0] = (0x80) | (0x3F);
		tempWriteBuffer[1] = 0x08;
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiWaitForTimerTicks(stallTime);
	}

	//Set the SPI config for streaming mode
	spiConfig.ssnCtrl = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
	spiConfig.wordLen = 8;
	CyU3PSpiSetConfig (&spiConfig, NULL);

	//Set infinite DMA transfer on streaming channel
	CyU3PDmaChannelSetXfer(&StreamingChannel, 0);

	//Set the real-time data capture thread flag
	CyU3PEventSet (&eventHandler, ADI_REAL_TIME_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;

}

/*
 * Function: AdiRealTimeFinished()
 *
 * This function cleans up after a real-time stream by resetting the SPI port, triggering the SYNC/RTS pin (if asked to do so),
 * and notifying the host that the cancel operation was successful.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiRealTimeFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//CyU3PThreadPriorityChange(&streamingThread, 8, threadPriority);

	//Pull SYNC/RTS pin low to force x021 out of RT mode
	if(pinExitEnableDisable || pinStartEnableDisable)
	{
		//Configure SYNC/RTS as an output and set high
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyFalse;
		gpioConfig.driveLowEn = CyTrue;
		gpioConfig.driveHighEn = CyTrue;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

		//Reset flag for next run
		pinExitEnableDisable = CyFalse;
	}

	//Stop pin output drive and enable as input
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

	//Disable SPI DMA mode
	CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);

	//Reset the SPI controller
	SPI->lpp_spi_config &= ~(CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_ENABLE);
	while ((SPI->lpp_spi_config & CY_U3P_LPP_SPI_ENABLE) != 0);

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	//Clear all interrupt flags
	CyU3PVicClearInt();

	//Re-enable relevant ISRs
	CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	CyU3PVicEnableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	//Additional clean-up after a user requests an early cancellation
	if(killEarly)
	{
		//Send status back over control endpoint to end USB transaction and signal cancel was completed successfully
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		//Reset killEarly flag in case the user wants to capture data again
		killEarly = CyFalse;
	}

	return status;
}

/*
 * Function: AdiRealTimeStop()
 *
 * This function sets a flag to notify the streaming thread that the user requested to cancel the streaming operation.
 * Note that this flag is also used in the generic stream.
 *
 * Returns: void
 *
 */
void AdiRealTimeStop()
{

	killEarly = CyTrue;

}

/*
 * Function: AdiBurstStreamStart()
 *
 * This function kicks off a burst stream by configuring a pin interrupt on a user-specified pin, configuring
 * the SPI and USB DMAs to handle the incoming data, and enabling the streaming function.
 * It can be configured for "Blackfin" or "ADuC" burst using vendor requests.
 *
 * Returns: The status of starting a real-time stream.
 */
CyU3PReturnStatus_t AdiBurstStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;
	uint16_t burstLength;

	//Disable GPIO interrupt before attaching interrupt to pin
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	//Make sure the global data ready pin is configured as an input and attach the correct pin interrupt
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	if (DrPolarity)
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_NEG_EDGE;
	}
	else
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	}

	CyU3PGpioSetSimpleConfig(dataReadyPin, &gpioConfig);

	//Get number of frames to capture from control endpoint
	CyU3PUsbGetEP0Data(8, USBBuffer, &bytesRead);
	numBuffers = USBBuffer[0];
	numBuffers += (USBBuffer[1] << 8);
	numBuffers += (USBBuffer[2] << 16);
	numBuffers += (USBBuffer[3] << 24);

	//Get number of words per burst transfer (minus the trigger word)
	burstLength = USBBuffer[6];
	burstLength += (USBBuffer[7] << 8);

	//Set regList memory to correct length minus trigger word. We're going to overwrite the first
	//two bytes with the trigger word, so make the burst length 2 bytes wider.
	regList = CyU3PMemAlloc(sizeof(uint8_t) * (burstLength + 2));

	//Clear (zero) contents of regList memory. Burst transfers are DNC, so we're sending zeros.
	CyU3PMemSet(regList, 0, sizeof(uint8_t) * (burstLength + 2));

	//Append burst trigger word to the first two bytes of regList
	regList[0] = USBBuffer[5];
	regList[1] = USBBuffer[4];

	//Clear the DMA buffers
	CyU3PDmaChannelReset(&StreamingChannel);

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	//Set the SPI config for streaming mode
	spiConfig.ssnCtrl = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
	spiConfig.wordLen = 8;
	CyU3PSpiSetConfig(&spiConfig, NULL);

	//Set infinite DMA transfer on streaming channel
	CyU3PDmaChannelSetXfer(&StreamingChannel, 0);

	//Set the burst stream flag to notify the streaming thread
	CyU3PEventSet (&eventHandler, ADI_BURST_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;

}

/*
 * Function: AdiBurstStreamStop()
 *
 * This function sets a flag to notify the streaming thread that the user requested to cancel the streaming operation.
 * Note that this function uses the same boolean as the other streaming types.
 *
 * Returns: void
 *
 */
void AdiBurstStreamStop()
{
	killEarly = CyTrue;
}

/*
 * Function: AdiBurstStreamFinished()
 *
 * This function cleans up after a burst stream by resetting the SPI port and notifying the host
 * that the cancel operation was successful.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiBurstStreamFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//Disable SPI DMA mode
	CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);

	//Reset the SPI controller
	SPI->lpp_spi_config &= ~(CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_ENABLE);
	while ((SPI->lpp_spi_config & CY_U3P_LPP_SPI_ENABLE) != 0);

	//Remove the interrupt from the global data ready pin
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	CyU3PGpioSetSimpleConfig(dataReadyPin, &gpioConfig);

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	//Clear all interrupt flags
	CyU3PVicClearInt();

	//Additional clean-up after a user requests an early cancellation
	if(killEarly)
	{
		//Send status back over control endpoint to end USB transaction and signal cancel was completed successfully
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		//Reset killEarly flag in case the user wants to capture data again
		killEarly = CyFalse;
	}

	return status;
}


/*
 * Function: AdiGenericDataStreamFinished()
 *
 * This function cleans up after a generic stream and notifies the host that the cancel operation was successful if requested.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiGenericDataStreamFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//Remove the interrupt from the global data ready pin
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	CyU3PGpioSetSimpleConfig(dataReadyPin, &gpioConfig);

	//Clear all interrupt flags
	CyU3PVicClearInt();

	//Re-enable ISRs that were previously disabled
    CyU3PVicEnableInt(CY_U3P_VIC_SWI_VECTOR);                      /**< 1: Software interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_DEBUG_RX_VECTOR);                 /**< 2: Unused debug vector. */
    //CyU3PVicEnableInt(CY_U3P_VIC_DEBUG_TX_VECTOR);                 /**< 3: Unused debug vector. */
    //CyU3PVicEnableInt(CY_U3P_VIC_WDT_VECTOR);                      /**< 4: Watchdog timer interrupt. */
    CyU3PVicEnableInt(CY_U3P_VIC_BIAS_CORRECT_VECTOR);             /**< 5: Timer for PVT Bias correction. */
    CyU3PVicEnableInt(CY_U3P_VIC_PIB_DMA_VECTOR);                  /**< 6: GPIF (PIB) DMA interrupt. */
    CyU3PVicEnableInt(CY_U3P_VIC_PIB_CORE_VECTOR);                 /**< 7: GPIF (PIB) Core interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_UIB_DMA_VECTOR);                  /**< 8: USB DMA interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_UIB_CORE_VECTOR);                 /**< 9: USB core interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_UIB_CONTROL_VECTOR);              /**< 10: Unused interrupt vector. */
    //CyU3PVicEnableInt(CY_U3P_VIC_SIB_DMA_VECTOR);                  /**< 11: Storage port DMA interrupt (FX3S only). */
    //CyU3PVicEnableInt(CY_U3P_VIC_SIB0_CORE_VECTOR);                /**< 12: Storage port 0 core interrupt (FX3S only). */
    //CyU3PVicEnableInt(CY_U3P_VIC_SIB1_CORE_VECTOR);               /**< 13: Storage port 1 core interrupt (FX3S only). */
    //CyU3PVicEnableInt(CY_U3P_VIC_RESERVED_15_VECTOR);              /**< 14: Unused interrupt vector. */
    CyU3PVicEnableInt(CY_U3P_VIC_I2C_CORE_VECTOR);                 /**< 15: I2C block interrupt. */
    CyU3PVicEnableInt(CY_U3P_VIC_I2S_CORE_VECTOR);                 /**< 16: I2S block interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_SPI_CORE_VECTOR);                 /**< 17: SPI block interrupt. */
    CyU3PVicEnableInt(CY_U3P_VIC_UART_CORE_VECTOR);                /**< 18: UART block interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);                /**< 19: GPIO block interrupt. */
    //CyU3PVicEnableInt(CY_U3P_VIC_LPP_DMA_VECTOR);                  /**< 20: Serial peripheral (I2C, I2S, SPI and UART) DMA interrupt. */
    CyU3PVicEnableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);                 /**< 21: VBus detect interrupt. */

    //Additional clean-up if a user requests an early cancellation
	if(killEarly)
	{
		//Send status back over control endpoint to end USB transaction and signal cancel was completed successfully
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		//Reset killEarly flag in case the user wants to capture data again
		killEarly = CyFalse;
	}

	return status;
}

/*
 * Function: AdiGenericDataStreamStop()
 *
 * This function sets a flag to notify the generic streaming thread that the user requested to cancel the streaming operation. Note that this
 * function uses the same boolean as the real-time version.
 *
 * Returns: void
 *
 */
void AdiGenericDataStreamStop()
{
	killEarly = CyTrue;
}

/*
 * Function: AdiGenericDataStreamStart()
 *
 * This function kicks off a generic data stream by configuring interrupts, SPI, and end points.
 * At the end of the function, the ADI_GENERIC_STREAM_ENABLE flag is set such that the
 * generic streaming thread knows to start producing data.
 *
 * Returns: The status of starting a generic stream.
 */
CyU3PReturnStatus_t AdiGenericDataStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;

	//Disable GPIO interrupt before attaching interrupt to pin
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	//Make sure the data ready pin is configured as an input and attach the correct pin interrupt
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	if (DrPolarity)
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_NEG_EDGE;
	}
	else
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	}

	CyU3PGpioSetSimpleConfig(dataReadyPin, &gpioConfig);

	//Get the data from the control endpoint transaction
	CyU3PUsbGetEP0Data(transferLength, USBBuffer, &bytesRead);

	//Get the number of buffers (number of times to read each set of registers)
	numBuffers = USBBuffer[0];
	numBuffers += (USBBuffer[1] << 8);
	numBuffers += (USBBuffer[2] << 16);
	numBuffers += (USBBuffer[3] << 24);

	//Get the number of captures of the address list (number of times to capture the list of registers)
	numCaptures = USBBuffer[4];
	numCaptures += (USBBuffer[5] << 8);
	numCaptures += (USBBuffer[6] << 16);
	numCaptures += (USBBuffer[7] << 24);

	//Set regList memory to correct length (extra location is used to sanitize final SPI transaction)
	regList = CyU3PMemAlloc(sizeof(uint8_t) * (transferLength - 7));

	//Clear contents of regList memory
	CyU3PMemSet(regList, 0, sizeof(uint8_t) * (transferLength - 7));

	//Write values to regList
	for(uint16_t i = 8; i < transferLength; i++)
	{
		regList[i - 8] = USBBuffer[i];
	}

	//Calculate the number of bytes per buffer
	// (2 bytes per word [register] * number of times to read each set of registers * number of registers)
	bytesPerBuffer = 2 * numCaptures * (transferLength - 8);

	//Disable interrupts before activating the streaming thread. Commented interrupts are *not* disabled.
	CyU3PVicDisableInt(CY_U3P_VIC_SWI_VECTOR);                      /**< 1: Software interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_DEBUG_RX_VECTOR);                 /**< 2: Unused debug vector. */
	//CyU3PVicDisableInt(CY_U3P_VIC_DEBUG_TX_VECTOR);                 /**< 3: Unused debug vector. */
	//CyU3PVicDisableInt(CY_U3P_VIC_WDT_VECTOR);                      /**< 4: Watchdog timer interrupt. */
	CyU3PVicDisableInt(CY_U3P_VIC_BIAS_CORRECT_VECTOR);             /**< 5: Timer for PVT Bias correction. */
	CyU3PVicDisableInt(CY_U3P_VIC_PIB_DMA_VECTOR);                  /**< 6: GPIF (PIB) DMA interrupt. */
	CyU3PVicDisableInt(CY_U3P_VIC_PIB_CORE_VECTOR);                 /**< 7: GPIF (PIB) Core interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_UIB_DMA_VECTOR);                  /**< 8: USB DMA interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_UIB_CORE_VECTOR);                 /**< 9: USB core interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_UIB_CONTROL_VECTOR);              /**< 10: Unused interrupt vector. */
	//CyU3PVicDisableInt(CY_U3P_VIC_SIB_DMA_VECTOR);                  /**< 11: Storage port DMA interrupt (FX3S only). */
	//CyU3PVicDisableInt(CY_U3P_VIC_SIB0_CORE_VECTOR);                /**< 12: Storage port 0 core interrupt (FX3S only). */
	//CyU3PVicDisableInt(CY_U3P_VIC_SIB1_CORE_VECTOR);               /**< 13: Storage port 1 core interrupt (FX3S only). */
	//CyU3PVicDisableInt(CY_U3P_VIC_RESERVED_15_VECTOR);              /**< 14: Unused interrupt vector. */
	CyU3PVicDisableInt(CY_U3P_VIC_I2C_CORE_VECTOR);                 /**< 15: I2C block interrupt. */
	CyU3PVicDisableInt(CY_U3P_VIC_I2S_CORE_VECTOR);                 /**< 16: I2S block interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_SPI_CORE_VECTOR);                 /**< 17: SPI block interrupt. */
	CyU3PVicDisableInt(CY_U3P_VIC_UART_CORE_VECTOR);                /**< 18: UART block interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);                /**< 19: GPIO block interrupt. */
	//CyU3PVicDisableInt(CY_U3P_VIC_LPP_DMA_VECTOR);                  /**< 20: Serial peripheral (I2C, I2S, SPI and UART) DMA interrupt. */
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);                 /**< 21: VBus detect interrupt. */
    //CyU3PVicDisableInt(CY_U3P_VIC_NUM_VECTORS);                     /**< Number of valid FX3 interrupt vectors. */

	//Enable generic data capture thread
	status = CyU3PEventSet (&eventHandler, ADI_GENERIC_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;

}


/*
 * Function: AdiMeasureDR()
 *
 * This function measures two data ready pulses on a user-specified pin and reports
 * back the delta-time in ticks. The function also transmits the tick scale factor
 * and a timeout counter to notify the interface of timeouts that may have occurred
 * due to missing pulses. Data is transmitted over USB via the bulk endpoint. Inputs
 * are provided through the control endpoint. This function can be expanded to capture
 * as many samples as required.
 *
 * pin: The GPIO pin number to measure
 *
 * polarity: The polarity of the pin (1 - Low-to-High, 0 - High-to-Low)
 *
 * timeoutInMs: The specified timeout in milliseconds
 *
 * Returns: The status of the pin drive operation
 */
CyU3PReturnStatus_t AdiMeasureDR()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pin;
	CyBool_t polarity, validPin, pinValue, sampleRollover;
	uint32_t timeWaited[2];
	uint32_t timeoutCounter = 0;
	uint32_t pinRegValue, startTime, currentTime, sampleEndTime, timeout, deltat;

	//Get the operation start time
	CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &startTime);
	currentTime = startTime;

	//Parse request data from USBBuffer
	pin = USBBuffer[0];
	pin = pin + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	timeout = USBBuffer[7];
	timeout = timeout + (USBBuffer[8] << 8);
	timeout = timeout + (USBBuffer[9] << 16);
	timeout = timeout + (USBBuffer[10] << 24);

	//Convert from ms to timer ticks
	timeout = AdiMStoTicks(timeout);

	//Calculate if timer rollover is going to occur for sample period
	sampleRollover = (timeout > 0 && (startTime > (0xFFFFFFFF - timeout)));

	//Calculate the sample period end time
	if(sampleRollover)
	{
		sampleEndTime = timeout - (0xFFFFFFFF - startTime);
	}
	else
	{
		sampleEndTime = timeout + startTime;
	}

	//Check that input pin specified is configured as input
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	if(status != CY_U3P_SUCCESS)
	{
		//If initial pin read fails try and configure as input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

		//get the pin value again after configuring
		status = CyU3PGpioSimpleGetValue(pin, &pinValue);

		//If pin setup not successful skip wait operation and return -1
		if(status != CY_U3P_SUCCESS)
		{
			validPin = CyFalse;
		}
	}
	else
	{
	validPin = CyTrue;
	}

	//If the pin is properly configured
	if(validPin)
	{
		//Loop through samples
		for(uint32_t i = 0; i <= 2; i++)
		{
			//Poll the input pin until a transition is detected or the timer runs out
			if(timeout)
			{
				//If the timeout will roll over
				if(sampleRollover)
				{
					//Low to high transition
					if(polarity == 1)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts high wait for low transition
						if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && (currentTime >= startTime || currentTime <= sampleEndTime))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime <= startTime || currentTime >= sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a low to high transition
						while((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime <= startTime || currentTime >= sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
					//Default / high to low transition
					else
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts low wait for high transition
						if((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime <= startTime || currentTime >= sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a high to low transition
						while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime <= startTime || currentTime >= sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
				}
				else
				{
					//Low to high transition
					if(polarity == 1)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts high wait for low transition
						if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && currentTime < sampleEndTime)
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime > sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a low to high transition
						while((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && currentTime < sampleEndTime)
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime > sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
					//Default / high to low transition
					else
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts low wait for high transition
						if((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && currentTime < sampleEndTime)
						{
							while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime > sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a high to low transition
						while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && currentTime < sampleEndTime)
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime > sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
				}
			}
			//If timeout is 0 treat it like there is no timeout
			else
			{
				//Low to high transition
				if(polarity == 1)
				{
					pinRegValue = GPIO->lpp_gpio_simple[pin];
					//If pin starts high wait for low transition
					if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
					{
						while(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							pinRegValue = GPIO->lpp_gpio_simple[pin];
						}
					}
					//Wait for a low to high transition
					while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
					}
				}
				//Default / high to low transition
				else
				{
					pinRegValue = GPIO->lpp_gpio_simple[pin];
					//If pin starts low wait for high transition
					if(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
					{
						while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
						{
							pinRegValue = GPIO->lpp_gpio_simple[pin];
						}
					}
					//Wait for a high to low transition
					while(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
					}
				}
			}
			//Calculate the time waited
			CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
			if (currentTime > startTime)
			{
				timeWaited[i] = currentTime - startTime;
			}
			else
			{
				timeWaited[i] = currentTime + (0xFFFFFFFF - startTime);
			}
		}
		//Calculate delta time
		deltat = timeWaited[1] - timeWaited[0];
	}
	else
	{
		//Set the wait time to max when invalid pin is specified
		deltat = 0xFFFFFFFF;
	}
	//Return delta time over ChannelToPC
	BulkBuffer[0] = deltat & 0xFF;
	BulkBuffer[1] = (deltat & 0xFF00) >> 8;
	BulkBuffer[2] = (deltat & 0xFF0000) >> 16;
	BulkBuffer[3] = (deltat & 0xFF000000) >> 24;
	BulkBuffer[4] = MS_TO_TICKS_MULT & 0xFF;
	BulkBuffer[5] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	BulkBuffer[6] = (MS_TO_TICKS_MULT & 0xFF00) >> 16;
	BulkBuffer[7] = (MS_TO_TICKS_MULT & 0xFF00) >> 24;
	BulkBuffer[8] = timeoutCounter;

	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = 9;

	//Send the data to PC
	status = CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}

/*
 * Function: AdiSpiInit()
 *
 * This function initializes the SPI controller
 *
 * Returns: The success of the SPI initialization operation
 */
CyU3PReturnStatus_t AdiSpiInit()
{
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    /* Start the SPI module and configure the master. */
    status = CyU3PSpiInit();
    if (status == CY_U3P_ERROR_ALREADY_STARTED)
    {
    	CyU3PSpiDeInit();
    	CyU3PSpiInit();
    }

    status = CyU3PSpiSetConfig (&spiConfig, NULL);

    return status;
}

/*
 * Function: AdiSetDefaultSpiConfig()
 *
 * This function resets the global SPI config to its default parameters
 *
 * Returns: void
 */
void AdiSetDefaultSpiConfig()
{
    //Set the stall time in ticks (each tick = 1us)
    stallTime = 25;

    //Set the DUT type
    DUTType = ADcmXL3021;

    //Set the data ready pin
    dataReadyPin = ADI_PIN_DIO2;

    //Set the DrActive
    DrActive = CyTrue;

    //Set the DrPolarity
    DrPolarity = CyTrue;

    // Configure the global SPI parameters
    CyU3PMemSet ((uint8_t *)&spiConfig, 0, sizeof(spiConfig));
    spiConfig.isLsbFirst = CyFalse;
    spiConfig.cpol       = CyTrue;
    spiConfig.ssnPol     = CyFalse;
    spiConfig.cpha       = CyTrue;
    spiConfig.leadTime   = CY_U3P_SPI_SSN_LAG_LEAD_ONE_CLK;
    spiConfig.lagTime    = CY_U3P_SPI_SSN_LAG_LEAD_ONE_CLK;
    spiConfig.ssnCtrl    = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
    spiConfig.clock      = 2000000;
    spiConfig.wordLen    = 8;
}

/*
 * Function: AdiGetSpiSettings()
 *
 * This function handles vendor commands to get the current SPI configuration from the FX3
 *
 * Returns: if the transaction was successful
 */
CyU3PReturnStatus_t AdiGetSpiSettings()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t USBBuffer[23];
	//Clock first
	USBBuffer[0] = spiConfig.clock & 0xFF;
	USBBuffer[1] = (spiConfig.clock & 0xFF00) >> 8;
	USBBuffer[2] = (spiConfig.clock & 0xFF0000) >> 16;
	USBBuffer[3] = (spiConfig.clock & 0xFF000000) >> 24;
	USBBuffer[4] = spiConfig.cpha;
	USBBuffer[5] = spiConfig.cpol;
	USBBuffer[6] = spiConfig.isLsbFirst;
	USBBuffer[7] = spiConfig.lagTime;
	USBBuffer[8] = spiConfig.leadTime;
	USBBuffer[9] = spiConfig.ssnCtrl;
	USBBuffer[10] = spiConfig.ssnPol;
	USBBuffer[11] = spiConfig.wordLen;
	USBBuffer[12] = stallTime & 0xFF;
	USBBuffer[13] = (stallTime & 0xFF00) >> 8;
	USBBuffer[14] = DUTType;
	USBBuffer[15] = DrActive;
	USBBuffer[16] = DrPolarity;
	USBBuffer[17] = dataReadyPin & 0xFF;
	USBBuffer[18] = (dataReadyPin & 0xFF00) >> 8;
	USBBuffer[19] = MS_TO_TICKS_MULT & 0xFF;
	USBBuffer[20] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	USBBuffer[21] = (MS_TO_TICKS_MULT & 0xFF0000) >> 16;
	USBBuffer[22] = (MS_TO_TICKS_MULT & 0xFF000000) >> 24;
	status = CyU3PUsbSendEP0Data (23, USBBuffer);
	return status;
}

/*
 * Function: AdiSpiUpdate(uint16_t index, uint16_t value, uint16_t length)
 *
 * This function handles a vendor command request to update the SPI configuration
 *
 * index: The wIndex from the control endpoint transaction which indicates which parameter to update
 *
 * value: The wValue from the control endpoint transaction which holds the SPI value to set
 *
 * length: The length of the Data In phase of the control endpoint transaction
 *
 * Returns: A boolean indicating if the SPI configuration was a success
 */
CyBool_t AdiSpiUpdate(uint16_t index, uint16_t value, uint16_t length)
{
    uint32_t clockFrequency;
    uint16_t *bytesRead = 0;
	CyBool_t isHandled = CyTrue;
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyU3PUsbGetEP0Data(length, USBBuffer, bytesRead);
	switch(index)
	{
	case 0:
		//Clock setting
		if(length != 4)
		{
			//Reasonable Default if data frame isn't set properly
			spiConfig.clock = 2000000;
		}
		else
		{
			clockFrequency = USBBuffer[3];
			clockFrequency += USBBuffer[2] << 8;
			clockFrequency += USBBuffer[1] << 16;
			clockFrequency += USBBuffer[0] << 24;
			spiConfig.clock = clockFrequency;
			status = CyU3PSpiSetConfig (&spiConfig, NULL);
		}
		break;

	case 1:
		//cpol
		spiConfig.cpol = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 2:
		//cpha
		spiConfig.cpha = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 3:
		//Chip Select Polarity
		spiConfig.ssnPol = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 4:
		//Chip Select Control
		spiConfig.ssnCtrl = (CyU3PSpiSsnCtrl_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 5:
		//Lead Time
		spiConfig.leadTime = (CyU3PSpiSsnLagLead_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 6:
		//Lag Time
		spiConfig.lagTime = (CyU3PSpiSsnLagLead_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 7:
		//Is LSB First
		spiConfig.isLsbFirst = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 8:
		//Word Length
		spiConfig.wordLen = value & 0xFF;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		break;

	case 9:
		//Stall time in ticks (received in ticks from the PC, each tick = 1us)
		stallTime = value;
		break;

	case 10:
		//DUT type
		DUTType = value;
		switch(DUTType)
		{
		case ADcmXL3021:
			bytesPerFrame = 200;
			break;
		case ADcmXL2021:
			bytesPerFrame = 136;
			break;
		case ADcmXL1021:
			bytesPerFrame = 72;
			break;
		case Other:
		default:
			bytesPerFrame = 200;
			break;
		}
		break;

	case 11:
		//DR polarity
		DrPolarity = (CyBool_t) value;
		break;

	case 12:
		//DR active
		DrActive = (CyBool_t) value;
		break;

	case 13:
		//Ready pin
		dataReadyPin = value;
		break;

	default:
		//Invalid Command
		isHandled = CyFalse;
		break;
	}

	//Check that the configuration was successful
	if(status != CY_U3P_SUCCESS)
	{
		isHandled = CyFalse;
	}

	return isHandled;
}

/*
 * Function: AdiDebugInit()
 *
 * This function initializes the UART controller to send debug messages
 *
 * Returns: Void
 */
void AdiDebugInit()
{
    CyU3PUartConfig_t uartConfig;

    /* Initialize the UART for printing debug messages */
    CyU3PUartInit();

    /* Set UART configuration */
    CyU3PMemSet ((uint8_t *)&uartConfig, 0, sizeof (uartConfig));
    uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
    uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
    uartConfig.parity = CY_U3P_UART_NO_PARITY;
    uartConfig.txEnable = CyTrue;
    uartConfig.rxEnable = CyFalse;
    uartConfig.flowCtrl = CyFalse;
    uartConfig.isDma = CyTrue;

    CyU3PUartSetConfig (&uartConfig, NULL);

    /* Set the UART transfer to a really large value. */
    CyU3PUartTxSetBlockXfer (0xFFFFFFFF);

    /* Initialize the debug module. */
    CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);

    /* Turn off the preamble to the debug messages. */
    CyU3PDebugPreamble(CyFalse);

    /* Send a success command over the debug port. */
    CyU3PDebugPrint (4, "\r\n");
    CyU3PDebugPrint (4, "Debugger successfully initialized!\r\n");
    CyU3PDebugPrint (4, "\r\n");

}

/*
 * Function: ADICreateEventFlagGroup()
 *
 * This function creates generic event groups to keep track of the state of the RT and DR threads
 *
 *	eventHandler:
 *	BIT	  DESCRIPTION
 *	 0    Real-time start/stop. 1 = start / 0 = stop
 *	 1	  Streaming? 1 = yes / 0 = no
 *	 2    Pin Exit? 1 = enabled / 0 = disabled
*	 3    Data stream start/stop. 1 = start / 0 = stop
 *	 .
 *	 .
 *
 *	 gpioHandler:
 *	 BIT  DESCRIPTION
 *	 0	  Signal that a gpio event has occurred
 *
 * Returns: The success of the event creation operation
 */
CyU3PReturnStatus_t AdiCreateEventFlagGroup()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	//Create stream event handler
	status = CyU3PEventCreate(&eventHandler);
	if(status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Create gpio event handler
	status = CyU3PEventCreate(&gpioHandler);
	if(status != CY_U3P_SUCCESS)
		{
			return status;
		}

	return status;
}

/*
 * Function: AdiConfigureBulkEndpoint()
 *
 * This function configures Bulk-In endpoint 1 (FX3 to PC). It also sets up a DMA channel
 * to connect the SPI producer with the USB consumer, allowing automatic DMA transfer in
 * real time streaming mode.
 *
 * Returns: The success of the endpoint configuration operation
 */
CyU3PReturnStatus_t AdiConfigureEndpoints()
{
	CyU3PEpConfig_t bulkCfg;
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t size;

	//Clear the config
	CyU3PMemSet ((uint8_t *)&bulkCfg, 0, sizeof (bulkCfg));

	//Get the current USB speed
    CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
    switch (usbSpeed)
    {
        case CY_U3P_FULL_SPEED:
            size = 64;
            break;

        case CY_U3P_HIGH_SPEED:
            size = 512;
            break;

        case  CY_U3P_SUPER_SPEED:
            size = 1024;
            break;

        default:
        	size = 0;
            break;
    }

	//Set bulk endpoint parameters
	bulkCfg.enable = CyTrue;
	bulkCfg.epType = CY_U3P_USB_EP_BULK;
	bulkCfg.burstLen = 1;
	bulkCfg.pcktSize = size;
	bulkCfg.streams = 0;

	//Set endpoint config for real time streaming endpoint
	status = CyU3PSetEpConfig(ADI_STREAMING_ENDPOINT, &bulkCfg);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting RTS endpoint failed, Error Code = %d\n", status);
		return status;
	}

	//Set endpoint config for the PC to FX3 direction
	status = CyU3PSetEpConfig(ADI_FROM_PC_ENDPOINT, &bulkCfg);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting PC to FX3 endpoint failed, Error Code = %d\n", status);
		return status;
	}

	//Set endpoint config for the FX3 to PC direction
	status = CyU3PSetEpConfig(ADI_TO_PC_ENDPOINT, &bulkCfg);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting FX3 to PC endpoint failed, Error Code = %d\n", status);
		return status;
	}

	//Flush endpoint memory
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);
	CyU3PUsbFlushEp(ADI_FROM_PC_ENDPOINT);
	CyU3PUsbFlushEp(ADI_TO_PC_ENDPOINT);

	//Configure DMA for real time streaming channel
    CyU3PDmaChannelConfig_t dmaConfig;
    dmaConfig.size = 1024;
    dmaConfig.count = 64;
    dmaConfig.prodSckId = CY_U3P_LPP_SOCKET_SPI_PROD;
    dmaConfig.consSckId = CY_U3P_UIB_SOCKET_CONS_1;
    dmaConfig.dmaMode = CY_U3P_DMA_MODE_BYTE;

    //Disable DMA callbacks
    dmaConfig.prodHeader     = 0;
    dmaConfig.prodFooter     = 0;
    dmaConfig.consHeader     = 0;
    dmaConfig.notification   = 0;
    dmaConfig.cb             = NULL;
    dmaConfig.prodAvailCount = 0;

    status = CyU3PDmaChannelCreate(&StreamingChannel, CY_U3P_DMA_TYPE_AUTO, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the RTS DMA failed, Error Code = %d\n", status);
		return status;
	}

    //Configure DMA for ChannelFromPC
    dmaConfig.count = 0;
    dmaConfig.prodSckId = CY_U3P_UIB_SOCKET_PROD_1;
    dmaConfig.consSckId = CY_U3P_CPU_SOCKET_CONS;

    status = CyU3PDmaChannelCreate(&ChannelFromPC, CY_U3P_DMA_TYPE_MANUAL_IN, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the ChannelFromPC DMA failed, Error Code = %d\n", status);
		return status;
	}

    //Configure DMA for ChannelToPC
    dmaConfig.count = 0;
    dmaConfig.prodSckId = CY_U3P_CPU_SOCKET_PROD;
    dmaConfig.consSckId = CY_U3P_UIB_SOCKET_CONS_2;

    status = CyU3PDmaChannelCreate(&ChannelToPC, CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the ChannelToPC DMA failed, Error Code = %d\n", status);
		return status;
	}

	return status;
}

/*
 * Function: AdiBulkEndpointHandler(CyU3PUsbEpEvtType evType,CyU3PUSBSpeed_t usbSpeed, uint8_t epNum)
 *
 * This function handles events generated by the bulk endpoint
 *
 * evType: The type of the event being handled
 *
 * usbSpeed: The current connection speed
 *
 * epNum: The end point number
 *
 * Returns: void
 */
void AdiBulkEndpointHandler(CyU3PUsbEpEvtType evType, CyU3PUSBSpeed_t usbSpeed, uint8_t epNum)
{
}

/*
 * Function: AdiUSBEventHandler (CyU3PUsbEventType_t evtype, uint16_t evdata)
 *
 * This is a callback function to handle generic USB events
 *
 * evtype: The type of the event being handled
 *
 * evdata: The data from the event
 *
 * Returns: void
 */
void AdiUSBEventHandler (CyU3PUsbEventType_t evtype, uint16_t evdata)
{
    switch (evtype)
    {
        case CY_U3P_USB_EVENT_CONNECT:
        	CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_CONNECT detected\r\n");
			break;

        case CY_U3P_USB_EVENT_SETCONF:
        	CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_SETCONF detected\r\n");
			/* Enable the application */
        	appActive = CyTrue;
        	/* Disable the low power entry to optimize USB throughput */
        	CyU3PUsbLPMDisable();
            break;

        case CY_U3P_USB_EVENT_RESET:
        	CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_RESET detected\r\n");
        	break;

        case CY_U3P_USB_EVENT_DISCONNECT:
        	appActive = CyFalse;
			CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_DISCONNECT detected\r\n");
            break;

        default:
            break;
    }
}

/*
 * Function: AdiLPMRequestHandler(CyU3PUsbLinkPowerMode link_mode)
 *
 * This is a callback function to handle LPM requests. Returns true so that
 * the USB driver stays in high power state.
 *
 * link_mode: The USB link power state that is being set
 *
 * Returns: True
 */
CyBool_t AdiLPMRequestHandler(CyU3PUsbLinkPowerMode link_mode)
{
    return CyTrue;
}

/*
 * Function: AdiGPIOInit()
 *
 * This function initializes the GPIO pins used on the FX3 board, and configures the GPIO clock source.
 *
 * Returns: The status of the GPIO initialization operation
 */
CyU3PReturnStatus_t AdiGPIOInit()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//Configure the clock source and set up ISR
	//System clock should be 403.2MHz
	CyU3PGpioClock_t gpioClock;
	gpioClock.fastClkDiv = 13;
	gpioClock.slowClkDiv = 31;
	//Effective clock speed for timer is 403.2MHz / (13 * 31) = 1.000MHz
	gpioClock.simpleDiv = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
	//Simple clock (for GPIO pins) is 201.6MHz
	gpioClock.clkSrc = CY_U3P_SYS_CLK;
	gpioClock.halfDiv = 0;
	//Set GPIO configuration and attach the GPIO event handler
	status = CyU3PGpioInit(&gpioClock, AdiGPIOEventHandler);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Override all pins used by ADI to act as GPIO
	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO1, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO2, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO3, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO4, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO5, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO6, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO7, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride (ADI_PIN_RESET, CyTrue);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PDeviceGpioOverride(ADI_TIMER_PIN, CyFalse);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Set the GPIO config for each pin DIO pin
	CyU3PGpioSimpleConfig_t gpioConfig;

	gpioConfig.outValue = CyFalse;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO1, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO2, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO3, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO4, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO5, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO6, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO7, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_RESET, &gpioConfig);
	if (status != CY_U3P_SUCCESS)
	{
		return status;
	}

	//Configure timer using complex GPIO
	CyU3PGpioComplexConfig_t gpioComplexConfig;
	gpioComplexConfig.outValue = CyFalse;
	gpioComplexConfig.inputEn = CyFalse;
	gpioComplexConfig.driveLowEn = CyTrue;
	gpioComplexConfig.driveHighEn = CyTrue;
	gpioComplexConfig.pinMode = CY_U3P_GPIO_MODE_STATIC;
	gpioComplexConfig.intrMode = CY_U3P_GPIO_NO_INTR;
	gpioComplexConfig.timerMode = CY_U3P_GPIO_TIMER_LOW_FREQ;
	gpioComplexConfig.timer = 0;
	gpioComplexConfig.period = 0xffffffff;
	gpioComplexConfig.threshold = 0xffffffff;
	status = CyU3PGpioSetComplexConfig(ADI_TIMER_PIN, &gpioComplexConfig);

	return status;
}

/*
 * Function: AdiGPIOEventHandler(uint8_t gpioId)
 *
 * This function handles GPIO interrupts and sets the appropriate flag in gpioHandler.
 *
 * gpioId: The pin number of the pin which generated the interrupt
 *
 * Returns: void
 */
void AdiGPIOEventHandler(uint8_t gpioId)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyBool_t gpioValue = CyFalse;
	status = CyU3PGpioGetValue (gpioId, &gpioValue);
    if (status == CY_U3P_SUCCESS)
    {
    	//Read the pin ID that generated the event and set the appropriate flag
    	switch(gpioId)
    	{
    		case ADI_PIN_DIO1:
    			CyU3PEventSet(&gpioHandler, ADI_PIN_DIO1, CYU3P_EVENT_OR);
    			break;

    		case ADI_PIN_DIO2:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO2, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO3:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO3, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO4:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO4, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO5:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO5, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO6:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO6, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO7:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO7, CYU3P_EVENT_OR);
				break;
    		default:
    			break;
    	}
    }
}

/*
 * Function: AdiDeviceInit()
 *
 * This function initializes all hardware peripherals used for the ADI application
 * and configures the USB interface.
 *
 * Returns: The status of the configuration operation.
 */
CyU3PReturnStatus_t AdiDeviceInit()
{
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    //Initialize USB
    status = CyU3PUsbStart();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "CyU3PUsbStart failed to Start, Error code = %d\n", status);
        return status;
    }
    else
    {
    	CyU3PDebugPrint (4, "USB OK\r\n");
    }

    /* The fast enumeration is the easiest way to setup a USB connection,
     * where all enumeration phase is handled by the library. Only the
     * class / vendor requests need to be handled by the application. */
    CyU3PUsbRegisterSetupCallback(AdiControlEndpointHandler, CyTrue);

    //Setup the callback to handle the USB events
    CyU3PUsbRegisterEventCallback(AdiUSBEventHandler);

    // Register a callback to handle LPM requests from the USB 3.0 host
    CyU3PUsbRegisterLPMRequestCallback(AdiLPMRequestHandler);

    //Setup the callback to handle bulk endpoint events
    CyU3PUsbRegisterEpEvtCallback(AdiBulkEndpointHandler, 1, 1, 0);


    /* Set the USB Enumeration descriptors */

    /* Super speed device descriptor. */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB30DeviceDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* High speed device descriptor. */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB20DeviceDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* BOS descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)CyFxUSBBOSDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* Device qualifier descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)CyFxUSBDeviceQualDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device qualifier descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* Super speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBSSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* High speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBHSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Set Other Speed Descriptor failed, Error Code = %d\n", status);
        return status;
    }

    /* Full speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBFSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Set Configuration Descriptor failed, Error Code = %d\n", status);
        return status;
    }

    /* String descriptor 0 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* String descriptor 1 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* String descriptor 2 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", status);
        return status;
    }

    /* Connect the USB Pins with super speed operation enabled. */
    status = CyU3PConnectState (CyTrue, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Connect failed, Error code = %d\n", status);
        return status;
    }

    //Setup the bulk endpoint
    status = AdiConfigureEndpoints();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Configuring endpoints failed, Error code = %d\n", status);
        return status;
    }

    //Initialize the SPI interface
    AdiSetDefaultSpiConfig();
    status = AdiSpiInit();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "SPI initialization failed, Error code = %d\n", status);
        return status;
    }
    else
    {
    	CyU3PDebugPrint (4, "SPI OK\r\n");
    }

    //Explicitly disable watchdog timer by putting it in mode 3
    GCTLAON->watchdog_cs |= CY_U3P_GCTL_MODE0_MASK;

    //Set up global event flags
    status = AdiCreateEventFlagGroup();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Setting up global event flags failed, Error code = %d\n", status);
        return status;
    }

    CyU3PDebugPrint (8, "AdiDeviceInit complete!\r\n");

    return status;
}


/*
 * Function: AdiDataStream_Entry(uint32_t input)
 *
 * This function runs in its own thread and handles both real-time and generic streaming processes. Either type
 * of stream can be kicked off by executing the appropriate set-up routine and then triggering the corresponding
 * event flag.
 *
 * input: Unused input required by the thread manager
 *
 * Returns: void
 */
void AdiDataStream_Entry(uint32_t input)
{
	uint32_t eventMask = ADI_GENERIC_STREAM_ENABLE|ADI_REAL_TIME_STREAM_ENABLE|ADI_BURST_STREAM_ENABLE;
	uint8_t tempData[2];
	uint8_t *bufPntr;
	uint32_t numBuffersRead = 0;
	uint32_t gpioEventFlag, eventFlag;

	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t pinIndex;
	uint32_t numFramesCaptured, errorStartTime, currentTime, initialRegValue;
	CyBool_t interruptTriggered = CyFalse;
	CyBool_t errorHandled = CyFalse;

	//Delay timer definitions
	uint32_t counter = 0;
	uint32_t stopCount = 0;

	//Get the pin index
	pinIndex = ADI_TIMER_PIN % 8;

	for (;;)
	{
		if (CyU3PEventGet (&eventHandler, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag, CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
		{
			if (eventFlag & ADI_GENERIC_STREAM_ENABLE)
			{
				//Set the BulkBuffer pointer
				bufPntr = BulkBuffer;
				//Loop to read data
				for (uint32_t numCapturesRead = 0; numCapturesRead < numCaptures; numCapturesRead++)
				{
					//Wait for DR if enabled
					if (DrActive)
					{
						//Enable GPIO interrupts
						CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
						/* Wait for GPIO interrupt flag (Note: We're reacting to an interrupt on any ADI configured pin, but
						   we're only attaching an interrupt to one pin. */
						CyU3PEventGet(&gpioHandler, 0x7F, CYU3P_EVENT_OR_CLEAR, &gpioEventFlag, CYU3P_WAIT_FOREVER);
						//Disable GPIO interrupts until we need them again
						CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
					}

					//Transmit first word without reading back
					tempData[0] = (0x7F) & regList[0];
					tempData[1] = 0;
					CyU3PSpiTransmitWords(tempData, 2);

					//Read the registers in the register list into BulkBuffer
					for(uint16_t regIndex = 0; regIndex < (transferLength - 8); regIndex++)
					{
						/* Ugly delay counter based on the core system clock.
						 * This was the most efficient way to add a quick delay between words.
						 * Note that 12us is the smallest delay supported when streaming using this mode. */
						if (stallTime > 12)
						{
							stopCount = stallTime * 10;
							while(counter < stopCount)
							{
								counter++;
							}
							counter = 0;
						}

						//Prepare, transmit, and receive SPI words
						tempData[0] = (0x7F) & regList[regIndex + 1];
						tempData[1] = 0;
						CyU3PSpiTransferWords(tempData, 2, bufPntr, 2);
						bufPntr += 2;
					}

					//Transmit the buffered data to the PC
					ManualDMABuffer.buffer = BulkBuffer;
					ManualDMABuffer.size = sizeof(BulkBuffer);
					ManualDMABuffer.count = bytesPerBuffer;
					CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

					//Check to see if we've captured enough buffers of we were asked to stop data capture early
					if ((numBuffersRead >= (numBuffers - 1)) || killEarly)
					{
						//Reset buffer counter
						numBuffersRead = 0;
						//Reset buffer index
						bufPntr = 0;
						//Don't reset flag
						CyU3PEventSet(&eventHandler, ADI_DATA_STREAMING_DONE, CYU3P_EVENT_OR);
					}
					else
					{
						//Increment buffer counter
						numBuffersRead++;
						//Reset buffer index
						bufPntr = 0;
						//Reset flag
						CyU3PEventSet (&eventHandler, ADI_GENERIC_STREAM_ENABLE, CYU3P_EVENT_OR);
					}
				}
			}
			if (eventFlag & ADI_REAL_TIME_STREAM_ENABLE)
			{
				//Wait for GPIO interrupt flag to be set and pin to be positive (interrupt configured for positive edge)
				interruptTriggered = CyFalse;
				while(!interruptTriggered)
				{
					interruptTriggered = ((CyBool_t)(GPIO->lpp_gpio_intr0 & (1 << dataReadyPin)) && (CyBool_t)(GPIO->lpp_gpio_simple[dataReadyPin] & CY_U3P_LPP_GPIO_IN_VALUE));
				}

				//Clear the SPI Rx FIFO
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_RX_CLEAR;
				while((SPI->lpp_spi_status & CY_U3P_LPP_SPI_RX_DATA) != 0);
				SPI->lpp_spi_config &= ~CY_U3P_LPP_SPI_RX_CLEAR;

				//Set the config for DMA mode with RX enabled
				SPI->lpp_spi_config |= (CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_RX_ENABLE);

				//Set the Tx/Rx count
				SPI->lpp_spi_tx_byte_count = 0;
				SPI->lpp_spi_rx_byte_count = bytesPerFrame;

				//Enable the SPI block
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_ENABLE;

				//Wait for transfer to finish
				status = CyU3PSpiWaitForBlockXfer(CyTrue);

				if(status == CY_U3P_SUCCESS)
				{
					//Disable SPI DMA transfer
					status = CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);

					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[dataReadyPin] |= CY_U3P_LPP_GPIO_INTR;
				}
				//Error handling
				if(status != CY_U3P_SUCCESS)
				{
					//Have an error that needs to be handled
					errorHandled = CyFalse;

					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[dataReadyPin] |= CY_U3P_LPP_GPIO_INTR;

					//Get the initial pin config
					initialRegValue = (GPIO->lpp_gpio_pin[pinIndex].status & ~CY_U3P_LPP_GPIO_INTR);
					//Set the pin config for sample now mode
					GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
					//wait for sample to finish
					while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
					//read error start time
					errorStartTime = GPIO->lpp_gpio_pin[pinIndex].threshold;

					//Reset the DMA controller
					CyU3PDmaChannelReset(&StreamingChannel);

					while(!errorHandled)
					{
						//Set the pin config for sample now mode
						GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
						//wait for sample to finish
						while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
						//Read the current time
						currentTime = GPIO->lpp_gpio_pin[pinIndex].threshold;

						//Wait for another busy edge
						if((GPIO->lpp_gpio_intr0 & (1 << dataReadyPin)))
						{
							errorHandled = CyTrue;
						}

						//If the wait time is more than 10 milliseconds cancel streaming
						if((currentTime - errorStartTime) > (MS_TO_TICKS_MULT*10) && !errorHandled)
						{
							errorHandled = CyTrue;
							//Reset frame counter
							numFramesCaptured = 0;
							//Set ADI event flags
							CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_DONE, CYU3P_EVENT_OR);
						}
					}
				}
				//Check that we haven't captured the desired number of frames or were asked to kill the thread early
				if((numFramesCaptured >= (numRealTimeCaptures - 1)) || killEarly)
				{
					//Send whatever is in the buffer over to the PC
					CyU3PDmaChannelSetWrapUp(&StreamingChannel);
					//Reset frame counter
					numFramesCaptured = 0;
					//Set ADI event flags
					CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_DONE, CYU3P_EVENT_OR);
				}
				else
				{
					//increment the frame counter
					numFramesCaptured++;
					//Reset real-time data capture thread flag
					CyU3PEventSet (&eventHandler, ADI_REAL_TIME_STREAM_ENABLE, CYU3P_EVENT_OR);
				}
			}
			if (eventFlag & ADI_BURST_STREAM_ENABLE)
			{
				//Enable GPIO interrupts
				CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
				/* Wait for GPIO interrupt flag (Note: We're reacting to an interrupt on any ADI configured pin, but
				   we're only attaching an interrupt to one pin. */
				CyU3PEventGet(&gpioHandler, 0x7F, CYU3P_EVENT_OR_CLEAR, &gpioEventFlag, CYU3P_WAIT_FOREVER);
				//Disable GPIO interrupts until we need them again
				CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

				//Clear the SPI Rx FIFO
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_RX_CLEAR;
				while((SPI->lpp_spi_status & CY_U3P_LPP_SPI_RX_DATA) != 0);
				SPI->lpp_spi_config &= ~CY_U3P_LPP_SPI_RX_CLEAR;

				//Set the config for DMA mode with TX and RX enabled
				SPI->lpp_spi_config |= (CY_U3P_LPP_SPI_DMA_MODE|CY_U3P_LPP_SPI_RX_ENABLE|CY_U3P_LPP_SPI_TX_ENABLE);

				//Set the Tx/Rx count and Tx data
				SPI->lpp_spi_tx_byte_count = sizeof(regList);
				SPI->lpp_spi_rx_byte_count = numCaptures;
				SPI->lpp_spi_egress_data = *regList;

				//Enable the SPI block
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_ENABLE;

				//Wait for transfer to finish
				status = CyU3PSpiWaitForBlockXfer(CyTrue);

				if(status == CY_U3P_SUCCESS)
				{
					//Disable SPI DMA transfer
					status = CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);

					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[dataReadyPin] |= CY_U3P_LPP_GPIO_INTR;
				}
				//Error handling
				if(status != CY_U3P_SUCCESS)
				{
					//Have an error that needs to be handled
					errorHandled = CyFalse;

					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[dataReadyPin] |= CY_U3P_LPP_GPIO_INTR;

					//Get the initial pin config
					initialRegValue = (GPIO->lpp_gpio_pin[pinIndex].status & ~CY_U3P_LPP_GPIO_INTR);
					//Set the pin config for sample now mode
					GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
					//wait for sample to finish
					while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
					//read error start time
					errorStartTime = GPIO->lpp_gpio_pin[pinIndex].threshold;

					//Reset the DMA controller
					CyU3PDmaChannelReset(&StreamingChannel);

					while(!errorHandled)
					{
						//Set the pin config for sample now mode
						GPIO->lpp_gpio_pin[pinIndex].status = (initialRegValue | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
						//wait for sample to finish
						while (GPIO->lpp_gpio_pin[pinIndex].status & CY_U3P_LPP_GPIO_MODE_MASK);
						//Read the current time
						currentTime = GPIO->lpp_gpio_pin[pinIndex].threshold;

						//Wait for another busy edge
						if((GPIO->lpp_gpio_intr0 & (1 << dataReadyPin)))
						{
							errorHandled = CyTrue;
						}

						//If the wait time is more than 10 milliseconds cancel streaming
						if((currentTime - errorStartTime) > (MS_TO_TICKS_MULT*10) && !errorHandled)
						{
							errorHandled = CyTrue;
							//Reset frame counter
							numBuffersRead = 0;
							//Set ADI event flags
							CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_DONE, CYU3P_EVENT_OR);
						}
					}
				}
				//Check that we haven't captured the desired number of frames or were asked to kill the thread early
				if((numBuffersRead >= (numBuffers - 1)) || killEarly)
				{
					//Send whatever is in the buffer over to the PC
					CyU3PDmaChannelSetWrapUp(&StreamingChannel);
					//Reset frame counter
					numBuffersRead = 0;
					//Set ADI event flags
					CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_DONE, CYU3P_EVENT_OR);
				}
				else
				{
					//increment the frame counter
					numBuffersRead++;
					//Reset real-time data capture thread flag
					CyU3PEventSet (&eventHandler, ADI_BURST_STREAM_ENABLE, CYU3P_EVENT_OR);
				}
			}

		}
        /* Allow other ready threads to run. */
        CyU3PThreadRelinquish ();
	}
}


/*
 * Function AppThread_Entry(uint32_t input)
 *
 * This is the entry point for the main application thread. It performs the device initialization
 * and then handles streaming start/stop commands for the various streaming methods.
 *
 * input: Unused input argument required by the thread manager
 *
 * Returns: void
 */
void AppThread_Entry(uint32_t input)
{
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
    uint32_t eventMask =
    		ADI_RT_STREAMING_DONE|
    		ADI_RT_STREAMING_START|
    		ADI_RT_STREAMING_STOP|
    		ADI_DATA_STREAMING_DONE|
    		ADI_DATA_STREAMING_START|
    		ADI_DATA_STREAMING_STOP|
    		ADI_BURST_STREAMING_DONE|
    		ADI_BURST_STREAMING_START|
    		ADI_BURST_STREAMING_STOP;
    uint32_t eventFlag;

    /* Initialize UART debugging */
    AdiDebugInit();

    //Enable and configure GPIO
    status = AdiGPIOInit();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "GPIO initialization failed, error code = %d\n", status);
    	AdiFatalErrorHandler(ERROR_PIN_INIT);
    }
    else
    {
    	CyU3PDebugPrint (4, "GPIO OK\r\n");
    }

    //Initialize the ADI-specific configuration
    status = AdiDeviceInit();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "ADI-specific initialization failed, error code = %d\n", status);
    	AdiFatalErrorHandler(ERROR_GENERAL_INIT);
    }
    else
    {
    	CyU3PDebugPrint (4, "ADI HW Config OK\r\n");
    }

    for (;;)
    {
    	//Wait for event handler flags to occur and handle them
    	if (CyU3PEventGet(&eventHandler, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag, CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
    	{
			//Handle real-time stream commands
			if (eventFlag & ADI_RT_STREAMING_STOP)
			{
				AdiRealTimeStop();
				CyU3PDebugPrint (4, "Stop real time stream command detected.\r\n");
			}
			if (eventFlag & ADI_RT_STREAMING_DONE)
			{
				AdiRealTimeFinished();
				CyU3PDebugPrint (4, "Real time stream finished.\r\n");
			}
			if (eventFlag & ADI_RT_STREAMING_START)
			{
				AdiRealTimeStart();
				CyU3PDebugPrint (4, "Real time stream started.\r\n");
			}

			//Handle generic data stream commands
			if (eventFlag & ADI_DATA_STREAMING_START)
			{
				AdiGenericDataStreamStart();
				CyU3PDebugPrint (4, "Generic data stream started.\r\n");
			}
			if (eventFlag & ADI_DATA_STREAMING_STOP)
			{
				AdiGenericDataStreamStop();
				CyU3PDebugPrint (4, "Stop generic stream command detected.\r\n");
			}
			if (eventFlag & ADI_DATA_STREAMING_DONE)
			{
				AdiGenericDataStreamFinished();
				CyU3PDebugPrint (4, "Generic data stream finished.\r\n");
			}

			//Handle burst data stream commands
			if (eventFlag & ADI_BURST_STREAMING_START)
			{
				AdiBurstStreamStart();
				CyU3PDebugPrint (4, "Burst data stream started.\r\n");
			}
			if (eventFlag & ADI_BURST_STREAMING_STOP)
			{
				AdiBurstStreamStop();
				CyU3PDebugPrint (4, "Stop burst stream command detected.\r\n");
			}
			if (eventFlag & ADI_BURST_STREAMING_DONE)
			{
				AdiBurstStreamFinished();
				CyU3PDebugPrint (4, "Burst data stream finished.\r\n");
			}

    	}
        /* Allow other ready threads to run. */
        CyU3PThreadRelinquish ();
    }
}

/*
 * Function CyFxApplicationDefine(void)
 *
 * This function is automatically called by the RTOS kernel after booting.
 * It must define all the threads used in the application.
 *
 * Returns: void
 */
void CyFxApplicationDefine(void)
{
    void *ptr = NULL;
    uint32_t retThrdCreate = CY_U3P_SUCCESS;

    //Create application (main) thread
    ptr = CyU3PMemAlloc (APPTHREAD_STACK);
    retThrdCreate = CyU3PThreadCreate (&appThread, /* Thread structure. */
            "21:AppThread",                        /* Thread ID and name. */
            AppThread_Entry,                       /* Thread entry function. */
            0,                                     /* Thread input parameter. */
            ptr,                                   /* Pointer to the allocated thread stack. */
            APPTHREAD_STACK,                       /* Allocated thread stack size. */
            APPTHREAD_PRIORITY,                    /* Thread priority. */
            APPTHREAD_PRIORITY,                    /* Thread pre-emption threshold: No preemption. */
            CYU3P_NO_TIME_SLICE,                   /* No time slice. Thread will run until task is
                                                      completed or until the higher priority
                                                      thread gets active. */
            CYU3P_AUTO_START                       /* Start the thread immediately. */
            );

    //Check if creating thread succeeded
    if (retThrdCreate != CY_U3P_SUCCESS)
    {
    	//If thread creation fails try to handle error
    	AdiFatalErrorHandler(ERROR_THREAD_START);
    }

    //Create thread for streaming data
    ptr = CyU3PMemAlloc (STREAMINGTHREAD_STACK);
    retThrdCreate = CyU3PThreadCreate (&streamingThread, 	/* Thread structure. */
            "22:StreamingThread",                 			/* Thread ID and name. */
            AdiDataStream_Entry,              				/* Thread entry function. */
            0,                                     			/* Thread input parameter. */
            ptr,                                   			/* Pointer to the allocated thread stack. */
            STREAMINGTHREAD_STACK,                       	/* Allocated thread stack size. */
            STREAMINGTHREAD_PRIORITY,                    	/* Thread priority. */
            STREAMINGTHREAD_PRIORITY,                    	/* Thread pre-emption threshold: No preemption. */
            CYU3P_NO_TIME_SLICE,                   			/* No time slice. Thread will run until task is
                                                      	  	   completed or until the higher priority
                                                      	  	   thread gets active. */
            CYU3P_AUTO_START                      			/* Start the thread immediately. */
            );

    //Check if creating thread succeeded
    if (retThrdCreate != CY_U3P_SUCCESS)
    {
    	//If thread creation fails try to handle error
    	AdiFatalErrorHandler(ERROR_THREAD_START);
    }
}

/*
 * Function: AdiFatalErrorHandler()
 *
 * Handles configuration errors during boot time by resetting the FX3 so it can be reprogrammed.
 *
 * Returns: void
 */
void AdiFatalErrorHandler(uint32_t ErrorType)
{
	//Reset the part if more than two errors have occurred
	if(errorCount > 2)
	{
		ErrorType = ERROR_OTHER;
	}

	//Perform different operations depending on the error type
	switch(ErrorType)
	{
	case ERROR_GENERAL_INIT:
		//Power cycle the device
		CyU3PDeviceReset(CyFalse);
		break;

	case ERROR_CACHE_CONTROL:
		//Power cycle the device
		CyU3PDeviceReset(CyFalse);
		break;

	case ERROR_PIN_INIT:
		//Retry the pin initialization function
		AdiGPIOInit();
		break;

	case ERROR_GPIO_MATRIX:
		//Power cycle the device
		CyU3PDeviceReset(CyFalse);
		break;

	case ERROR_THREAD_START:
		//Stop both application threads, and restart
		CyU3PThreadDestroy(&appThread);
		CyU3PThreadDestroy(&streamingThread);
		CyU3PThreadDestroy(&dataCaptureThread);
		CyFxApplicationDefine();
		break;

	case ERROR_OTHER:
	default:
		//Power cycle the device
		CyU3PDeviceReset(CyFalse);
		break;
	}
	//Increment the error counter
	errorCount++;
}

/*
 * Function: main(void)
 *
 * This is the main entry point function which is executed when the part first powers on.
 * It initializes the device, memory, and IO matrix, and then boots the RTOS kernel.
 *
 * Returns: 0
 */
int main (void)
{
    CyU3PIoMatrixConfig_t io_cfg;
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    CyU3PSysClockConfig_t sysclk_cfg;

    //Initialize the device

    sysclk_cfg.setSysClk400 = CyTrue;
    sysclk_cfg.useStandbyClk = CyFalse;
    sysclk_cfg.clkSrc = CY_U3P_SYS_CLK;
    sysclk_cfg.cpuClkDiv = 2;
    sysclk_cfg.dmaClkDiv = 2;
    sysclk_cfg.mmioClkDiv = 2;

    status = CyU3PDeviceInit (&sysclk_cfg);

    if (status != CY_U3P_SUCCESS)
    {
    	AdiFatalErrorHandler(ERROR_GENERAL_INIT);
    }
    status = CyU3PDeviceCacheControl (CyTrue, CyTrue, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiFatalErrorHandler(ERROR_CACHE_CONTROL);
    }

    /* Configure the io matrix to implement SPI and enable UART
     * debugging on DQ30 and DQ31 (GPIO48 and GPIO49).
     */
    CyU3PMemSet ((uint8_t *)&io_cfg, 0, sizeof(io_cfg));
    io_cfg.isDQ32Bit = CyFalse;
    io_cfg.s0Mode = CY_U3P_SPORT_INACTIVE;
    io_cfg.s1Mode = CY_U3P_SPORT_INACTIVE;
    io_cfg.useUart   = CyTrue;
    io_cfg.useI2C    = CyFalse;
    io_cfg.useI2S    = CyFalse;
    io_cfg.useSpi    = CyTrue;
    io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
    io_cfg.gpioSimpleEn[0]  = 0;
    io_cfg.gpioSimpleEn[1]  = 0;
    io_cfg.gpioComplexEn[0] = 0;
    io_cfg.gpioComplexEn[1] = 0;
    status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiFatalErrorHandler(ERROR_GPIO_MATRIX);
    }

    //Start the RTOS kernel
    CyU3PKernelEntry();

    //Return 0 to make the compiler happy
    return 0;

}
