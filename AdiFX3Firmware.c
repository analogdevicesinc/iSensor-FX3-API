/*
 ## Analog Devices Inc. FX3 Interface Firmware (AdiFX3Firmware.c)
 ## ===========================
 ##
 ##  Copyright Analog Devices Incorporated, 2018-2019,
 ##  All Rights Reserved
 ##
 ##  THIS SOFTWARE IS BUILT AROUND LIBRARIES DEVELOPED
 ##	 AND MAINTAINED BY CYPRESS INC.
 ##
 ##  Use of this file is governed
 ##  by the license agreement included
 ##	 in this repository.
 ##
 ##	 Juan Chong (juan.chong@analog.com), Alex Nolan (alex.nolan@analog.com)
 ##
 ## ===========================
 */



#include "AdiFX3Firmware.h"

/*
 * Thread and Thread Management Definitions
 */

/*Thread for real time streaming function */
CyU3PThread streamingThread;

/*Thread for the main application */
CyU3PThread appThread;

/*ADI event structure */
CyU3PEvent eventHandler;

/*ADI GPIO event structure */
CyU3PEvent gpioHandler;

/*
 * DMA Channel Definitions
 */

/*DMA channel for real time streaming (SPI to USB BULK-IN 0x81) */
CyU3PDmaChannel StreamingChannel;

/*DMA channel for BULK-OUT endpoint 0x1 (PC to FX3) */
CyU3PDmaChannel ChannelFromPC;

/*DMA channel for BULK-IN endpoint 0x82 (FX3 to PC) */
CyU3PDmaChannel ChannelToPC;

/*DMA channel for reading a memory location into a DMA consumer */
CyU3PDmaChannel MemoryToSPI;

/*
 * Buffer Definitions
 */

/*USB Data buffer */
uint8_t USBBuffer[4096] __attribute__ ((aligned (32)));

/*Bulk endpoint output buffer */
uint8_t BulkBuffer[12288] __attribute__ ((aligned (32)));

/*
 * Application Configuration Definitions
 */

/*Global variable to track the SPI configuration */
CyU3PSpiConfig_t spiConfig;

/*DMA buffer structure for output buffer */
CyU3PDmaBuffer_t ManualDMABuffer;

/*DMA buffer structure for SPI transmit */
CyU3PDmaBuffer_t SpiDmaBuffer;

/*Global to track the part type */
PartType DUTType;

/*
 * Application constants
 */

/*Constant firmware ID string. Manually updated when building new firmware. */
const uint8_t FirmwareID[32] __attribute__ ((aligned (32))) = { 'A', 'D', 'I', ' ', 'F', 'X', '3', ' ', 'R', 'E', 'V', ' ', '1', '.', '0', '.', '6', '-','P','U','B',' ', '\0' };

/*Constant error string used to write "ERROR" to output buffer */
const uint8_t ErrorString[16] __attribute__ ((aligned (16))) = { 'E', 'R', 'R', 'O', 'R', '\0'};

/*Constant FX3 unique serial number */
char serial_number[] __attribute__ ((aligned (32))) = {
	    '0',0x00,'0',0x00,'0',0x00,'0',0x00,
	    '0',0x00,'0',0x00,'0',0x00,'0',0x00,
	    '0',0x00,'0',0x00,'0',0x00,'0',0x00,
	    '0',0x00,'0',0x00,'0',0x00,'0',0x00,
};

/*
 * Runtime Global Variables
 */

/*
 * Global application variables
 */

/*Track the USB connection speed */
uint16_t usbBufferSize = 0;

/*Track main application execution */
CyBool_t appActive = CyFalse;

/*Signal RT thread to kill data capture early (True = kill thread signaled, False = allow execution) */
static volatile CyBool_t killEarly = CyFalse;

/*Bit mask of the starting timer pin configuration */
uint32_t timerPinConfig;

/*
 * Global user configuration variables
 */

/*Track the number of bytes per real time frame */
uint32_t bytesPerFrame = 200;

/*Track the stall time in microseconds. This is the same as the FX3Api stall time setting */
uint32_t stallTime;

/*Track the busy pin number */
uint16_t busyPin = 4;

/*Track the data ready pin number */
uint16_t DrPin = 3;

/*Track if data ready is active (True = active, False = inactive) */
CyBool_t DrActive = CyFalse;

/*Track data ready polarity (True = rising, False = falling) */
CyBool_t DrPolarity = CyTrue;

/*Track the pin exit setting for RT stream mode (True = enabled, False = disabled) */
CyBool_t pinExitEnableDisable = CyFalse;

/*Track the pin start setting for RT stream mode (True = enabled, False = disabled) */
CyBool_t pinStartEnableDisable = CyFalse;

/*Track the number of real-time captures to record (0 = Infinite) */
uint32_t numRealTimeCaptures = 0;

/*Track the total size of generic stream transfer in 16-bit words */
uint16_t transferWordLength = 0;

/*Track the total size of generic and burst stream transfers in bytes */
uint32_t transferByteLength = 0;

/*Track the total size of a generic or burst stream rounded to a multiple of 16 */
uint16_t roundedByteTransferLength = 0;

/*Track the number of captures requested for the generic data stream */
uint32_t numCaptures = 0;

/*Track the number of buffers requested for the generic data stream */
uint32_t numBuffers = 0;

/*Track the number of bytes to be read per buffer */
uint16_t bytesPerBuffer = 0;

/*Pointer to byte array of registers needing to be read by the generic data stream */
uint8_t *regList;

/*Number of bytes per USB packet in generic data stream mode */
uint16_t bytesPerUsbPacket = 0;



/*
 * Function: AdiControlEndpointHandler (uint32_t setupdat0, uint32_t setupdat1)
 *
 * This function handles events generated by the control endpoint. All vendor requests are handled
 * in this function.
 *
 * setupdat0: The first set of setup data
 *
 * setupdat1: The second set of setup data
 *
 * Returns: A boolean indicating if the control endpoint event was handled properly
 */
CyBool_t AdiControlEndpointHandler (uint32_t setupdat0, uint32_t setupdat1)
{
    /* Fast enumeration is used. Only requests addressed to the interface, class,
     * vendor and unknown control requests are received by this function. */

    uint8_t  bRequest, bReqType;
    uint8_t  bType, bTarget;
    uint16_t wValue, wIndex, wLength;
    CyBool_t isHandled = CyFalse;
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
    uint16_t *bytesRead = 0;

    /* Decode the fields from the setup request. */
    bReqType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
    bType    = (bReqType & CY_U3P_USB_TYPE_MASK);
    bTarget  = (bReqType & CY_U3P_USB_TARGET_MASK);
    bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
    wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
    wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
    wLength   = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)   >> CY_U3P_USB_LENGTH_POS);

    /* Handle vendor requests */
    if (bType == CY_U3P_USB_VENDOR_RQT)
    {
        isHandled = CyTrue;

        //CyU3PDebugPrint (4, "Vendor request = 0x%x\r\n", bRequest);

        switch (bRequest)
        {
        	//special command to trigger a data capture and measure the corresponding busy pulse
        	case ADI_BUSY_MEASURE:
        		status = AdiMeasureBusyPulse(wLength);
        		break;

        	//Bulk register read/write using RegReadArray
        	case ADI_BULK_REGISTER_TRANSFER:
        		CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
        		status = AdiBulkByteTransfer(wIndex, wValue);
        		USBBuffer[0] = status & 0xFF;
        		USBBuffer[1] = (status & 0xFF00) >> 8;
        		USBBuffer[2] = (status & 0xFF0000) >> 16;
        		USBBuffer[3] = (status & 0xFF000000) >> 24;
        		CyU3PUsbSendEP0Data (4, USBBuffer);
        		break;

        	//Read single word for IRegInterface
        	case ADI_READ_BYTES:
        		AdiReadRegBytes(wIndex);
        		break;

        	//Write single byte for IRegInterface
        	case ADI_WRITE_BYTE:
        		AdiWriteRegByte(wIndex, wValue & 0xFF);
        		break;

        	//Pulse drive for a specified amount of time
        	case ADI_PULSE_DRIVE:
        		//Read config data into USBBuffer
        		CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
        		//Run pulse drive function
        		status = AdiPulseDrive();
        		//Send back status over the BULK-In endpoint
        		USBBuffer[0] = status & 0xFF;
        		USBBuffer[1] = (status & 0xFF00) >> 8;
        		USBBuffer[2] = (status & 0xFF0000) >> 16;
        		USBBuffer[3] = (status & 0xFF000000) >> 24;
        		ManualDMABuffer.buffer = USBBuffer;
        		ManualDMABuffer.size = 4096;
        		ManualDMABuffer.count = 4;
        		CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);
        		break;

        	//Wait on an edge, with timeout
        	case ADI_PULSE_WAIT:
        		//Run pulse wait function
        		status = AdiPulseWait(wLength);
        		break;

        	//Set a pin
        	case ADI_SET_PIN:
        		status = AdiSetPin(wIndex, (CyBool_t) wValue);
            	USBBuffer[0] = status & 0xFF;
            	USBBuffer[1] = (status & 0xFF00) >> 8;
            	USBBuffer[2] = (status & 0xFF0000) >> 16;
            	USBBuffer[3] = (status & 0xFF000000) >> 24;
            	CyU3PUsbSendEP0Data (wLength, USBBuffer);
        		break;

        	//ID Check
            case ADI_FIRMWARE_ID_CHECK:
                status = CyU3PUsbSendEP0Data (32, (uint8_t *)FirmwareID);
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
                break;

            //Serial Number Check
            case ADI_SERIAL_NUMBER_CHECK:
            	status = CyU3PUsbSendEP0Data (32, (uint8_t *)serial_number);
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
                break;

            /* Hard-reset the FX3 firmware (return to bootloader mode) */
            case ADI_HARD_RESET:

            	CyU3PUsbAckSetup();
            	CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
            	CyU3PThreadSleep(500);
            	CyU3PConnectState(CyFalse, CyTrue);
            	AdiAppStop ();
            	CyU3PPibDeInit ();
            	CyU3PThreadSleep(500);
				CyU3PDeviceReset(CyFalse);
				CyU3PThreadSleep(500);

            	break;

            /* Soft-reset the FX3 firmware (restart the ADI application firmware) */
            case ADI_WARM_RESET:

            	CyU3PUsbAckSetup();
            	CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
            	CyU3PThreadSleep(500);
            	CyU3PConnectState(CyFalse, CyTrue);
            	AdiAppStop ();
            	CyU3PPibDeInit ();
            	CyU3PThreadSleep(500);
            	CyU3PDeviceReset(CyTrue);
            	CyU3PThreadSleep(500);

            	break;

            //Set the SPI config
            case ADI_SET_SPI_CONFIG:
            	isHandled = AdiSpiUpdate(wIndex, wValue, wLength);
            	break;

            //Read a GPIO pin specified by index
            case ADI_READ_PIN:
            	status = AdiPinRead(wIndex);
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Read the current SPI config
            case ADI_READ_SPI_CONFIG:
            	status = AdiGetSpiSettings();
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Real time stream control. Index will start(1)/stop(0) the stream, and value will enable(1)/disable(0) pin exit
            case ADI_STREAM_REALTIME:
            	if (wIndex)
            	{
            		pinExitEnableDisable = (CyBool_t) wValue;
            		status = CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_START, CYU3P_EVENT_OR);
            	}
            	else
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_STOP, CYU3P_EVENT_OR);
            	}
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Read the value from the complex GPIO timer
            case ADI_READ_TIMER_VALUE:
            	status = AdiReadTimerValue();
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

            //Command to do nothing
            case ADI_NULL_COMMAND:
            	isHandled = CyTrue;
            	break;

            //Get the current status of the FX3
            case ADI_GET_STATUS:
            	USBBuffer[0] = status & 0xFF;
            	USBBuffer[1] = (status & 0xFF00) >> 8;
            	USBBuffer[2] = (status & 0xFF0000) >> 16;
            	USBBuffer[3] = (status & 0xFF000000) >> 24;
            	CyU3PUsbSendEP0Data (4, USBBuffer);
            	break;

            //Start a register stream triggered on data ready
            case ADI_STREAM_GENERIC_DATA:
            	if (wIndex)
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_GENERIC_STREAMING_START, CYU3P_EVENT_OR);
					if (status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "Setting generic stream enable flag failed, Error code = %d\r\n", status);
					}
            		transferByteLength = wLength;
            	}
            	else
            	{
            		status = CyU3PEventSet(&eventHandler, ADI_GENERIC_STREAMING_STOP, CYU3P_EVENT_OR);
            	}
            	if (status != CY_U3P_SUCCESS)
            	{
            		isHandled = CyFalse;
            	}
            	break;

			//Burst stream control. Index will start(1)/stop(0) the stream
			case ADI_STREAM_BURST_DATA:
				if (wIndex)
				{
					status = CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_START, CYU3P_EVENT_OR);
				}
				else
				{
					status = CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_STOP, CYU3P_EVENT_OR);
				}
				if (status != CY_U3P_SUCCESS)
				{
					isHandled = CyFalse;
				}
				break;

			//Get the measured DR frequency
            case ADI_MEASURE_DR:
            	//Read config data into USBBuffer
				CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
				//Run pulse drive function
				status = AdiMeasureDR();
				break;

			//PWM configuration
            case ADI_PWM_CMD:
            	//Read config data into USBBuffer
				CyU3PUsbGetEP0Data(wLength, USBBuffer, bytesRead);
				//Run pulse drive function (index = 1 to enable, 0 to disable)
				status = AdiConfigurePWM((CyBool_t) wIndex);
            	break;

            case ADI_TRANSFER_BYTES:
            	//Call the transfer bytes function
            	//upper 2 write bytes are passed in wIndex, lower are passed in wValue
            	status = AdiTransferBytes(wIndex << 16 | wValue);
            	break;

            case ADI_TRANSFER_STREAM:
            	//TODO: Implement transfer stream functionality
            	isHandled = CyTrue;
            	break;

            default:
                // This is unknown request
            	//CyU3PDebugPrint (4, "ERROR: Unknown vendor command 0x%x\r\n", bRequest);
                isHandled = CyFalse;
                break;
        }

        if (bType == CY_U3P_USB_STANDARD_RQT)
        {
            /* Handle SET_FEATURE(FUNCTION_SUSPEND) and CLEAR_FEATURE(FUNCTION_SUSPEND)
             * requests here. It should be allowed to pass if the device is in configured
             * state and failed otherwise. */
            if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
                        || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
            {
                if (appActive)
                    CyU3PUsbAckSetup ();
                else
                    CyU3PUsbStall (0, CyTrue, CyFalse);

                isHandled = CyTrue;
            }

            if(bTarget == CY_U3P_USB_TARGET_ENDPT)
            {
            	isHandled = CyTrue;
            }
        }

        /* TODO: Implement the CLEAR_FEATURE request to clean up the ADI application.
         *
         * CLEAR_FEATURE request for endpoint is always passed to the setup callback
         * regardless of the enumeration model used. When a clear feature is received,
         * the previous transfer has to be flushed and cleaned up. This is done at the
         * protocol level. Since this is just a loopback operation, there is no higher
         * level protocol. So flush the EP memory and reset the DMA channel associated
         * with it. If there are more than one EP associated with the channel reset both
         * the EPs. The endpoint stall and toggle / sequence number is also expected to be
         * reset. Return CyFalse to make the library clear the stall and reset the endpoint
         * toggle. Or invoke the CyU3PUsbStall (ep, CyFalse, CyTrue) and return CyTrue.
         * Here we are clearing the stall.
        if ((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
                && (wValue == CY_U3P_USBX_FS_EP_HALT))
        {
            if ((wIndex == CY_FX_EP_PRODUCER) || (wIndex == CY_FX_EP_CONSUMER))
            {
                if (glIsApplnActive)
                {
                    CyU3PUsbSetEpNak (CY_FX_EP_PRODUCER, CyTrue);
                    CyU3PUsbSetEpNak (CY_FX_EP_CONSUMER, CyTrue);
                    CyU3PBusyWait (125);

                    CyU3PDmaChannelReset (&glChHandleBulkLp);
                    CyU3PUsbFlushEp (CY_FX_EP_PRODUCER);
                    CyU3PUsbFlushEp (CY_FX_EP_CONSUMER);
                    CyU3PUsbResetEp (CY_FX_EP_PRODUCER);
                    CyU3PUsbResetEp (CY_FX_EP_CONSUMER);
                    CyU3PDmaChannelSetXfer (&glChHandleBulkLp, CY_FX_BULKLP_DMA_TX_SIZE);
                    CyU3PUsbStall (wIndex, CyFalse, CyTrue);

                    CyU3PUsbSetEpNak (CY_FX_EP_PRODUCER, CyFalse);
                    CyU3PUsbSetEpNak (CY_FX_EP_CONSUMER, CyFalse);

                    CyU3PUsbAckSetup ();
                    isHandled = CyTrue;
                }
            }
        } */

        //If there was an error return false to stall the request
        if (status != CY_U3P_SUCCESS)
        {
            isHandled = CyFalse;
        }
    }
    return isHandled;
}

CyU3PReturnStatus_t AdiTransferStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;

	/* Get the data from the control endpoint */
	status = CyU3PUsbGetEP0Data(transferByteLength, USBBuffer, &bytesRead);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Failed to read configuration data from control endpoint!, error code = %d\r\n", status);
	}

	//The data is formatted as follows
	//NumCaptures[1-4], NumBuffers[5-8], BytesPerBuffer[9-10], MOSIData.Count()[11-12], MOSIData[13 - ...]

	/* Disable VBUS ISR */
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	/* Disable GPIO interrupt before attaching interrupt to pin */
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	//If using DR triggering configure the selected pin as an input with the correct polarity
	if(DrActive)
	{
		//Configure the pin as an input with interrupts enabled on the selected edge
	}

	//Set up the DMA channel

	//Set the data stream thread event to begin a capture

	return status;
}

CyU3PReturnStatus_t AdiTransferStreamFinish()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//If DrActive restore the data ready to normal (input, no interrupts) mode

	//Destroy DMA channel

	//Re-enable interrupts

	//Reset timer configuration
	return status;
}

/*
 * Function: AdiMeasureBusyPulse(uint16_t transferLength)
 *
 * Sets a user configurable trigger condition and then measures the following GPIO pulse.
 * This function is approx. microsecond accurate.
 *
 * transferLength: The amount of data (in bytes) to read from the USB buffer
 *
 * Returns: A status code indicating the success of the measure pulse operation
 */
CyU3PReturnStatus_t AdiMeasureBusyPulse(uint16_t transferLength)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t *bytesRead = 0;
	uint16_t busyPin, triggerPin;
	CyBool_t pinValue, exitCondition, SpiTriggerMode, validPin, busyPolarity, triggerPolarity;
	uint32_t currentTime, lastTime, timeout, rollOverCount, driveTime;
	CyU3PGpioSimpleConfig_t gpioConfig;

	//Read config data into USBBuffer
	CyU3PUsbGetEP0Data(transferLength, USBBuffer, bytesRead);

	//Parse general request data from USBBuffer
	busyPin = USBBuffer[0];
	busyPin = busyPin + (USBBuffer[1] << 8);
	busyPolarity = (CyBool_t) USBBuffer[2];
	timeout = USBBuffer[3];
	timeout = timeout + (USBBuffer[4] << 8);
	timeout = timeout + (USBBuffer[5] << 16);
	timeout = timeout + (USBBuffer[6] << 24);

	//Get the trigger mode
	SpiTriggerMode = USBBuffer[7];

	//Convert ms to timer ticks
	timeout = timeout * MS_TO_TICKS_MULT;

	//Check that busy pin specified is configured as input
	status = CyU3PGpioSimpleGetValue(busyPin, &pinValue);
	validPin = CyTrue;
	if(status != CY_U3P_SUCCESS)
	{
		//If initial pin read fails try and configure as input
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

		//get the pin value again after configuring
		status = CyU3PGpioSimpleGetValue(busyPin, &pinValue);

		//If pin setup not successful skip wait operation and return -1
		if(status != CY_U3P_SUCCESS)
		{
			validPin = CyFalse;
		}
	}

	//Set default for trigger pin to invalid value
	triggerPin = 0xFFFF;

	//Only perform pulse wait if the pin is able to act as an input
	if(validPin)
	{
		//parse the trigger specific data and trigger
		if(SpiTriggerMode)
		{
			uint16_t RegAddr, RegValue;
			uint8_t spiBuf[2];

			//parse register address
			RegAddr = USBBuffer[8];
			RegAddr = RegAddr + (USBBuffer[9] << 8);

			//parse register write value
			RegValue = USBBuffer[10];
			RegValue = RegValue + (USBBuffer[11] << 8);

			//transmit addr and least significant byte of SpiValue
			spiBuf[0] = RegAddr | 0x80;
			spiBuf[1] = RegValue & 0xFF;
			CyU3PSpiTransmitWords(spiBuf, 2);

			//wait for stall
			AdiSleepForMicroSeconds(stallTime);

			//transmit (addr + 1) and most significant byte of SpiValue
			spiBuf[0] = (RegAddr + 1) | 0x80;
			spiBuf[1] = (RegValue & 0xFF00) >> 8;
			CyU3PSpiTransmitWords(spiBuf, 2);
		}
		else
		{
			//parse parameters from USB Buffer
			triggerPin = USBBuffer[8];
			triggerPin = triggerPin + (USBBuffer[9] << 8);

			triggerPolarity = USBBuffer[10];

			driveTime = USBBuffer[11];
			driveTime = driveTime + (USBBuffer[12] << 8);
			driveTime = driveTime + (USBBuffer[13] << 16);
			driveTime = driveTime + (USBBuffer[14] << 24);

			//convert drive time (ms) to ticks
			driveTime = driveTime * MS_TO_TICKS_MULT;

			//want to configure the trigger pin to act as an output
			status = CyU3PDeviceGpioOverride(triggerPin, CyTrue);
			if(status != CY_U3P_SUCCESS)
			{
				CyU3PDebugPrint (4, "Error! GPIO override to exit PWM mode failed, error code: 0x%x\r\n", status);
				return status;
			}

			//Disable the GPIO
			status = CyU3PGpioDisable(triggerPin);
			if(status != CY_U3P_SUCCESS)
			{
				CyU3PDebugPrint (4, "Error! Pin disable while exiting PWM mode failed, error code: 0x%x\r\n", status);
			}

			//Reset the pin timer register to 0
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;
			//Disable interrupts on the timer pin
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= ~(CY_U3P_LPP_GPIO_INTRMODE_MASK);
			//Set the pin timer period to 0xFFFFFFFF;
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = 0xFFFFFFFF;

			//Configure the pin to act as an output and drive
			gpioConfig.outValue = triggerPolarity;
			gpioConfig.inputEn = CyFalse;
			gpioConfig.driveLowEn = CyTrue;
			gpioConfig.driveHighEn = CyTrue;
			gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
			status = CyU3PGpioSetSimpleConfig(triggerPin, &gpioConfig);
		    if (status != CY_U3P_SUCCESS)
		    {
		    	CyU3PDebugPrint (4, "Error! GPIO config to exit PWM mode failed, error code: 0x%x\r\n", status);
		    }
		}

		//Wait until the busy pin reaches the selected polarity
		while(((GPIO->lpp_gpio_simple[busyPin] & CY_U3P_LPP_GPIO_IN_VALUE) >> 1) != busyPolarity);

		//In pin mode subtract the wait time from the total drive time
		if(!SpiTriggerMode)
		{
			//Set the pin config for sample now mode
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
			//wait for sample to finish
			while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
			//read timer value
			driveTime = driveTime - GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;
		}

		//Reset the pin timer register to 0
		GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;
		//Disable interrupts on the timer pin
		GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= ~(CY_U3P_LPP_GPIO_INTRMODE_MASK);
		//Set the pin timer period to 0xFFFFFFFF;
		GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = 0xFFFFFFFF;

		//Reset state variables
		currentTime = 0;
		rollOverCount = 0;
		lastTime = 0;
		exitCondition = CyFalse;

		//Wait for the GPIO pin the reach the desired level or timeout
		while(!exitCondition)
		{
			//Store previous time
			lastTime = currentTime;

			//Set the pin config for sample now mode
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
			//wait for sample to finish
			while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
			//read timer value
			currentTime = GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;

			//Read the pin value
			pinValue = ((GPIO->lpp_gpio_simple[busyPin] & CY_U3P_LPP_GPIO_IN_VALUE) >> 1);

			//Check if rollover occured
			if(currentTime < lastTime)
			{
				rollOverCount++;
			}

			//update the exit condition
			if(timeout)
			{
				exitCondition = ((pinValue != busyPolarity) || (currentTime >= timeout));
			}
			else
			{
				exitCondition = (pinValue != busyPolarity);
			}

			//Check if the pin drive can stop
			if(!SpiTriggerMode)
			{
				if(currentTime > driveTime)
				{
					//drive the opposite polarity
					CyU3PGpioSimpleSetValue(triggerPin, ~triggerPolarity);
				}
				//Set trigger mode to true to prevent this loop from hitting again
				SpiTriggerMode = CyTrue;
			}
		}

		//add 2us to current time (fudge factor, calibrated using DSLogic Pro)
		if(currentTime < (0xFFFFFFFF - 20))
		{
			currentTime = currentTime + 20;
		}
		else
		{
			currentTime = 0;
			rollOverCount++;
		}
	}
	else
	{
		//Case where pin could not be configured as input
		currentTime = 0xFFFFFFFF;
	}

	//Reset trigger pin to input if needed
	if(triggerPin != 0xFFFF)
	{
		CyU3PGpioDisable(triggerPin);
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(triggerPin, &gpioConfig);
	}

	//Return pulse wait data over ChannelToPC
	BulkBuffer[0] = status & 0xFF;
	BulkBuffer[1] = (status & 0xFF00) >> 8;
	BulkBuffer[2] = (status & 0xFF0000) >> 16;
	BulkBuffer[3] = (status & 0xFF000000) >> 24;
	BulkBuffer[4] = currentTime & 0xFF;
	BulkBuffer[5] = (currentTime & 0xFF00) >> 8;
	BulkBuffer[6] = (currentTime & 0xFF0000) >> 16;
	BulkBuffer[7] = (currentTime & 0xFF000000) >> 24;
	BulkBuffer[8] = rollOverCount & 0xFF;
	BulkBuffer[9] = (rollOverCount & 0xFF00) >> 8;
	BulkBuffer[10] = (rollOverCount & 0xFF0000) >> 16;
	BulkBuffer[11] = (rollOverCount & 0xFF000000) >> 24;
	BulkBuffer[12] = MS_TO_TICKS_MULT & 0xFF;
	BulkBuffer[13] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	BulkBuffer[14] = (MS_TO_TICKS_MULT & 0xFF0000) >> 16;
	BulkBuffer[15] = (MS_TO_TICKS_MULT & 0xFF000000) >> 24;

	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = 16;

	//Send the data to PC
	CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}

/*
 * Function: AdiConfigurePWM(CyBool_t EnablePWM)
 *
 * This function configures the FX3 PWM options. The pin number, threshold value,
 * and period are provided in the USBBuffer, and are calculated in the FX3Api.
 *
 * enablePWM: If the PWM should be enabled or disabled.
 *
 * Returns: status
 */
CyU3PReturnStatus_t AdiConfigurePWM(CyBool_t EnablePWM)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pinNumber;
	uint32_t threshold, period;

	//Get the pin number
	pinNumber = USBBuffer[0];
	pinNumber |= (USBBuffer[1] << 8);

	if(EnablePWM)
	{
		//get the period
		period = USBBuffer[2];
		period |= (USBBuffer[3] << 8);
		period |= (USBBuffer[4] << 16);
		period |= (USBBuffer[5] << 24);

		//get the threshold
		threshold = USBBuffer[6];
		threshold |= (USBBuffer[7] << 8);
		threshold |= (USBBuffer[8] << 16);
		threshold |= (USBBuffer[9] << 24);

		CyU3PDebugPrint (4, "Setting up PWM with period %d, threshold %d, for pin %d\r\n", period, threshold, pinNumber);

		//Override the selected pin to run as a complex GPIO
		status = CyU3PDeviceGpioOverride(pinNumber, CyFalse);
		if(status != CY_U3P_SUCCESS)
		{
			CyU3PDebugPrint (4, "Error! GPIO override for PWM mode failed, error code: 0x%s\r\n", status);
			return status;
		}

		//configure the selected pin in PWM mode
		CyU3PGpioComplexConfig_t gpioComplexConfig;
		CyU3PMemSet ((uint8_t *)&gpioComplexConfig, 0, sizeof (gpioComplexConfig));
		gpioComplexConfig.outValue = CyFalse;
		gpioComplexConfig.inputEn = CyFalse;
		gpioComplexConfig.driveLowEn = CyTrue;
		gpioComplexConfig.driveHighEn = CyTrue;
		gpioComplexConfig.pinMode = CY_U3P_GPIO_MODE_PWM;
		gpioComplexConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		gpioComplexConfig.timerMode = CY_U3P_GPIO_TIMER_HIGH_FREQ;
		gpioComplexConfig.timer = 0;
		gpioComplexConfig.period = period;
		gpioComplexConfig.threshold = threshold;
		status = CyU3PGpioSetComplexConfig(pinNumber, &gpioComplexConfig);
	    if (status != CY_U3P_SUCCESS)
	    {
	    	CyU3PDebugPrint (4, "Error! GPIO config for PWM mode failed, error code: 0x%s\r\n", status);
	    	return status;
	    }
	}
	else
	{
		//want to reset the specified pin to simple state without output driven
		status = CyU3PDeviceGpioOverride(pinNumber, CyTrue);
		if(status != CY_U3P_SUCCESS)
		{
			CyU3PDebugPrint (4, "Error! GPIO override to exit PWM mode failed, error code: 0x%s\r\n", status);
			return status;
		}

		//Disable the GPIO
		status = CyU3PGpioDisable(pinNumber);
		if(status != CY_U3P_SUCCESS)
		{
			CyU3PDebugPrint (4, "Error! Pin disable while exiting PWM mode failed, error code: 0x%s\r\n", status);
			return status;
		}

		/* Set the GPIO configuration for each GPIO that was just overridden */
		CyU3PGpioSimpleConfig_t gpioConfig;
		CyU3PMemSet ((uint8_t *)&gpioConfig, 0, sizeof (gpioConfig));
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

		status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);
	    if (status != CY_U3P_SUCCESS)
	    {
	    	CyU3PDebugPrint (4, "Error! GPIO config to exit PWM mode failed, error code: 0x%s\r\n", status);
	    	return status;
	    }
	}
	return status;
}

/*
 * Function: AdiTransferBytes(uint32_t writeData)
 *
 * This function performs a bi-directional SPI transfer, on up to 4 bytes of data.
 * The status code and data read back are returned on the control endpoint.
 *
 * writeData: The TX data to transmit to the slave device.
 *
 * Returns: status
 */
CyU3PReturnStatus_t AdiTransferBytes(uint32_t writeData)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t writeBuffer[4];
	uint8_t readBuffer[4];
	uint32_t transferSize;

	//populate the writebuffer
	writeBuffer[0] = writeData & 0xFF;
	writeBuffer[1] = (writeData & 0xFF00) >> 8;
	writeBuffer[2] = (writeData & 0xFF0000) >> 16;
	writeBuffer[3] = (writeData & 0xFF000000) >> 24;

	//Calculate number of bytes to transfer
	transferSize = spiConfig.wordLen / 8;

	//perform SPI transfer
	status = CyU3PSpiTransferWords(writeBuffer, transferSize, readBuffer, transferSize);

	/* Send status and data back via control endpoint */
	USBBuffer[0] = status & 0xFF;
	USBBuffer[1] = (status & 0xFF00) >> 8;
	USBBuffer[2] = (status & 0xFF0000) >> 16;
	USBBuffer[3] = (status & 0xFF000000) >> 24;
	USBBuffer[4] = readBuffer[0];
	USBBuffer[5] = readBuffer[1];
	USBBuffer[6] = readBuffer[2];
	USBBuffer[7] = readBuffer[3];
	CyU3PUsbSendEP0Data (8, USBBuffer);

	return status;
}

/*
 * Function: AdiReadRegBytes(uint16_t addr)
 *
 * This function reads a single word over SPI. Note that reads are not "full duplex"
 * and will require a discrete read to set the address to be read from.
 *
 * addr: The address to send to the DUT in the first SPI transaction
 *
 * Returns: status
 */
CyU3PReturnStatus_t AdiReadRegBytes(uint16_t addr)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t tempBuffer[2];

	/* Set the address to read from */
	tempBuffer[0] = (0x7F) & addr;
	/* Set the second byte to 0's */
	tempBuffer[1] = 0;
	/* Send SPI Read command */
	status = CyU3PSpiTransmitWords(tempBuffer, 2);
	/* Check that the transfer was successful and end function if failed */
	if (status != CY_U3P_SUCCESS)
	{
        CyU3PDebugPrint (4, "Error! CyU3PSpiTransmitWords failed, error code: 0x%s\r\n", status);
	}

	/* Stall for user-specified time */
	AdiSleepForMicroSeconds(stallTime);

	/* Receive the data requested */
	status = CyU3PSpiReceiveWords(tempBuffer, 2);
	/* Check that the transfer was successful and end function if failed */
	if (status != CY_U3P_SUCCESS)
	{
        CyU3PDebugPrint (4, "Error! CyU3PSpiReceiveWords failed!.\r\n");
	}

	/* Send status and data back via control endpoint */
	USBBuffer[0] = status & 0xFF;
	USBBuffer[1] = (status & 0xFF00) >> 8;
	USBBuffer[2] = (status & 0xFF0000) >> 16;
	USBBuffer[3] = (status & 0xFF000000) >> 24;
	USBBuffer[4] = tempBuffer[0];
	USBBuffer[5] = tempBuffer[1];
	CyU3PUsbSendEP0Data (6, USBBuffer);

	return status;
}

/*
 * Function: AdiWriteRegByte(uint16_t addr, uint8_t data)
 *
 * This function writes a single byte of data over the SPI bus
 *
 * addr: The address to write data to
 *
 * data: The byte of data to write to the address
 *
 * Returns: status
 */
CyU3PReturnStatus_t AdiWriteRegByte(uint16_t addr, uint8_t data)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t tempBuffer[2];
	tempBuffer[0] = 0x80 | addr;
	tempBuffer[1] = data;
	status = CyU3PSpiTransmitWords (tempBuffer, 2);
	/* Check that the transfer was successful and end function if failed */
	if (status != CY_U3P_SUCCESS)
	{
        CyU3PDebugPrint (4, "Error! CyU3PSpiTransmitWords failed!.\r\n");
        //AdiAppErrorHandler (status);
	}
	/* Send write status over the control endpoint */
	USBBuffer[0] = status & 0xFF;
	USBBuffer[1] = (status & 0xFF00) >> 8;
	USBBuffer[2] = (status & 0xFF0000) >> 16;
	USBBuffer[3] = (status & 0xFF000000) >> 24;
	CyU3PUsbSendEP0Data (4, USBBuffer);

	return status;
}

/*
 * Function: AdiPulseDrive()
 *
 * This function drives a GPIO pin for a specified number of milliseconds. If the
 * selected GPIO pin is not configured as an output, this function configures the pin.
 *
 * pin: The GPIO pin number to drive
 *
 * polarity: The polarity of the pin (True - High, False - Low)
 *
 * driveTime: The number of milliseconds to drive the pin for
 *
 * Returns: The status of the pin drive operation
 */
CyU3PReturnStatus_t AdiPulseDrive()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pinNumber;
	CyBool_t polarity, exit;
	uint32_t timerTicks, timerRollovers, rolloverCount, currentTime, lastTime;

	//Parse request data from USBBuffer
	pinNumber = USBBuffer[0];
	pinNumber = pinNumber + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	timerTicks = USBBuffer[3];
	timerTicks = timerTicks + (USBBuffer[4] << 8);
	timerTicks = timerTicks + (USBBuffer[5] << 16);
	timerTicks = timerTicks + (USBBuffer[6] << 24);
	timerRollovers = USBBuffer[7];
	timerRollovers = timerRollovers + (USBBuffer[8] << 8);
	timerRollovers = timerRollovers + (USBBuffer[9] << 16);
	timerRollovers = timerRollovers + (USBBuffer[10] << 24);

	//Configure the GPIO pin as a driven output
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = polarity;
	gpioConfig.inputEn = CyFalse;
	gpioConfig.driveLowEn = CyTrue;
	gpioConfig.driveHighEn = CyTrue;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);

	//Reset the pin timer register to 0
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;
	//Disable interrupts on the timer pin
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= ~(CY_U3P_LPP_GPIO_INTRMODE_MASK);
	//Set the pin timer period to 0xFFFFFFFF;
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = 0xFFFFFFFF;

	//If config fails try to disable and reconfigure
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDeviceGpioOverride(pinNumber, CyTrue);
		CyU3PGpioDisable(pinNumber);
		status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);
		if(status != CY_U3P_SUCCESS)
		{
			CyU3PDebugPrint (4, "Error! Unable to configure selected pin as output, status error: 0x%x\r\n", status);
			return status;
		}
	}

	exit = CyFalse;
	rolloverCount = 0;
	currentTime = 0;
	lastTime = 0;
	while(!exit)
	{
		//Store previous time
		lastTime = currentTime;

		//Set the pin config for sample now mode
		GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
		//wait for sample to finish
		while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
		//read timer value
		currentTime = GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;

		//Check if rollover occured
		if(currentTime < lastTime)
		{
			rolloverCount++;
		}

		exit = (currentTime >= timerTicks) && (rolloverCount >= timerRollovers);
	}

	//set the pin to opposite polarity
	CyU3PGpioSetValue(pinNumber, !polarity);

	//configure the selected pin as input and tristate
	CyU3PDeviceGpioOverride(pinNumber, CyTrue);

	//Disable the GPIO
	CyU3PGpioDisable(pinNumber);

	gpioConfig.outValue = CyFalse;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);

	//return the status
	return status;
}

/*
 * Function: AdiBulkByteTransfer()
 *
 * This function performs a bulk register transfer using the bulk in and out endpoints.
 * It handles function calls in the IRegInterface which require more than one register
 * read/write operation.
 *
 * Returns: The status of the transfer operation
 */
CyU3PReturnStatus_t AdiBulkByteTransfer(uint16_t numBytes, uint16_t bytesPerCapture)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t loopCounter = 0;
	uint8_t buffValue;
	uint8_t *bufPntr;
	uint8_t TxBuffer[2];
	uint32_t transferStatus = 0;
	CyU3PGpioIntrMode_t waitType = CY_U3P_GPIO_INTR_POS_EDGE;

	//Transfer in data via ChannelFromPC
	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = numBytes;
	ManualDMABuffer.status = 0;

	status = CyU3PDmaChannelSetupRecvBuffer(&ChannelFromPC, &ManualDMABuffer);

	//Wait for the DMA channel to finish (20ms timeout)
	while(transferStatus != CY_U3P_DMA_CB_RECV_CPLT && loopCounter < 4)
	{
		CyU3PEventGet(&(ChannelFromPC.flags), CY_U3P_DMA_CB_RECV_CPLT,  CYU3P_EVENT_OR, &transferStatus, 5);
		loopCounter++;
	}

	//Reset the DMA channel
	CyU3PDmaChannelReset(&ChannelFromPC);

	//Set the bytesPerCapture depending on DrActive
	if(!DrActive)
	{
		bytesPerCapture = numBytes;
	}
	else
	{
		//Set the transition type depending on the DrPolarity
		if(DrPolarity)
		{
			waitType = CY_U3P_GPIO_INTR_POS_EDGE;;
		}
		else
		{
			waitType = CY_U3P_GPIO_INTR_NEG_EDGE;
		}
	}

	//Loop through rest of the transfers
	bufPntr = BulkBuffer;
	loopCounter = 0;
	while(loopCounter < numBytes)
	{
		//Wait for data ready if needed and run through one set of registers
		if(DrActive)
		{
			AdiWaitForPin(DrPin, waitType, CYU3P_WAIT_FOREVER);
		}
		//For first transfer don't read back
		if(BulkBuffer[loopCounter] & 0x80)
		{
			//Case of a SPI write
			TxBuffer[0] = BulkBuffer[loopCounter];
			TxBuffer[1] = BulkBuffer[loopCounter + 1];
			CyU3PSpiTransmitWords(TxBuffer, 2);
			BulkBuffer[loopCounter] = 0;
			BulkBuffer[loopCounter + 1] = 0;
		}
		else
		{
			//Case of a SPI read
			TxBuffer[0] = BulkBuffer[loopCounter];
			TxBuffer[1] = 0;
			CyU3PSpiTransmitWords(TxBuffer, 2);
		}
		loopCounter+=2;

		AdiSleepForMicroSeconds(stallTime);

		//Loop through rest of the reads
		while(loopCounter < bytesPerCapture)
		{
			//Get the value out of the bulk buffer
			buffValue = BulkBuffer[loopCounter];

			if(buffValue & 0x80)
			{
				//If its a write command, perform write
				//perform SPI write
				TxBuffer[0] = buffValue;
				TxBuffer[1] = BulkBuffer[loopCounter + 1];
				CyU3PSpiTransmitWords(TxBuffer, 2);
				//Store 0 in the Bulk Buffer
				BulkBuffer[loopCounter] = 0;
				BulkBuffer[loopCounter + 1] = 0;
			}
			else
			{
				//If it's a read command, perform SPI read and write and store value in bulk buffer
				TxBuffer[0] = buffValue;
				TxBuffer[1] = 0;
				CyU3PSpiTransferWords(TxBuffer, 2, bufPntr, 2);
			}
			bufPntr += 2;
			loopCounter += 2;
			AdiSleepForMicroSeconds(stallTime);
		}
		//Receive the last two bytes
		if(buffValue & 0x80)
		{
			BulkBuffer[loopCounter] = 0;
			BulkBuffer[loopCounter + 1] = 0;
		}
		else
		{
			CyU3PSpiReceiveWords(bufPntr, 2);
		}
		//Increment loop counter
		loopCounter += 2;
	}

	//Send the data back over ChannelToPC
	status = CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}

/*
 * Function: AdiPulseWait(uint16_t transferLength)
 *
 * This function waits for a pin to reach a selected logic level. The PulseWait parameters are
 * passed in the USB buffer.
 *
 * pin is the GPIO pin number to poll
 *
 * polarity is the pin polarity which will trigger an exit condition
 *
 * delay is the wait time (in ms) from when the function starts before pin polling starts
 *
 * timeout is the time (in ms) to wait for the pin level before exiting
 */
CyU3PReturnStatus_t AdiPulseWait(uint16_t transferLength)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pin;
    uint16_t *bytesRead = 0;
	CyBool_t polarity, validPin, pinValue, exitCondition;
	uint32_t currentTime, lastTime, delay, timeoutTicks, timeoutRollover, rollOverCount;

	//Disable interrupts on the timer pin
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= ~(CY_U3P_LPP_GPIO_INTRMODE_MASK);
	//Set the pin timer period to 0xFFFFFFFF;
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = 0xFFFFFFFF;
	//Reset the pin timer register to 0
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;

	//Read config data into USBBuffer
	CyU3PUsbGetEP0Data(transferLength, USBBuffer, bytesRead);

	//Parse request data from USBBuffer
	pin = USBBuffer[0];
	pin = pin + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	delay = USBBuffer[3];
	delay = delay + (USBBuffer[4] << 8);
	delay = delay + (USBBuffer[5] << 16);
	delay = delay + (USBBuffer[6] << 24);
	timeoutTicks = USBBuffer[7];
	timeoutTicks = timeoutTicks + (USBBuffer[8] << 8);
	timeoutTicks = timeoutTicks + (USBBuffer[9] << 16);
	timeoutTicks = timeoutTicks + (USBBuffer[10] << 24);
	timeoutRollover = USBBuffer[11];
	timeoutRollover = timeoutRollover + (USBBuffer[12] << 8);
	timeoutRollover = timeoutRollover + (USBBuffer[13] << 16);
	timeoutRollover = timeoutRollover + (USBBuffer[14] << 24);

	//Convert ms to timer ticks
	delay = delay * MS_TO_TICKS_MULT;

	//Check that input pin specified is configured as input
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	validPin = CyTrue;
	if(status != CY_U3P_SUCCESS)
	{
		//If initial pin read fails try and configure as input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

		//get the pin value again after configuring
		status = CyU3PGpioSimpleGetValue(pin, &pinValue);

		//If pin setup not successful skip wait operation and return -1
		if(status != CY_U3P_SUCCESS)
		{
			validPin = CyFalse;
		}
	}

	//Only perform pulse wait if the pin is able to act as an input
	if(validPin)
	{
		//Wait for the delay, if needed
		currentTime = 0;
		rollOverCount = 0;
		lastTime = 0;
		exitCondition = CyFalse;
		if(delay > 0)
		{
			while(currentTime < delay)
			{
				//Set the pin config for sample now mode
				GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
				//wait for sample to finish
				while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
				//read timer value
				currentTime = GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;
			}
		}

		//Wait for the GPIO pin the reach the desired level or timeout
		while(!exitCondition)
		{
			//Store previous time
			lastTime = currentTime;

			//Set the pin config for sample now mode
			GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
			//wait for sample to finish
			while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
			//read timer value
			currentTime = GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;

			//Check if rollover occured
			if(currentTime < lastTime)
			{
				rollOverCount++;
			}

			//Read the pin value
			pinValue = ((GPIO->lpp_gpio_simple[pin] & CY_U3P_LPP_GPIO_IN_VALUE) >> 1);

			//update the exit condition (will always have valid timeout)
			//exits when pin reaches the desired polarity or timer reaches timeout
			exitCondition = ((pinValue == polarity) || ((currentTime >= timeoutTicks) && (rollOverCount >= timeoutRollover)));
		}

	}
	else
	{
		//Case where pin could not be configured as input
		currentTime = 0xFFFFFFFF;
	}

	//Return pulse wait data over ChannelToPC
	BulkBuffer[0] = status & 0xFF;
	BulkBuffer[1] = (status & 0xFF00) >> 8;
	BulkBuffer[2] = (status & 0xFF0000) >> 16;
	BulkBuffer[3] = (status & 0xFF000000) >> 24;
	BulkBuffer[4] = currentTime & 0xFF;
	BulkBuffer[5] = (currentTime & 0xFF00) >> 8;
	BulkBuffer[6] = (currentTime & 0xFF0000) >> 16;
	BulkBuffer[7] = (currentTime & 0xFF000000) >> 24;
	BulkBuffer[8] = rollOverCount & 0xFF;
	BulkBuffer[9] = (rollOverCount & 0xFF00) >> 8;
	BulkBuffer[10] = (rollOverCount & 0xFF0000) >> 16;
	BulkBuffer[11] = (rollOverCount & 0xFF000000) >> 24;

	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = 12;

	//Send the data to PC
	CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);

	return status;
}


/*
 * Function: AdiSetPin(uint16_t pinNumber, CyBool_t polarity)
 *
 * This function configures the specified pin as an output and sets the value
 *
 * pinNumber: The GPIO index of the pin to be set
 *
 * polarity: The polarity of the pin to be set (True - High, False - Low)
 *
 * Returns: The status of the operation
 */
CyU3PReturnStatus_t AdiSetPin(uint16_t pinNumber, CyBool_t polarity)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	//Configure pin as output and set the drive value
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = polarity;
	gpioConfig.inputEn = CyFalse;
	gpioConfig.driveLowEn = CyTrue;
	gpioConfig.driveHighEn = CyTrue;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);
	return status;
}

/*
 * Function: AdiSleepForMicroSeconds(uint32_t numTicks)
 *
 * This function blocks thread execution for a specified number of timer ticks.
 * It uses a complex GPIO timer which is based on the system clock.
 *
 * numTicks: The number of timer ticks to wait for.
 *
 * Returns: status
 */
CyU3PReturnStatus_t AdiSleepForMicroSeconds(uint32_t numMicroSeconds)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t finalTickCount, currentTime;

	//reset the timer register first to reduce overhead
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;

	//Offset the timer value
	if(numMicroSeconds > ADI_MICROSECONDS_SLEEP_OFFSET)
	{
		numMicroSeconds = numMicroSeconds - ADI_MICROSECONDS_SLEEP_OFFSET;
	}
	else
	{
		return status;
	}

	//Check if sleep is too long (would overflow on multiply) and return if needed
	//Use the CyU3PThreadSleep() if longer sleep is needed
	if(numMicroSeconds > 426172)
	{
		CyU3PDebugPrint (4, "ERROR: Sleep of %d microseconds not achievable with AdiSleepForMicroseconds, use system sleep call \r\n", numMicroSeconds);
		return CY_U3P_ERROR_BAD_ARGUMENT;
	}

	//calculate final tick count using MS multiplier
	finalTickCount = numMicroSeconds * MS_TO_TICKS_MULT;

	//scale back to microseconds
	finalTickCount = finalTickCount / 1000;

	currentTime = 0;
	while(currentTime < finalTickCount)
	{
		//Set the pin config for sample now mode
		GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status = (timerPinConfig | (CY_U3P_GPIO_MODE_SAMPLE_NOW << CY_U3P_LPP_GPIO_MODE_POS));
		//wait for sample to finish
		while (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_MODE_MASK);
		//read timer value
		currentTime = GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold;
	}
	return status;
}

/*
 * Function: AdiWaitForPin(uint32_t pinNumber, PinWaitType waitType)
 *
 * This function blocks the execution of the current thread until an event happens on the
 * specified GPIO pin.
 *
 * pinNumber: The GPIO pin number to poll
 *
 * waitType: The event type to wait for, as a PinWaitType
 *
 * Returns: void
 */
CyU3PReturnStatus_t AdiWaitForPin(uint32_t pinNumber, CyU3PGpioIntrMode_t interruptSetting, uint32_t timeoutTicks)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t gpioEventFlag;
	CyU3PGpioSimpleConfig_t gpioConfig;

	//Configure the specified pin as an input and attach the correct pin interrupt
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = interruptSetting;

	status = CyU3PGpioSetSimpleConfig(pinNumber, &gpioConfig);

	//Catch unspecified timeout
	if (timeoutTicks == 0)
	{
		timeoutTicks = CYU3P_WAIT_FOREVER;
	}

	if (status == CY_U3P_SUCCESS)
	{
		//Enable GPIO interrupts (in case it's not enabled)
		CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
		//Wait for GPIO interrupt flag
		status = CyU3PEventGet(&gpioHandler, pinNumber, CYU3P_EVENT_OR_CLEAR, &gpioEventFlag, timeoutTicks);
		//Disable GPIO interrupts until we need them again
		CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	}
	return status;
}

/*
 * Function: AdiMStoTicks(uint32_t timeInMS)
 *
 * Converts milliseconds to number of ticks and adjusts the resulting offset if below the
 * measurable minimum.
 *
 * timeInMS: The real stall time (in ms) desired.
 */
uint32_t AdiMStoTicks(uint32_t timeInMS)
{
	return timeInMS * MS_TO_TICKS_MULT;
}

/*
 * Function: AdiPinRead(uint16_t pin)
 *
 * This function handles Pin read control end point requests. It reads the value of a specified
 * GPIO pin, and sends that value over the control endpoint, along with the pin read status.
 *
 * Returns: The success of the pin read operation
 */
CyU3PReturnStatus_t AdiPinRead(uint16_t pin)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyBool_t pinValue = CyFalse;

	//get the pin value
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	if(status != CY_U3P_SUCCESS)
	{
		//If the initial pin read fails reconfigure the pin as in input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);
		//If the config is successful, read the pin value
		if(status == CY_U3P_SUCCESS)
		{
			status = CyU3PGpioSimpleGetValue(pin, &pinValue);
		}
	}

	//Put pin register value in output buffer
	USBBuffer[0] = pinValue;
	USBBuffer[1] = status & 0xFF;
	USBBuffer[2] = (status & 0xFF00) >> 8;
	USBBuffer[3] = (status & 0xFF0000) >> 16;
	USBBuffer[4] = (status & 0xFF000000) >> 24;
	//Send the pin value
	CyU3PUsbSendEP0Data (5, (uint8_t *)USBBuffer);
	//Send a packet terminate
	CyU3PUsbSendEP0Data (0, NULL);
	return status;
}

/*
 * Function: AdiReadTimerValue()
 *
 * This function handles Timer read control endpoint requests. It reads the current value from the
 * complex GPIO timer and then sends the value over the control endpoint.
 *
 * Returns: The success of the timer read operation
 */
CyU3PReturnStatus_t AdiReadTimerValue()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t timerValue;
	status = CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &timerValue);
	if(status != CY_U3P_SUCCESS)
	{
		return status;
	}
	USBBuffer[0] = timerValue & 0xFF;
	USBBuffer[1] = (timerValue & 0xFF00) >> 8;
	USBBuffer[2] = (timerValue & 0xFF0000) >> 16;
	USBBuffer[3] = (timerValue & 0xFF000000) >> 24;
	status = CyU3PUsbSendEP0Data (4, USBBuffer);
	return status;
}

/*
 * Function: AdiRealTimeStreamStart()
 *
 * This function kicks off a real-time stream by configuring interrupts, SPI, and end points.
 * It also optionally toggles the SYNC/RTS pin if requested. At the end of the function, the
 * bit assigned to enable the capture thread is toggled to signal the streaming thread to start producing data.
 *
 * Returns: The status of starting a real-time stream.
 */
CyU3PReturnStatus_t AdiRealTimeStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;
	uint8_t tempWriteBuffer[2];
	uint8_t tempReadBuffer[2];

	//Make sure the BUSY pin is configured as input (DIO2)
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyFalse;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	CyU3PGpioSetSimpleConfig(DrPin, &gpioConfig);

	//Disable GPIO ISR
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	//Disable VBUS ISR
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	//Get number of frames to capture from control endpoint
	CyU3PUsbGetEP0Data(5, USBBuffer, &bytesRead);
	numRealTimeCaptures = USBBuffer[0];
	numRealTimeCaptures += (USBBuffer[1] << 8);
	numRealTimeCaptures += (USBBuffer[2] << 16);
	numRealTimeCaptures += (USBBuffer[3] << 24);

	//Get pin start setting
	pinStartEnableDisable = (CyBool_t) USBBuffer[4];

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	/* Configure RTS channel DMA */
    CyU3PDmaChannelConfig_t dmaConfig;
    dmaConfig.size 				= usbBufferSize;
    dmaConfig.count 			= 256;
    dmaConfig.prodSckId 		= CY_U3P_LPP_SOCKET_SPI_PROD;
    dmaConfig.consSckId 		= CY_U3P_UIB_SOCKET_CONS_1;
    dmaConfig.dmaMode 			= CY_U3P_DMA_MODE_BYTE;
    dmaConfig.prodHeader    	= 0;
    dmaConfig.prodFooter    	= 0;
    dmaConfig.consHeader    	= 0;
    dmaConfig.notification  	= 0;
    dmaConfig.cb            	= NULL;
    dmaConfig.prodAvailCount	= 0;

    /* Configure DMA for RealTimeStreamingChannel */
    status = CyU3PDmaChannelCreate(&StreamingChannel, CY_U3P_DMA_TYPE_AUTO, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the RTS DMA failed, Error Code = %d\n", status);
		return status;
	}

	//Clear the DMA buffers
	CyU3PDmaChannelReset(&StreamingChannel);

	if(pinExitEnableDisable)
	{
		//Disable starting the capture by raising SYNC/RTS
		//If this is not done before setting SYNC/RTS high, things will break

		//If pin start is disabled (we're starting the capture with GLOB_CMD)
		if(!pinStartEnableDisable)
		{
			//Read MSC_CTRL register
			tempReadBuffer[0] = (0x64);
			tempReadBuffer[1] = (0x00);
			status = CyU3PSpiTransmitWords(tempReadBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
						return status;
			}
			AdiSleepForMicroSeconds(stallTime);
			status = CyU3PSpiReceiveWords(tempReadBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiSleepForMicroSeconds(stallTime);

			//Clear bit 12 (bit enables/disables starting a capture using SYNC pin)
			tempReadBuffer[0] = tempReadBuffer[0] & (0xEF);

			//Write modified buffer to MSC_CTRL
			tempWriteBuffer[0] = (0x80) | (0x64);
			tempWriteBuffer[1] = tempReadBuffer[1];
			status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiSleepForMicroSeconds(stallTime);
			tempWriteBuffer[0] = (0x80) | (0x65);
			tempWriteBuffer[1] = tempReadBuffer[0];
			status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
			if (status != CY_U3P_SUCCESS)
			{
				return status;
			}
			AdiSleepForMicroSeconds(stallTime);

			//Configure SYNC/RTS as an output and set high
			CyU3PGpioSimpleConfig_t gpioConfig;
			gpioConfig.outValue = CyTrue;
			gpioConfig.inputEn = CyFalse;
			gpioConfig.driveLowEn = CyTrue;
			gpioConfig.driveHighEn = CyTrue;
			gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
			status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

			//If config fails try to override and reconfigure
			if(status != CY_U3P_SUCCESS)
			{
				status = CyU3PDeviceGpioOverride (busyPin, CyTrue);
				status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);
			}

			//Check that the pin is configured to act as an output, return if not
			status = CyU3PGpioSimpleSetValue(busyPin, CyTrue);
			if(status != CY_U3P_SUCCESS)
			{
				return status;
			}
		}
	}

	//If pin start is enabled, set bit 12 in MISC_CTRL and toggle SYNC, otherwise send 0x0800 to COMMAND
	if(pinStartEnableDisable)
	{
		//Read MSC_CTRL register
		tempReadBuffer[0] = (0x64);
		tempReadBuffer[1] = (0x00);
		status = CyU3PSpiTransmitWords(tempReadBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
					return status;
		}
		AdiSleepForMicroSeconds(stallTime);
		status = CyU3PSpiReceiveWords(tempReadBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiSleepForMicroSeconds(stallTime);

		//Set bit 12 (bit enables/disables starting a capture using SYNC pin)
		tempReadBuffer[0] = tempReadBuffer[0] | (0x10);

		//Write modified buffer to MSC_CTRL
		tempWriteBuffer[0] = (0x80) | (0x64);
		tempWriteBuffer[1] = tempReadBuffer[1];
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiSleepForMicroSeconds(stallTime);
		tempWriteBuffer[0] = (0x80) | (0x65);
		tempWriteBuffer[1] = tempReadBuffer[0];
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiSleepForMicroSeconds(stallTime);

		//Configure SYNC/RTS as an output and set high
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyTrue;
		gpioConfig.inputEn = CyFalse;
		gpioConfig.driveLowEn = CyTrue;
		gpioConfig.driveHighEn = CyTrue;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

		//If config fails try to override and reconfigure
		if(status != CY_U3P_SUCCESS)
		{
			status = CyU3PDeviceGpioOverride (busyPin, CyTrue);
			status = CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);
		}

		//Check that the pin is configured to act as an output, return if not
		status = CyU3PGpioSimpleSetValue(busyPin, CyTrue);
		if(status != CY_U3P_SUCCESS)
		{
			return status;
		}
	}
	else
	{
		//Send COMMAND 0x800
		//Command is Page 0, Address 62
		tempWriteBuffer[0] = (0x80) | (0x3E);
		tempWriteBuffer[1] = 0;
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiSleepForMicroSeconds(stallTime);
		tempWriteBuffer[0] = (0x80) | (0x3F);
		tempWriteBuffer[1] = 0x08;
		status = CyU3PSpiTransmitWords(tempWriteBuffer, 2);
		if (status != CY_U3P_SUCCESS)
		{
			return status;
		}
		AdiSleepForMicroSeconds(stallTime);
	}

	//Manually reset SPI Rx/Tx FIFO
	AdiSpiResetFifo(CyTrue, CyTrue);

	//Set the SPI config for streaming mode
	//spiConfig.ssnCtrl = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
	//spiConfig.wordLen = 8;
	//CyU3PSpiSetConfig (&spiConfig, NULL);

	//Set infinite DMA transfer on streaming channel
	CyU3PDmaChannelSetXfer(&StreamingChannel, 0);

	//Set the real-time data capture thread flag
	CyU3PEventSet (&eventHandler, ADI_REAL_TIME_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;

}


/*
 * Function: AdiRealTimeStreamFinished()
 *
 * This function cleans up after a real-time stream by resetting the SPI port, triggering the SYNC/RTS pin (if asked to do so),
 * and notifying the host that the cancel operation was successful.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiRealTimeStreamFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	//CyU3PThreadPriorityChange(&streamingThread, 8, threadPriority);

	//Pull SYNC/RTS pin low to force x021 out of RT mode
	if(pinExitEnableDisable || pinStartEnableDisable)
	{
		//Configure SYNC/RTS as an output and set high
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyFalse;
		gpioConfig.driveLowEn = CyTrue;
		gpioConfig.driveHighEn = CyTrue;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

		//Reset flag for next run
		pinExitEnableDisable = CyFalse;
	}

	//Stop pin output drive and enable as input
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	CyU3PGpioSetSimpleConfig(busyPin, &gpioConfig);

	//Disable SPI DMA mode
	CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);

	//Reset the SPI controller
	SPI->lpp_spi_config &= ~(CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_ENABLE);
	while ((SPI->lpp_spi_config & CY_U3P_LPP_SPI_ENABLE) != 0);

    /* Tear down the RT streaming channel */
    status = CyU3PDmaChannelDestroy(&StreamingChannel);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Tearing down the RTS DMA failed, Error Code = %d\n", status);
		return status;
	}

	//Flush streaming end point
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	//Clear all interrupt flags
	CyU3PVicClearInt();

	//Re-enable relevant ISRs
	CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	CyU3PVicEnableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	//Additional clean-up after a user requests an early cancellation
	if(killEarly)
	{
		//Send status back over control endpoint to end USB transaction and signal cancel was completed successfully
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		//Reset killEarly flag in case the user wants to capture data again
		killEarly = CyFalse;
	}

	return status;
}


/*
 * Function: AdiBurstStreamStart()
 *
 * This function kicks off a burst stream by configuring a pin interrupt on a user-specified pin, configuring
 * the SPI and USB DMAs to handle the incoming data, and enabling the streaming function.
 * It can be configured for "Blackfin" or "ADuC" burst using vendor requests.
 *
 * Returns: The status of starting a real-time stream.
 */
CyU3PReturnStatus_t AdiBurstStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;

	/* Disable VBUS ISR */
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	/* Disable GPIO interrupt before attaching interrupt to pin */
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	/* Make sure the global data ready pin is configured as an input and attach the interrupt to the correct edge */
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	if (DrPolarity)
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	}
	else
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_NEG_EDGE;
	}
	status = CyU3PGpioSetSimpleConfig(DrPin, &gpioConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting burst stream pin interrupt failed!, error code = %d\r\n", status);
		AdiAppErrorHandler(status);
	}

	/* Get the number of buffers, trigger word, and transfer length from the control endpoint */
	CyU3PUsbGetEP0Data(8, USBBuffer, &bytesRead);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Failed to get EP0 data!, error code = %d\r\n", status);
		AdiAppErrorHandler(status);
	}
	numBuffers = USBBuffer[0];
	numBuffers += (USBBuffer[1] << 8);
	numBuffers += (USBBuffer[2] << 16);
	numBuffers += (USBBuffer[3] << 24);

	/* Get number of words to capture per transfer (minus the trigger word) */
	transferWordLength = USBBuffer[6];
	transferWordLength += (USBBuffer[7] << 8);

	/* Calculate the total number of bytes to transfer and add the trigger word */
	/* We're going to overwrite the first two bytes with the trigger word, so make the burst length 2 bytes larger */
	transferByteLength = (transferWordLength * 2) + 2;

	/* Set regList memory to correct length plus trigger word */
	regList = CyU3PDmaBufferAlloc(sizeof(uint8_t) * transferByteLength);

	/* Clear (zero) contents of regList memory. Burst transfers are DNC, so we're sending zeros */
	CyU3PMemSet(regList, 0, sizeof(uint8_t) * transferByteLength);

	/* Append burst trigger word to the first two bytes of regList */
	regList[0] = USBBuffer[4];
	regList[1] = USBBuffer[5];

	/* Calculate the required memory block (in bytes) to be a multiple of 16 */
	uint16_t remainder = transferByteLength % 16;
	if (remainder == 0)
	{
		roundedByteTransferLength = transferByteLength;
	}
	else
	{
		roundedByteTransferLength = transferByteLength + 16 - remainder;
	}

	 /*Debugging print statements
	 CyU3PDebugPrint (4, "burstTriggerUpper:  %d\r\n", regList[0]);
	 CyU3PDebugPrint (4, "burstTriggerLower:  %d\r\n", regList[1]);
	 CyU3PDebugPrint (4, "roundedTransferLength:  %d\r\n", roundedByteTransferLength);
	 CyU3PDebugPrint (4, "transferByteLength:  %d\r\n", transferByteLength);
	 CyU3PDebugPrint (4, "transferWordLength:  %d\r\n", transferWordLength);
	 CyU3PDebugPrint (4, "numBuffers:  %d\r\n", numBuffers); */

	/* Configure the Burst DMA Streaming Channel (SPI to PC) for Auto DMA */
	CyU3PDmaChannelConfig_t dmaConfig;
	CyU3PMemSet ((uint8_t *)&dmaConfig, 0, sizeof(dmaConfig));
	dmaConfig.size 				= usbBufferSize;
	dmaConfig.count 			= 256;
	dmaConfig.prodSckId 		= CY_U3P_LPP_SOCKET_SPI_PROD;
	dmaConfig.consSckId 		= CY_U3P_UIB_SOCKET_CONS_1;
	dmaConfig.dmaMode 			= CY_U3P_DMA_MODE_BYTE;
	dmaConfig.prodHeader    	= 0;
	dmaConfig.prodFooter    	= 0;
	dmaConfig.consHeader    	= 0;
	dmaConfig.notification  	= 0;
	dmaConfig.cb            	= NULL;
	dmaConfig.prodAvailCount	= 0;

	status = CyU3PDmaChannelCreate(&StreamingChannel, CY_U3P_DMA_TYPE_AUTO, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the Burst Stream DMA failed, Error Code = %d\n", status);
		AdiAppErrorHandler(status);
	}

	/* Configure SPI TX DMA (CPU memory to SPI for burst mode)
	 * Transfer length must equal length of message to be sent
	 * Count not required since the DMA will be run in override mode */
	CyU3PMemSet ((uint8_t *)&dmaConfig, 0, sizeof(dmaConfig));
    dmaConfig.size 				= roundedByteTransferLength;
    dmaConfig.count 			= 0;
    dmaConfig.prodSckId 		= CY_U3P_CPU_SOCKET_PROD;
    dmaConfig.consSckId 		= CY_U3P_LPP_SOCKET_SPI_CONS;
    dmaConfig.dmaMode 			= CY_U3P_DMA_MODE_BYTE;
    dmaConfig.prodHeader     	= 0;
    dmaConfig.prodFooter     	= 0;
    dmaConfig.consHeader     	= 0;
    dmaConfig.notification   	= 0;
    dmaConfig.cb             	= NULL;
    dmaConfig.prodAvailCount 	= 0;

    status = CyU3PDmaChannelCreate(&MemoryToSPI, CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the SPI TX DMA failed, Error Code = %d\r\n", status);
		AdiAppErrorHandler(status);
	}

	/* Flush the streaming endpoint */
	status = CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Flushing the ADI_STREAMING_ENDPOINT failed, Error Code = %d\r\n", status);
		AdiAppErrorHandler(status);
	}

	/* Manually reset the SPI Rx/Tx FIFO */
	AdiSpiResetFifo(CyTrue, CyTrue);

	/* Set the SPI config for streaming mode */
	spiConfig.ssnCtrl = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
	spiConfig.wordLen = 8;
	status = CyU3PSpiSetConfig(&spiConfig, NULL);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting SPI config for burst stream mode failed, Error Code = %d\n", status);
		AdiAppErrorHandler(status);
	}

	/* Configure SpiDmaBuffer and feed it regList*/
	CyU3PMemSet ((uint8_t *)&SpiDmaBuffer, 0, sizeof(SpiDmaBuffer));
	SpiDmaBuffer.count = transferByteLength;
	SpiDmaBuffer.size = roundedByteTransferLength;
	SpiDmaBuffer.buffer = regList;
	SpiDmaBuffer.status = 0;

	/* Enable an infinite DMA transfer on the streaming channel */
	status = CyU3PDmaChannelSetXfer(&StreamingChannel, 0);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting CyU3PDmaChannelSetXfer failed, Error Code = %d\n", status);
		AdiAppErrorHandler(status);
	}

	/* Set the burst stream flag to notify the streaming thread it should take over */
	CyU3PEventSet (&eventHandler, ADI_BURST_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;
}

/*
 * Function: AdiBurstStreamFinished()
 *
 * This function cleans up after a burst stream by resetting the SPI port and notifying the host
 * that the cancel operation was successful.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiBurstStreamFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	/* Reset the SPI controller */
	SPI->lpp_spi_config &= ~(CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_ENABLE);
	while ((SPI->lpp_spi_config & CY_U3P_LPP_SPI_ENABLE) != 0);

	/* Remove the interrupt from the global data ready pin */
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	CyU3PGpioSetSimpleConfig(DrPin, &gpioConfig);

	/* Destroy MemoryToSpi DMA channel */
    status = CyU3PDmaChannelDestroy(&MemoryToSPI);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Destroying the SPI TX DMA failed, Error Code = %d\r\n", status);
		return status;
	}

    /* Destroy the burst DMA channel (and recover a LOT of memory) */
    status = CyU3PDmaChannelDestroy(&StreamingChannel);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Tearing down the Streaming DMA channel failed, Error Code = %d\n", status);
		return status;
	}

	/* Flush the streaming end point */
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	/* Clear all interrupt flags */
	CyU3PVicClearInt();

	/* Re-enable relevant ISRs */
	CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	CyU3PVicEnableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	/* Additional clean-up after a user requests an early cancellation */
	if(killEarly)
	{
		/* Send status back over control endpoint to end USB transaction and signal cancel was completed successfully */
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		/* Reset killEarly flag in case the user wants to capture data again */
		killEarly = CyFalse;
	}

	return status;
}


/*
 * Function: AdiGenericStreamStart()
 *
 * This function kicks off a generic data stream by configuring interrupts, SPI, and end points.
 * At the end of the function, the ADI_GENERIC_STREAM_ENABLE flag is set such that the
 * generic streaming thread knows to start producing data.
 *
 * Returns: The status of starting a generic stream.
 */
CyU3PReturnStatus_t AdiGenericStreamStart()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t bytesRead;

	/* Get the data from the control endpoint */
	status = CyU3PUsbGetEP0Data(transferByteLength, USBBuffer, &bytesRead);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Failed to read configuration data from control endpoint!, error code = %d\r\n", status);
	}

	/* Disable VBUS ISR */
	CyU3PVicDisableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	/* Disable GPIO interrupt before attaching interrupt to pin */
	CyU3PVicDisableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);

	/* Make sure the data ready pin is configured as an input and attach the correct pin interrupt */
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	if (DrPolarity)
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_POS_EDGE;
	}
	else
	{
		gpioConfig.intrMode = CY_U3P_GPIO_INTR_NEG_EDGE;
	}

	status = CyU3PGpioSetSimpleConfig(DrPin, &gpioConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Setting burst stream pin interrupt failed!, error code = %d\r\n", status);
	}

	/* Get the number of buffers (number of times to read each set of registers) */
	numBuffers = USBBuffer[0];
	numBuffers += (USBBuffer[1] << 8);
	numBuffers += (USBBuffer[2] << 16);
	numBuffers += (USBBuffer[3] << 24);

	/* Get the number of captures of the address list (number of times to capture the list of registers per buffer) */
	numCaptures = USBBuffer[4];
	numCaptures += (USBBuffer[5] << 8);
	numCaptures += (USBBuffer[6] << 16);
	numCaptures += (USBBuffer[7] << 24);

	/* Calculate the number of bytes per buffer */
	/* Number of times to read each set of registers * (number of registers - control registers) */
	bytesPerBuffer = numCaptures * (transferByteLength - 8);

	/* Set regList memory ((transferByteLength - (number of config bytes) * numCaptures) + trigger word) */
	regList = CyU3PMemAlloc(sizeof(uint8_t) * (((transferByteLength - 8) * numCaptures) + 2));

	/* Clear (zero) contents of regList memory */
	CyU3PMemSet(regList, 0, sizeof(uint8_t) * (((transferByteLength - 8) * numCaptures) + 2));

	/* Write register list values to regList */
	uint16_t i, j;
	for (i = 0; i < numCaptures; i++)
	{
		for(j = 0; j < (transferByteLength - 8); j++)
		{
			regList[(i * (transferByteLength - 8)) + j] = USBBuffer[j + 8];
		}
	}

	//Find number of register "buffers" which fit in a USB buffer
	if(bytesPerBuffer > usbBufferSize)
	{
		bytesPerUsbPacket = usbBufferSize;
	}
	else
	{
		bytesPerUsbPacket = ((usbBufferSize / bytesPerBuffer) * bytesPerBuffer);
	}

	/* Flush the streaming endpoint */
	status = CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Flushing the ADI_STREAMING_ENDPOINT failed, Error Code = %d\r\n", status);
		AdiAppErrorHandler(status);
	}

	/* Configure the StreamingChannel DMA (SPI to PC) */
	CyU3PDmaChannelConfig_t dmaConfig;
	CyU3PMemSet ((uint8_t *)&dmaConfig, 0, sizeof(dmaConfig));
	dmaConfig.size 				= usbBufferSize;
	dmaConfig.count 			= 4;
	dmaConfig.prodSckId 		= CY_U3P_CPU_SOCKET_PROD;
	dmaConfig.consSckId 		= CY_U3P_UIB_SOCKET_CONS_1;
	dmaConfig.dmaMode 			= CY_U3P_DMA_MODE_BYTE;
	dmaConfig.prodHeader    	= 0;
	dmaConfig.prodFooter    	= 0;
	dmaConfig.consHeader    	= 0;
	dmaConfig.notification  	= 0;
	dmaConfig.cb            	= NULL;
	dmaConfig.prodAvailCount	= 0;

	status = CyU3PDmaChannelCreate(&StreamingChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaConfig);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Configuring the StreamingChannel DMA for generic stream failed, Error Code = %d\n", status);
		AdiAppErrorHandler(status);
	}

	/* Set DMA transfer mode */
	status = CyU3PDmaChannelSetXfer(&StreamingChannel, 0);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error Code = %d\n", status);
		return status;
	}

	//Enable timer interrupts
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= (~CY_U3P_LPP_GPIO_INTRMODE_MASK);
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status |= CY_U3P_GPIO_INTR_TIMER_THRES << CY_U3P_LPP_GPIO_INTRMODE_POS;

	//Set the timer pin threshold to correspond with the stall time
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold = (stallTime * 10) - ADI_GENERIC_STALL_OFFSET;
	//Set the timer pin period (useful for error case, timer register is manually reset)
	GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = (stallTime * 10) - ADI_GENERIC_STALL_OFFSET + 1;

	//Enable generic data capture thread
	status = CyU3PEventSet (&eventHandler, ADI_GENERIC_STREAM_ENABLE, CYU3P_EVENT_OR);

	return status;

}

/*
 * Function: AdiGenericStreamFinished()
 *
 * This function cleans up after a generic stream and notifies the host that the cancel operation was successful if requested.
 *
 * Returns: The status of the cancel operation.
 *
 */
CyU3PReturnStatus_t AdiGenericStreamFinished()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	/* Remove the interrupt from the global data ready pin */
	CyU3PGpioSimpleConfig_t gpioConfig;
	gpioConfig.outValue = CyTrue;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	CyU3PGpioSetSimpleConfig(DrPin, &gpioConfig);

    /* Destroy the StreamingChannel channel (and recover a LOT of memory) */
    status = CyU3PDmaChannelDestroy(&StreamingChannel);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Tearing down the Streaming DMA channel failed, Error Code = %d\n", status);
	}

	/* Flush the streaming end point */
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);

	/* Clear all interrupt flags */
	CyU3PVicClearInt();

	/* Re-enable relevant ISRs */
	CyU3PVicEnableInt(CY_U3P_VIC_GPIO_CORE_VECTOR);
	CyU3PVicEnableInt(CY_U3P_VIC_GCTL_PWR_VECTOR);

	/* Additional clean-up after a user requests an early cancellation */
	if(killEarly)
	{
		/* Send status back over control endpoint to end USB transaction and signal cancel was completed successfully */
		USBBuffer[0] = status & 0xFF;
		USBBuffer[1] = (status & 0xFF00) >> 8;
		USBBuffer[2] = (status & 0xFF0000) >> 16;
		USBBuffer[3] = (status & 0xFF000000) >> 24;
		CyU3PUsbSendEP0Data (4, USBBuffer);

		/* Reset killEarly flag in case the user wants to capture data again */
		killEarly = CyFalse;
	}

	return status;

}


/*
 * Function: AdiStopAnyDataStream()
 *
 * This function sets a flag to notify the streaming thread that the user requested to cancel streaming.
 * This function can be used to stop any stream operation.
 *
 * Returns: The function status code
 *
 */
CyU3PReturnStatus_t AdiStopAnyDataStream()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	killEarly = CyTrue;
	return status;
}


/*
 * Function: AdiMeasureDR()
 *
 * This function measures two data ready pulses on a user-specified pin and reports
 * back the delta-time in ticks. The function also transmits the tick scale factor
 * and a timeout counter to notify the interface of timeouts that may have occurred
 * due to missing pulses. Data is transmitted over USB via the bulk endpoint. Inputs
 * are provided through the control endpoint. This function can be expanded to capture
 * as many samples as required.
 *
 * pin: The GPIO pin number to measure
 *
 * polarity: The polarity of the pin (1 - Low-to-High, 0 - High-to-Low)
 *
 * timeoutInMs: The specified timeout in milliseconds
 *
 * Returns: The status of the pin drive operation
 */
CyU3PReturnStatus_t AdiMeasureDR()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint16_t pin;
	CyBool_t polarity, validPin, pinValue, sampleRollover;
	uint32_t timeWaited[2];
	uint32_t timeoutCounter = 0;
	uint32_t pinRegValue, startTime, currentTime, sampleEndTime, timeout, deltat;

	//Get the operation start time
	CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &startTime);
	currentTime = startTime;

	//Parse request data from USBBuffer
	pin = USBBuffer[0];
	pin = pin + (USBBuffer[1] << 8);
	polarity = (CyBool_t) USBBuffer[2];
	timeout = USBBuffer[7];
	timeout = timeout + (USBBuffer[8] << 8);
	timeout = timeout + (USBBuffer[9] << 16);
	timeout = timeout + (USBBuffer[10] << 24);

	//Convert from ms to timer ticks
	timeout = AdiMStoTicks(timeout);

	//Calculate if timer rollover is going to occur for sample period
	sampleRollover = (timeout > 0 && (startTime > (0xFFFFFFFF - timeout)));

	//Calculate the sample period end time
	if(sampleRollover)
	{
		sampleEndTime = timeout - (0xFFFFFFFF - startTime);
	}
	else
	{
		sampleEndTime = timeout + startTime;
	}

	//Check that input pin specified is configured as input
	status = CyU3PGpioSimpleGetValue(pin, &pinValue);
	if(status != CY_U3P_SUCCESS)
	{
		//If initial pin read fails try and configure as input
		CyU3PGpioSimpleConfig_t gpioConfig;
		gpioConfig.outValue = CyFalse;
		gpioConfig.inputEn = CyTrue;
		gpioConfig.driveLowEn = CyFalse;
		gpioConfig.driveHighEn = CyFalse;
		gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;
		status = CyU3PGpioSetSimpleConfig(pin, &gpioConfig);

		//get the pin value again after configuring
		status = CyU3PGpioSimpleGetValue(pin, &pinValue);

		//If pin setup not successful skip wait operation and return -1
		if(status != CY_U3P_SUCCESS)
		{
			validPin = CyFalse;
		}
	}
	else
	{
	validPin = CyTrue;
	}

	//If the pin is properly configured
	if(validPin)
	{
		//Loop through samples
		for(uint32_t i = 0; i <= 2; i++)
		{
			//Poll the input pin until a transition is detected or the timer runs out
			if(timeout)
			{
				//If the timeout will roll over
				if(sampleRollover)
				{
					//Low to high transition
					if(polarity == 1)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts high wait for low transition
						if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && (currentTime >= startTime || currentTime <= sampleEndTime))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime <= startTime || currentTime >= sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a low to high transition
						while((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime <= startTime || currentTime >= sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
					//Default / high to low transition
					else
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts low wait for high transition
						if((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime <= startTime || currentTime >= sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a high to low transition
						while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && (currentTime >= startTime || currentTime <= sampleEndTime))
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime <= startTime || currentTime >= sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
				}
				else
				{
					//Low to high transition
					if(polarity == 1)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts high wait for low transition
						if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && currentTime < sampleEndTime)
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime > sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a low to high transition
						while((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && currentTime < sampleEndTime)
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime > sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
					//Default / high to low transition
					else
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
						//If pin starts low wait for high transition
						if((!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)) && currentTime < sampleEndTime)
						{
							while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
							{
								CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
								pinRegValue = GPIO->lpp_gpio_simple[pin];
								//Increment timeout counter if a timeout occurs
								if(currentTime > sampleEndTime)
								{
									timeoutCounter++;
								}
							}
						}
						//Wait for a high to low transition
						while((pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE) && currentTime < sampleEndTime)
						{
							CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
							pinRegValue = GPIO->lpp_gpio_simple[pin];
							//Increment timeout counter if a timeout occurs
							if(currentTime > sampleEndTime)
							{
								timeoutCounter++;
							}
						}
					}
				}
			}
			//If timeout is 0 treat it like there is no timeout
			else
			{
				//Low to high transition
				if(polarity == 1)
				{
					pinRegValue = GPIO->lpp_gpio_simple[pin];
					//If pin starts high wait for low transition
					if(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
					{
						while(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
						{
							pinRegValue = GPIO->lpp_gpio_simple[pin];
						}
					}
					//Wait for a low to high transition
					while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
					}
				}
				//Default / high to low transition
				else
				{
					pinRegValue = GPIO->lpp_gpio_simple[pin];
					//If pin starts low wait for high transition
					if(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
					{
						while(!(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE))
						{
							pinRegValue = GPIO->lpp_gpio_simple[pin];
						}
					}
					//Wait for a high to low transition
					while(pinRegValue & CY_U3P_LPP_GPIO_IN_VALUE)
					{
						pinRegValue = GPIO->lpp_gpio_simple[pin];
					}
				}
			}
			//Calculate the time waited
			CyU3PGpioComplexSampleNow(ADI_TIMER_PIN, &currentTime);
			if (currentTime > startTime)
			{
				timeWaited[i] = currentTime - startTime;
			}
			else
			{
				timeWaited[i] = currentTime + (0xFFFFFFFF - startTime);
			}
		}
		//Calculate delta time
		deltat = timeWaited[1] - timeWaited[0];
	}
	else
	{
		//Set the wait time to max when invalid pin is specified
		deltat = 0xFFFFFFFF;
	}
	//Return delta time over ChannelToPC
	//TODO: Stop sending MS_TO_TICKS_MULT since it's already
	//      part of the SPI config message
	BulkBuffer[0] = deltat & 0xFF;
	BulkBuffer[1] = (deltat & 0xFF00) >> 8;
	BulkBuffer[2] = (deltat & 0xFF0000) >> 16;
	BulkBuffer[3] = (deltat & 0xFF000000) >> 24;
	BulkBuffer[4] = MS_TO_TICKS_MULT & 0xFF;
	BulkBuffer[5] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	BulkBuffer[6] = (MS_TO_TICKS_MULT & 0xFF00) >> 16;
	BulkBuffer[7] = (MS_TO_TICKS_MULT & 0xFF00) >> 24;
	BulkBuffer[8] = timeoutCounter;

	ManualDMABuffer.buffer = BulkBuffer;
	ManualDMABuffer.size = sizeof(BulkBuffer);
	ManualDMABuffer.count = 9;

	//Send the data to PC
	status = CyU3PDmaChannelSetupSendBuffer(&ChannelToPC, &ManualDMABuffer);
	if(status != CY_U3P_SUCCESS)
	{
		CyU3PDebugPrint (4, "Sending DR data to PC failed!, error code = %d\r\n", status);
	}

	return status;
}

/*
 * FunctionL AdiSpiResetFifo(CyBool_t isTx, CyBool_t isRx)
 *
 * This function resets the SPI FIFO and disables the SPI block after completion.
 * It is a copy of the private CyU3PSpiResetFifo() function required due to our
 * high-speed, register-initiated transfers.
 *
 * Returns: The success of the SPI reset FIFO operation
 */
CyU3PReturnStatus_t AdiSpiResetFifo(CyBool_t isTx, CyBool_t isRx)
{
	uint32_t intrMask;
	uint32_t ctrlMask = 0;
	uint32_t temp;

	/* No lock is acquired or error checked */

	/* Temporarily disable interrupts. */
	intrMask = SPI->lpp_spi_intr_mask;
	SPI->lpp_spi_intr_mask = 0;

	if (isTx)
	{
		ctrlMask = CY_U3P_LPP_SPI_TX_CLEAR;
	}
	if (isRx)
	{
		ctrlMask |= CY_U3P_LPP_SPI_RX_CLEAR;
	}

	/* Disable the SPI block and reset. */
	temp = ~(CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE |
		CY_U3P_LPP_SPI_DMA_MODE | CY_U3P_LPP_SPI_ENABLE);
	SPI->lpp_spi_config &= temp;
	while ((SPI->lpp_spi_config & CY_U3P_LPP_SPI_ENABLE) != 0);

	/* Clear the FIFOs and wait until they have been cleared. */
	SPI->lpp_spi_config |= ctrlMask;
	if (isTx)
	{
		while ((SPI->lpp_spi_status & CY_U3P_LPP_SPI_TX_DONE) == 0);
	}
	if (isRx)
	{
		while ((SPI->lpp_spi_status & CY_U3P_LPP_SPI_RX_DATA) != 0);
	}
	SPI->lpp_spi_config &= ~ctrlMask;

	/* Clear all interrupts and re-enable them. */
	SPI->lpp_spi_intr |= CY_U3P_LPP_SPI_TX_DONE;
	SPI->lpp_spi_intr_mask = intrMask;

	return CY_U3P_SUCCESS;
}

/*
 * Function: AdiGetSpiSettings()
 *
 * This function handles vendor commands to get the current SPI configuration from the FX3
 *
 * Returns: if the transaction was successful
 */
CyU3PReturnStatus_t AdiGetSpiSettings()
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint8_t USBBuffer[23];
	//Clock first
	USBBuffer[0] = spiConfig.clock & 0xFF;
	USBBuffer[1] = (spiConfig.clock & 0xFF00) >> 8;
	USBBuffer[2] = (spiConfig.clock & 0xFF0000) >> 16;
	USBBuffer[3] = (spiConfig.clock & 0xFF000000) >> 24;
	USBBuffer[4] = spiConfig.cpha;
	USBBuffer[5] = spiConfig.cpol;
	USBBuffer[6] = spiConfig.isLsbFirst;
	USBBuffer[7] = spiConfig.lagTime;
	USBBuffer[8] = spiConfig.leadTime;
	USBBuffer[9] = spiConfig.ssnCtrl;
	USBBuffer[10] = spiConfig.ssnPol;
	USBBuffer[11] = spiConfig.wordLen;
	USBBuffer[12] = stallTime & 0xFF;
	USBBuffer[13] = (stallTime & 0xFF00) >> 8;
	USBBuffer[14] = DUTType;
	USBBuffer[15] = (CyBool_t)DrActive;
	USBBuffer[16] = (CyBool_t)DrPolarity;
	USBBuffer[17] = DrPin & 0xFF;
	USBBuffer[18] = (DrPin & 0xFF00) >> 8;
	USBBuffer[19] = MS_TO_TICKS_MULT & 0xFF;
	USBBuffer[20] = (MS_TO_TICKS_MULT & 0xFF00) >> 8;
	USBBuffer[21] = (MS_TO_TICKS_MULT & 0xFF0000) >> 16;
	USBBuffer[22] = (MS_TO_TICKS_MULT & 0xFF000000) >> 24;
	status = CyU3PUsbSendEP0Data (23, USBBuffer);
	return status;
}

/*
 * Function: AdiSpiUpdate(uint16_t index, uint16_t value, uint16_t length)
 *
 * This function handles a vendor command request to update the SPI configuration
 *
 * index: The wIndex from the control endpoint transaction which indicates which parameter to update
 *
 * value: The wValue from the control endpoint transaction which holds the SPI value to set
 *
 * length: The length of the Data In phase of the control endpoint transaction
 *
 * Returns: A boolean indicating if the SPI configuration was a success
 */
CyBool_t AdiSpiUpdate(uint16_t index, uint16_t value, uint16_t length)
{
    uint32_t clockFrequency;
    uint16_t *bytesRead = 0;
	CyBool_t isHandled = CyTrue;
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyU3PUsbGetEP0Data(length, USBBuffer, bytesRead);
	switch(index)
	{
	case 0:
		//Clock setting
		if(length != 4)
		{
			//Reasonable Default if data frame isn't set properly
			spiConfig.clock = 2000000;
		}
		else
		{
			clockFrequency = USBBuffer[3];
			clockFrequency += USBBuffer[2] << 8;
			clockFrequency += USBBuffer[1] << 16;
			clockFrequency += USBBuffer[0] << 24;
			spiConfig.clock = clockFrequency;
			status = CyU3PSpiSetConfig (&spiConfig, NULL);
			//CyU3PDebugPrint (4, "SCLK = %d\r\n", clockFrequency);
		}
		break;

	case 1:
		//cpol
		spiConfig.cpol = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "cpol = %d\r\n", value);
		break;

	case 2:
		//cpha
		spiConfig.cpha = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "cpha = %d\r\n", value);
		break;

	case 3:
		//Chip Select Polarity
		spiConfig.ssnPol = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "ssnPol = %d\r\n", value);
		break;

	case 4:
		//Chip Select Control
		spiConfig.ssnCtrl = (CyU3PSpiSsnCtrl_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "ssnCtrl = %d\r\n", value);
		break;

	case 5:
		//Lead Time
		spiConfig.leadTime = (CyU3PSpiSsnLagLead_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "leadTime = %d\r\n", value);
		break;

	case 6:
		//Lag Time
		spiConfig.lagTime = (CyU3PSpiSsnLagLead_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "lagTime = %d\r\n", value);
		break;

	case 7:
		//Is LSB First
		spiConfig.isLsbFirst = (CyBool_t) value;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "isLsbFirst = %d\r\n", value);
		break;

	case 8:
		//Word Length
		spiConfig.wordLen = value & 0xFF;
		status = CyU3PSpiSetConfig (&spiConfig, NULL);
		//CyU3PDebugPrint (4, "wordLen = %d\r\n", value);
		break;

	case 9:
		//Stall time in ticks (received in ticks from the PC, each tick = 1us)
		stallTime = value;
		//CyU3PDebugPrint (4, "stallTime = %d\r\n", value);
		break;

	case 10:
		//DUT type
		DUTType = value;
		switch(DUTType)
		{
		case ADcmXL3021:
			bytesPerFrame = 200; /* (32 word x 3 axis) + 4 word status/counter/etc */
			break;
		case ADcmXL2021:
			bytesPerFrame = 152; /* (32 word x 2 axis) + 8 word padding + 4 word status/counter/etc */
			break;
		case ADcmXL1021:
			bytesPerFrame = 88; /* 32 word + 8 word padding + 4 word status/counter/etc */
			break;
		case Other:
		default:
			bytesPerFrame = 200;
			break;
		}
		//CyU3PDebugPrint (4, "bytesPerFrame = %d\r\n", bytesPerFrame);
		break;

	case 11:
		//DR polarity
		DrPolarity = (CyBool_t) value;
		//CyU3PDebugPrint (4, "DrPolarity = %d\r\n", value);
		break;

	case 12:
		//DR active
		DrActive = (CyBool_t) value;
		//CyU3PDebugPrint (4, "DrActive = %d\r\n", value);
		break;

	case 13:
		//Ready pin
		DrPin = value;
		//CyU3PDebugPrint (4, "DrPin = %d\r\n", value);
		break;

	default:
		//Invalid Command
		isHandled = CyFalse;
		CyU3PDebugPrint (4, "ERROR: Invalid SPI config command!\r\n");
		break;
	}

	//Check that the configuration was successful
	if(status != CY_U3P_SUCCESS)
	{
		isHandled = CyFalse;
	}

	return isHandled;
}



/*
 * Function: AdiBulkEndpointHandler(CyU3PUsbEpEvtType evType,CyU3PUSBSpeed_t usbSpeed, uint8_t epNum)
 *
 * This function handles events generated by the bulk endpoint
 *
 * evType: The type of the event being handled
 *
 * usbSpeed: The current connection speed
 *
 * epNum: The end point number
 *
 * Returns: void
 */
void AdiBulkEndpointHandler(CyU3PUsbEpEvtType evType, CyU3PUSBSpeed_t usbSpeed, uint8_t epNum)
{
}

/*
 * Function: AdiUSBEventHandler (CyU3PUsbEventType_t evtype, uint16_t evdata)
 *
 * This is a callback function to handle generic USB events. It calls start/stop
 * functions to manage the ADI application.
 *
 * evtype: The type of the event being handled
 *
 * evdata: The data from the event
 *
 * Returns: void
 */
void AdiUSBEventHandler (CyU3PUsbEventType_t evtype, uint16_t evdata)
{
    switch (evtype)
    {
        case CY_U3P_USB_EVENT_SETCONF:
        	/* Disable the low power entry to optimize USB throughput */
        	CyU3PUsbLPMDisable();
        	/* Stop the application before re-starting. */
        	if (appActive)
        	{
        		AdiAppStop ();
        	}
			/* Start the application */
        	AdiAppStart ();
            break;

        case CY_U3P_USB_EVENT_RESET:
        case CY_U3P_USB_EVENT_DISCONNECT:
        	/* Stop the application */
        	if (appActive)
        	{
        		AdiAppStop ();
        	}
            break;

        default:
            break;
    }
}

/*
 * Function: AdiLPMRequestHandler(CyU3PUsbLinkPowerMode link_mode)
 *
 * This is a callback function to handle LPM requests. Returns true so that
 * the USB driver stays in high power state.
 *
 * link_mode: The USB link power state that is being set
 *
 * Returns: True
 */
CyBool_t AdiLPMRequestHandler(CyU3PUsbLinkPowerMode link_mode)
{
    return CyTrue;
}

/*
 * Function: AdiGPIOEventHandler(uint8_t gpioId)
 *
 * This function handles GPIO interrupts and sets the appropriate flag in gpioHandler.
 *
 * gpioId: The pin number of the pin which generated the interrupt
 *
 * Returns: void
 */
void AdiGPIOEventHandler(uint8_t gpioId)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	CyBool_t gpioValue = CyFalse;
	status = CyU3PGpioGetValue (gpioId, &gpioValue);
    if (status == CY_U3P_SUCCESS)
    {
    	//Read the pin ID that generated the event and set the appropriate flag
    	switch(gpioId)
    	{
    		case ADI_PIN_DIO1:
    			CyU3PEventSet(&gpioHandler, ADI_PIN_DIO1, CYU3P_EVENT_OR);
    			break;

    		case ADI_PIN_DIO2:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO2, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO3:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO3, CYU3P_EVENT_OR);
				break;

    		case ADI_PIN_DIO4:
				CyU3PEventSet(&gpioHandler, ADI_PIN_DIO4, CYU3P_EVENT_OR);
				break;

    		case FX3_PIN_GPIO1:
				CyU3PEventSet(&gpioHandler, FX3_PIN_GPIO1, CYU3P_EVENT_OR);
				break;

    		case FX3_PIN_GPIO2:
				CyU3PEventSet(&gpioHandler, FX3_PIN_GPIO2, CYU3P_EVENT_OR);
				break;

    		case FX3_PIN_GPIO3:
				CyU3PEventSet(&gpioHandler, FX3_PIN_GPIO3, CYU3P_EVENT_OR);
				break;

    		case FX3_PIN_GPIO4:
				CyU3PEventSet(&gpioHandler, FX3_PIN_GPIO4, CYU3P_EVENT_OR);
				break;

    		default:
    			break;
    	}
    }
}


/*
 * Function: AdiDataStream_Entry(uint32_t input)
 *
 * This function runs in its own thread and handles real-time, burst, and generic streaming processes. Either type
 * of stream can be kicked off by executing the appropriate set-up routine and then triggering the corresponding
 * event flag.
 *
 * input: Unused input required by the thread manager
 *
 * Returns: void
 */
void AdiDataStream_Entry(uint32_t input)
{
	uint32_t eventMask = ADI_GENERIC_STREAM_ENABLE|ADI_REAL_TIME_STREAM_ENABLE|ADI_BURST_STREAM_ENABLE;
	uint8_t tempData[2];
	uint32_t numBuffersRead = 0;
	uint32_t eventFlag;

	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
	uint32_t numFramesCaptured;
	CyBool_t interruptTriggered;

	uint16_t regIndex;

	/* Generic stream local variables */
	CyU3PDmaBuffer_t genBuf_p;
	uint32_t byteCounter = 0;
	uint8_t *tempPtr;
	CyBool_t firstRun = CyTrue;

	for (;;)
	{
		//Wait indefinitely for any flag to be set
		if (CyU3PEventGet (&eventHandler, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag, CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
		{
			/* Generic register stream case */
			if (eventFlag & ADI_GENERIC_STREAM_ENABLE)
			{
				if (firstRun)
				{
					status = CyU3PDmaChannelGetBuffer (&StreamingChannel, &genBuf_p, CYU3P_WAIT_FOREVER);
					if (status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer in generic capture failed, Error code = %d\r\n", status);
					}
					tempPtr = genBuf_p.buffer;
					firstRun = CyFalse;
				}
				//Wait for DR if enabled
				if (DrActive)
				{
					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
					//Loop until interrupt is triggered
					while(!(GPIO->lpp_gpio_intr0 & (1 << DrPin)));
					//Clear GPIO interrupt bit
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
				}

				//Transmit first word without reading back
				tempData[0] = regList[0];
				tempData[1] = regList[1];
				CyU3PSpiTransmitWords(tempData, 2);

				//Set the pin timer to 0
				GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;
				//clear interrupt flag
				GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status |= CY_U3P_LPP_GPIO_INTR;

				//Read the registers in the register list into regList
				for(regIndex = 0; regIndex < (bytesPerBuffer - 1); regIndex += 2)
				{
					//Wait for the complex GPIO timer to reach the stall time
					while(!(GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_INTR));

					//Prepare, transmit, and receive SPI words
					//TODO: Adjust SPI transactions to work with variable word lengths
					tempData[0] = regList[regIndex + 2];
					tempData[1] = regList[regIndex + 3];

					status = CyU3PSpiTransferWords(tempData, 2, tempPtr, 2);

					/*

					AdiSpiResetFifo(CyTrue, CyTrue);

				    intrMask = SPI->lpp_spi_intr_mask;
				    SPI->lpp_spi_intr_mask = 0;
					SPI->lpp_spi_config |= CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_RX_ENABLE;
					SPI->lpp_spi_config |= CY_U3P_LPP_SPI_ENABLE;
					for ( i = 0; i <= 2; i += 1)
					{
						SPI->lpp_spi_egress_data = tempData[i];
					}
					temp = CY_U3P_LPP_SPI_TX_SPACE | CY_U3P_LPP_SPI_RX_DATA;
					while ((SPI->lpp_spi_status & temp) != temp);
					temp = SPI->lpp_spi_ingress_data;
					tempPtr[0] = (uint8_t)(temp & 0xFF);

					SPI->lpp_spi_config &= ~(CY_U3P_LPP_SPI_TX_ENABLE | CY_U3P_LPP_SPI_RX_ENABLE);
					SPI->lpp_spi_intr |= CY_U3P_LPP_SPI_TX_DONE | CY_U3P_LPP_SPI_RX_DATA;
					SPI->lpp_spi_intr_mask = intrMask;
				    while ((SPI->lpp_spi_status & CY_U3P_LPP_SPI_BUSY) != 0);
				    SPI->lpp_spi_config &= ~CY_U3P_LPP_SPI_ENABLE;

				    */

					//Set the pin timer to 0
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].timer = 0;

					//clear interrupt flag
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status |= CY_U3P_LPP_GPIO_INTR;

					//Update counters
					tempPtr += 2;
					byteCounter += 2;

					//Check if a transmission is needed
					if (byteCounter >= (bytesPerUsbPacket - 1))
					{
						status = CyU3PDmaChannelCommitBuffer (&StreamingChannel, usbBufferSize, 0);
						if (status != CY_U3P_SUCCESS)
						{
							CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer in loop failed, Error code = 0x%x\r\n", status);
						}

						status = CyU3PDmaChannelGetBuffer (&StreamingChannel, &genBuf_p, CYU3P_WAIT_FOREVER);
						if (status != CY_U3P_SUCCESS)
						{
							CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer in generic capture failed, Error code = 0x%x\r\n", status);
						}
						tempPtr = genBuf_p.buffer;
						byteCounter = 0;
					}
				}
				//Check to see if we've captured enough buffers or if we were asked to stop data capture early
				if ((numBuffersRead >= (numBuffers - 1)) || killEarly)
				{
					//Reset buffer counter
					CyU3PDebugPrint (4, "Finished reading %d buffers\r\n", numBuffersRead);
					numBuffersRead = 0;
					firstRun = CyTrue;
					if (byteCounter)
					{
						status = CyU3PDmaChannelCommitBuffer (&StreamingChannel, usbBufferSize, 0);
						if (status != CY_U3P_SUCCESS)
						{
							CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer in loop failed, Error code = %d\r\n", status);
						}
						byteCounter = 0;
					}

					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;

					//Clear timer interrupt
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status |= CY_U3P_LPP_GPIO_INTR;

					//update the threshold and period
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].threshold = 0xFFFFFFFF;
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].period = 0xFFFFFFFF;

					//Disable interrupts
					GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status &= ~(CY_U3P_LPP_GPIO_INTRMODE_MASK);

					//Don't reset flag
					CyU3PEventSet(&eventHandler, ADI_GENERIC_STREAMING_DONE, CYU3P_EVENT_OR);
				}
				else
				{
					//Increment buffer counter
					numBuffersRead++;
					//Wait for the complex GPIO timer to reach the stall time if no data ready
					if(!DrActive)
					{
						while(!(GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & CY_U3P_LPP_GPIO_INTR));
					}
					//Reset flag
					CyU3PEventSet (&eventHandler, ADI_GENERIC_STREAM_ENABLE, CYU3P_EVENT_OR);
				}
			}

			/* Real-time (ADcmXL) stream case */
			if (eventFlag & ADI_REAL_TIME_STREAM_ENABLE)
			{
				//Clear GPIO interrupts
				GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
				//Wait for GPIO interrupt flag to be set and pin to be positive (interrupt configured for positive edge)
				interruptTriggered = CyFalse;
				while(!interruptTriggered)
				{
					interruptTriggered = ((CyBool_t)(GPIO->lpp_gpio_intr0 & (1 << DrPin)) && (CyBool_t)(GPIO->lpp_gpio_simple[DrPin] & CY_U3P_LPP_GPIO_IN_VALUE));
				}

				//Set the config for DMA mode
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_DMA_MODE;

				//Set the Tx/Rx count
				SPI->lpp_spi_tx_byte_count = 0;
				SPI->lpp_spi_rx_byte_count = bytesPerFrame;

				//Enable Rx and Tx as required
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_RX_ENABLE;

				//Enable the SPI block
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_ENABLE;

				//Wait for transfer to finish
				status = CyU3PSpiWaitForBlockXfer(CyTrue);

				if (status != CY_U3P_SUCCESS)
				{
					CyU3PDebugPrint (4, "Waiting for the block xfer to finish failed!, error code = %d\r\n", status);
				}

				//Check that we haven't captured the desired number of frames or were asked to kill the thread early
				if((numFramesCaptured >= (numRealTimeCaptures - 1)) || killEarly)
				{
					//Disable SPI DMA transfer
					status = CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);
					if(status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "Disabling block transfer failed!, error code = %d\r\n", status);
					}
					//Clear GPIO interrupts
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
					//Send whatever is in the buffer over to the PC
					status = CyU3PDmaChannelSetWrapUp(&StreamingChannel);
					if(status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "Wrapping up the streaming DMA channel failed!, error code = %d\r\n", status);
					}
					//Reset frame counter
					numFramesCaptured = 0;
					//Set ADI event flags
					CyU3PEventSet(&eventHandler, ADI_RT_STREAMING_DONE, CYU3P_EVENT_OR);
				}
				else
				{
					//increment the frame counter
					numFramesCaptured++;
					//Reset real-time data capture thread flag
					CyU3PEventSet (&eventHandler, ADI_REAL_TIME_STREAM_ENABLE, CYU3P_EVENT_OR);
				}
			}

			/* Burst stream case */
			if (eventFlag & ADI_BURST_STREAM_ENABLE)
			{
				/* Set up DMA to read registers from CPU memory */
				status = CyU3PDmaChannelSetupSendBuffer(&MemoryToSPI, &SpiDmaBuffer);
				if(status != CY_U3P_SUCCESS)
				{
					CyU3PDebugPrint (4, "Setting up the MemoryToSpi buffer channel failed!, error code = %d\r\n", status);
					AdiAppErrorHandler(status);
				}

				/* Wait for DR if enabled */
				if (DrActive)
				{
					/* Clear GPIO interrupts */
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
					/* Loop until interrupt is triggered */
					interruptTriggered = CyFalse;
					while(!interruptTriggered)
					{
						interruptTriggered = ((CyBool_t)(GPIO->lpp_gpio_intr0 & (1 << DrPin)));
					}
				}

				/* Set the config for DMA mode with RX and TX enabled */
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_DMA_MODE;

				/* Set the Tx/Rx count */
				SPI->lpp_spi_tx_byte_count = transferByteLength;
				SPI->lpp_spi_rx_byte_count = transferByteLength;

				/* Enable SPI Rx and Tx */
				SPI->lpp_spi_config |= (CY_U3P_LPP_SPI_RX_ENABLE | CY_U3P_LPP_SPI_TX_ENABLE);

				/* Enable the SPI block */
				SPI->lpp_spi_config |= CY_U3P_LPP_SPI_ENABLE;

				/*
				 * Note this section of code accomplishes the same as above, only
				 * the statements above circumvent the API and are performed much faster.
				 * The SPI FIFO must be properly cleaned up using AdiSpiResetFifo() before
				 * initiating a transfer.
				status = CyU3PSpiSetBlockXfer(transferByteLength, transferByteLength);
				if(status != CY_U3P_SUCCESS)
				{
					CyU3PDebugPrint (4, "Setting block xfer failed, Error code = %d\r\n", status);
				}
				*/

				/* Wait for SPI transfer to finish */
				status = CyU3PSpiWaitForBlockXfer(CyTrue);
				if(status != CY_U3P_SUCCESS)
				{
					CyU3PDebugPrint (4, "Waiting for the block xfer to finish failed!, error code = %d\r\n", status);
					AdiAppErrorHandler(status);
				}

				/* Check that we haven't captured the desired number of frames or that we were asked to kill the thread early */
				if((numBuffersRead >= (numBuffers - 1)) || killEarly)
				{
					/* Disable the SPI DMA transfer */
					status = CyU3PSpiDisableBlockXfer(CyTrue, CyTrue);
					if(status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "Disabling block transfer failed!, error code = %d\r\n", status);
						AdiAppErrorHandler(status);
					}

					/* Send whatever is in the buffer over to the PC */
					status = CyU3PDmaChannelSetWrapUp(&StreamingChannel);
					if(status != CY_U3P_SUCCESS)
					{
						CyU3PDebugPrint (4, "Wrapping up the streaming DMA channel failed!, error code = %d\r\n", status);
						AdiAppErrorHandler(status);
					}

					/* Clear GPIO interrupts */
					GPIO->lpp_gpio_simple[DrPin] |= CY_U3P_LPP_GPIO_INTR;
					/* Reset frame counter */
					numBuffersRead = 0;
					/* Set ADI event flags */
					CyU3PEventSet(&eventHandler, ADI_BURST_STREAMING_DONE, CYU3P_EVENT_OR);
				}
				else
				{
					/* Increment the frame counter */
					numBuffersRead++;
					/* Reset the real-time data capture thread flag */
					CyU3PEventSet (&eventHandler, ADI_BURST_STREAM_ENABLE, CYU3P_EVENT_OR);
				}
			}
			//CyU3PDebugPrint (4, "Event Exit \r\n");
		}
        /* Allow other ready threads to run. */
        CyU3PThreadRelinquish ();
	}
}

/*
 * Function: AdiDebugInit()
 *
 * This function initializes the UART controller to send debug messages.
 * The debug prints are routed to the UART and can be seen using a UART console
 * running at 115200 baud rate.
 *
 * Returns: Void
 */
void AdiDebugInit(void)
{
    CyU3PUartConfig_t uartConfig;
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    /* Initialize the UART for printing debug messages */
    status = CyU3PUartInit();
    if (status != CY_U3P_SUCCESS)
    {
        /* Error handling */
        AdiAppErrorHandler(status);
    }

    /* Set UART configuration */
    CyU3PMemSet ((uint8_t *)&uartConfig, 0, sizeof (uartConfig));
    uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
    uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
    uartConfig.parity = CY_U3P_UART_NO_PARITY;
    uartConfig.txEnable = CyTrue;
    uartConfig.rxEnable = CyFalse;
    uartConfig.flowCtrl = CyFalse;
    uartConfig.isDma = CyTrue;

    /* Set the UART configuration */
    status = CyU3PUartSetConfig (&uartConfig, NULL);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    /* Set the UART transfer to a really large value. */
    status = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    /* Initialize the debug module. */
    status = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    /* Turn off the preamble to the debug messages. */
    CyU3PDebugPreamble(CyFalse);

    /* Send a success command over the newly-created debug port. */
    CyU3PDebugPrint (4, "\r\n");
    CyU3PDebugPrint (4, "Debugger successfully initialized!\r\n");
    CyU3PDebugPrint (4, "\r\n");
}

/*
 * Function: AdiAppErrorHandler(CyU3PReturnStatus_t status)
 *
 * This function handles errors generated by the ADI application.
 *
 * Returns: void
 */
void AdiAppErrorHandler (CyU3PReturnStatus_t status)
{
    /* Application failed with the error code status */

    /* TODO: Add custom debug or recovery actions here */

	/* Loop Indefinitely */
	for (;;)
	{
		/* Thread sleep : 100 ms */
		CyU3PThreadSleep(100);
	}
}

/*
 * Function: AdiAppStart (void)
 *
 * This function sets up the necessary resources to start the ADI application.
 *
 * Returns: void
 */
void AdiAppStart (void)
{
	CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    /* Based on the Bus Speed configure the endpoint packet size */
    switch (usbSpeed)
    {
        case CY_U3P_FULL_SPEED:
        	usbBufferSize = 64;
            CyU3PDebugPrint (4, "Connected at USB 1.0 speed.\r\n");
            break;

        case CY_U3P_HIGH_SPEED:
        	usbBufferSize = 512;
            CyU3PDebugPrint (4, "Connected at USB 2.0 speed.\r\n");
            break;

        case  CY_U3P_SUPER_SPEED:
        	usbBufferSize = 1024;
            CyU3PDebugPrint (4, "Connected at USB 3.0 speed.\r\n");
            break;

        default:
            CyU3PDebugPrint (4, "Error! Invalid USB speed.\r\n");
            AdiAppErrorHandler (CY_U3P_ERROR_FAILURE);
            break;
    }

    /* Configure GPIO for ADI application */

	/* Configure fast sample clock to use a GPIO as a high-resolution timer.
	 * SYSCLK = 403.2 MHz. Effective clock speed for timer
	 * is 403.2MHz / (10 * 4) = 10.08 MHz. GPIO sample clock = 201.6 MHz */
	CyU3PGpioClock_t gpioClock;
	CyU3PMemSet ((uint8_t *)&gpioClock, 0, sizeof (gpioClock));
	gpioClock.fastClkDiv = 10;
	gpioClock.slowClkDiv = 0;
	gpioClock.simpleDiv = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
	gpioClock.clkSrc = CY_U3P_SYS_CLK_BY_4;
	gpioClock.halfDiv = 0;

	/* Set GPIO configuration and attach GPIO event handler */
	status = CyU3PGpioInit(&gpioClock, AdiGPIOEventHandler);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Override all pins used by ADI to act as GPIO.
	 * Configuration relies on io matrix configuration in main(). */
	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO1, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO2, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO3, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (ADI_PIN_DIO4, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (FX3_PIN_GPIO1, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (FX3_PIN_GPIO2, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (FX3_PIN_GPIO3, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (FX3_PIN_GPIO4, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride (ADI_PIN_RESET, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PDeviceGpioOverride(ADI_TIMER_PIN, CyFalse);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Set the GPIO configuration for each GPIO that was just overridden */
	CyU3PGpioSimpleConfig_t gpioConfig;
	CyU3PMemSet ((uint8_t *)&gpioConfig, 0, sizeof (gpioConfig));
	gpioConfig.outValue = CyFalse;
	gpioConfig.inputEn = CyTrue;
	gpioConfig.driveLowEn = CyFalse;
	gpioConfig.driveHighEn = CyFalse;
	gpioConfig.intrMode = CY_U3P_GPIO_NO_INTR;

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO1, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO2, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO3, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_DIO4, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(FX3_PIN_GPIO1, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(FX3_PIN_GPIO2, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(FX3_PIN_GPIO3, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(FX3_PIN_GPIO4, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	status = CyU3PGpioSetSimpleConfig(ADI_PIN_RESET, &gpioConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Configure high-speed, high-resolution timer using a complex GPIO */
	CyU3PGpioComplexConfig_t gpioComplexConfig;
	CyU3PMemSet ((uint8_t *)&gpioComplexConfig, 0, sizeof (gpioComplexConfig));
	gpioComplexConfig.outValue = CyFalse;
	gpioComplexConfig.inputEn = CyFalse;
	gpioComplexConfig.driveLowEn = CyTrue;
	gpioComplexConfig.driveHighEn = CyTrue;
	gpioComplexConfig.pinMode = CY_U3P_GPIO_MODE_STATIC;
	gpioComplexConfig.intrMode = CY_U3P_GPIO_NO_INTR;
	gpioComplexConfig.timerMode = CY_U3P_GPIO_TIMER_HIGH_FREQ;
	gpioComplexConfig.timer = 0;
	gpioComplexConfig.period = 0xFFFFFFFF;
	gpioComplexConfig.threshold = 0xFFFFFFFF;
	status = CyU3PGpioSetComplexConfig(ADI_TIMER_PIN, &gpioComplexConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    //Save bitmask of the timer pin config
	timerPinConfig = (GPIO->lpp_gpio_pin[ADI_TIMER_PIN_INDEX].status & ~CY_U3P_LPP_GPIO_INTR);

    /* Configure the SPI controller */

    /* Set the stall time in microseconds */
    stallTime = 25;

    /* Set the DUT type */
    DUTType = ADcmXL3021;

    /* Set the data ready pin */
    DrPin = ADI_PIN_DIO2;

    /* Enable the use of a data ready pin */
    DrActive = CyTrue;

    /* Set the data ready polarity */
    DrPolarity = CyTrue;

    /* Configure default global SPI parameters */
    CyU3PMemSet ((uint8_t *)&spiConfig, 0, sizeof(spiConfig));
    spiConfig.isLsbFirst = CyFalse;
    spiConfig.cpol       = CyTrue;
    spiConfig.ssnPol     = CyFalse;
    spiConfig.cpha       = CyTrue;
    spiConfig.leadTime   = CY_U3P_SPI_SSN_LAG_LEAD_ONE_CLK;
    spiConfig.lagTime    = CY_U3P_SPI_SSN_LAG_LEAD_ONE_CLK;
    spiConfig.ssnCtrl    = CY_U3P_SPI_SSN_CTRL_HW_END_OF_XFER;
    spiConfig.clock      = 2000000;
    spiConfig.wordLen    = 8;

    /* Start the SPI module and configure the FX3 as a master.
     * As with the GPIO configuration, SPI also relies on the io matrix to be correct. */
    status = CyU3PSpiInit();
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    status = CyU3PSpiSetConfig (&spiConfig, NULL);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    /* Configure global, user event flags */

	/* Create the stream/general use event handler */
	status = CyU3PEventCreate(&eventHandler);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Create GPIO event handler */
	status = CyU3PEventCreate(&gpioHandler);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

    /* Configure bulk endpoints */

	CyU3PEpConfig_t epConfig;
	CyU3PMemSet ((uint8_t *)&epConfig, 0, sizeof (epConfig));

	/* Set bulk endpoint parameters */
	epConfig.enable = CyTrue;
	epConfig.epType = CY_U3P_USB_EP_BULK;
	epConfig.burstLen = 1;
	epConfig.pcktSize = usbBufferSize;
	epConfig.streams = 0;

	/* Set endpoint config for RTS endpoint */
	status = CyU3PSetEpConfig(ADI_STREAMING_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Setting RTS/Streaming endpoint failed, Error Code = %d\n", status);
    	AdiAppErrorHandler(status);
    }

	/* Set endpoint config for the PC to FX3 endpoint */
	status = CyU3PSetEpConfig(ADI_FROM_PC_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Setting PC to FX3 endpoint failed, Error Code = %d\n", status);
    	AdiAppErrorHandler(status);
    }

	/* Set endpoint config for the FX3 to PC endpoint */
	status = CyU3PSetEpConfig(ADI_TO_PC_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Setting FX3 to PC endpoint failed, Error Code = %d\n", status);
    	AdiAppErrorHandler(status);
    }

	/* Flush endpoint memory */
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);
	CyU3PUsbFlushEp(ADI_FROM_PC_ENDPOINT);
	CyU3PUsbFlushEp(ADI_TO_PC_ENDPOINT);

	/* Configure DMAs */

    CyU3PDmaChannelConfig_t dmaConfig;
    dmaConfig.size 				= usbBufferSize;
    dmaConfig.count 			= 0;
    dmaConfig.dmaMode 			= CY_U3P_DMA_MODE_BYTE;
    dmaConfig.prodHeader     	= 0;
    dmaConfig.prodFooter     	= 0;
    dmaConfig.consHeader     	= 0;
    dmaConfig.notification   	= 0;
    dmaConfig.cb             	= NULL;
    dmaConfig.prodAvailCount 	= 0;

    /* Configure DMA for ChannelFromPC */
    dmaConfig.prodSckId = CY_U3P_UIB_SOCKET_PROD_1;
    dmaConfig.consSckId = CY_U3P_CPU_SOCKET_CONS;

    status = CyU3PDmaChannelCreate(&ChannelFromPC, CY_U3P_DMA_TYPE_MANUAL_IN, &dmaConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Configuring the ChannelFromPC DMA failed, Error Code = %d\n", status);
    	AdiAppErrorHandler(status);
    }

    /* Configure DMA for ChannelToPC */
    dmaConfig.prodSckId = CY_U3P_CPU_SOCKET_PROD;
    dmaConfig.consSckId = CY_U3P_UIB_SOCKET_CONS_2;

    status = CyU3PDmaChannelCreate(&ChannelToPC, CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "Configuring the ChannelToPC DMA failed, Error Code = %d\n", status);
    	AdiAppErrorHandler(status);
    }

    appActive = CyTrue;

    CyU3PDebugPrint (8, "AdiAppStart completed successfully!\r\n");
}

/*
 * Function: AdiAppStop (void)
 *
 * This function cleans up the resources used by the ADI application
 * and prepares them for the next run.
 *
 * Returns: void
 */
void AdiAppStop(void)
{
	CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

	/* Signal that the app thread has been stopped */
	appActive = CyFalse;

	/* Clean up UART (debug) */
	CyU3PUartDeInit ();

	/* Clean up GPIO */
	CyU3PGpioDeInit();

	/* Clean up SPI */
	CyU3PSpiDeInit();

	/* Clean up event handlers */
	CyU3PEventDestroy(&eventHandler);
	CyU3PEventDestroy(&gpioHandler);

	/* Flush endpoint memory */
	CyU3PUsbFlushEp(ADI_STREAMING_ENDPOINT);
	CyU3PUsbFlushEp(ADI_FROM_PC_ENDPOINT);
	CyU3PUsbFlushEp(ADI_TO_PC_ENDPOINT);

	/* Clean up DMAs */
	CyU3PDmaChannelDestroy(&ChannelFromPC);
	CyU3PDmaChannelDestroy(&ChannelToPC);

	/* Disable endpoints */
	CyU3PEpConfig_t epConfig;
	CyU3PMemSet ((uint8_t *)&epConfig, 0, sizeof (epConfig));
	epConfig.enable = CyFalse;

	/* Write configuration to each endpoint */

	/* Set endpoint config for RTS endpoint */
	status = CyU3PSetEpConfig(ADI_STREAMING_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Set endpoint config for the PC to FX3 endpoint */
	status = CyU3PSetEpConfig(ADI_FROM_PC_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }

	/* Set endpoint config for the FX3 to PC endpoint */
	status = CyU3PSetEpConfig(ADI_TO_PC_ENDPOINT, &epConfig);
    if (status != CY_U3P_SUCCESS)
    {
    	AdiAppErrorHandler(status);
    }
}

/* Function: AdiAppInit()
 *
 * This function initializes the USB module and attaches core event handlers.
 *
 * Returns: void
 */
void AdiAppInit (void)
{
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;

    /* Get USB serial number from FX3 die id */
    static uint32_t *EFUSE_DIE_ID = ((uint32_t *)0xE0055010);
    static const char hex_digit[16] = "0123456789ABCDEF";
    uint32_t die_id[2];

	/* Write FX3 die ID to USB serial number descriptor and a global variable */
	CyU3PReadDeviceRegisters(EFUSE_DIE_ID, 2, die_id);
	for (int i = 0; i < 2; i++)
	{
		//Access via the USB descriptor
		CyFxUSBSerialNumDesc[i*16+ 2] = hex_digit[(die_id[1-i] >> 28) & 0xF];
		CyFxUSBSerialNumDesc[i*16+ 4] = hex_digit[(die_id[1-i] >> 24) & 0xF];
		CyFxUSBSerialNumDesc[i*16+ 6] = hex_digit[(die_id[1-i] >> 20) & 0xF];
		CyFxUSBSerialNumDesc[i*16+ 8] = hex_digit[(die_id[1-i] >> 16) & 0xF];
		CyFxUSBSerialNumDesc[i*16+10] = hex_digit[(die_id[1-i] >> 12) & 0xF];
		CyFxUSBSerialNumDesc[i*16+12] = hex_digit[(die_id[1-i] >>  8) & 0xF];
		CyFxUSBSerialNumDesc[i*16+14] = hex_digit[(die_id[1-i] >>  4) & 0xF];
		CyFxUSBSerialNumDesc[i*16+16] = hex_digit[(die_id[1-i] >>  0) & 0xF];

		//Access via a vendor command
		serial_number[i*16+ 0] = hex_digit[(die_id[1-i] >> 28) & 0xF];
		serial_number[i*16+ 2] = hex_digit[(die_id[1-i] >> 24) & 0xF];
		serial_number[i*16+ 4] = hex_digit[(die_id[1-i] >> 20) & 0xF];
		serial_number[i*16+ 6] = hex_digit[(die_id[1-i] >> 16) & 0xF];
		serial_number[i*16+ 8] = hex_digit[(die_id[1-i] >> 12) & 0xF];
		serial_number[i*16+10] = hex_digit[(die_id[1-i] >>  8) & 0xF];
		serial_number[i*16+12] = hex_digit[(die_id[1-i] >>  4) & 0xF];
		serial_number[i*16+14] = hex_digit[(die_id[1-i] >>  0) & 0xF];
	}

	/* Start the USB functionality. */
    status = CyU3PUsbStart();
    if (status != CY_U3P_SUCCESS)
    {
    	CyU3PDebugPrint (4, "CyU3PUsbStart failed to Start, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }
    else
    {
    	CyU3PDebugPrint (4, "USB OK\r\n");
    }

    /* The fast enumeration is the easiest way to setup a USB connection,
     * where all enumeration phase is handled by the library. Only the
     * class / vendor requests need to be handled by the application. */
    CyU3PUsbRegisterSetupCallback(AdiControlEndpointHandler, CyTrue);

    /* Setup the callback to handle the USB events */
    CyU3PUsbRegisterEventCallback(AdiUSBEventHandler);

    /* Register a callback to handle LPM requests from the USB host */
    CyU3PUsbRegisterLPMRequestCallback(AdiLPMRequestHandler);

    /* Set the USB Enumeration descriptors */

    /* Super speed device descriptor. */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB30DeviceDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* Full speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBFSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Set Configuration Descriptor failed, Error Code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* Super speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBSSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* BOS descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, 0, (uint8_t *)CyFxUSBBOSDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* High speed device descriptor. */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, 0, (uint8_t *)CyFxUSB20DeviceDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* Device qualifier descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, 0, (uint8_t *)CyFxUSBDeviceQualDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set device qualifier descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* High speed configuration descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, 0, (uint8_t *)CyFxUSBHSConfigDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Set Other Speed Descriptor failed, Error Code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* String descriptor 0 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* String descriptor 1 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* String descriptor 2 */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }

    /* Serial number descriptor */
    status = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 3, (uint8_t *)CyFxUSBSerialNumDesc);
    if (status != CY_U3P_SUCCESS)
    {
      CyU3PDebugPrint (4, "USB set serial number descriptor failed, Error code = %d\r\n", status);
      AdiAppErrorHandler(status);
    }

    /* Connect the USB Pins with high speed operation enabled (USB 2.0 for better compatibility) */
    status = CyU3PConnectState (CyTrue, CyFalse);
    if (status != CY_U3P_SUCCESS)
    {
        CyU3PDebugPrint (4, "USB Connect failed, Error code = %d\r\n", status);
        AdiAppErrorHandler(status);
    }
}

/*
 * Function AppThread_Entry(uint32_t input)
 *
 * This is the entry point for the main application thread. It performs the device initialization
 * and then handles streaming start/stop commands for the various streaming methods.
 *
 * input: Unused input argument required by the thread manager
 *
 * Returns: void
 */
void AppThread_Entry (uint32_t input)
{
    uint32_t eventMask =
    		ADI_RT_STREAMING_DONE|
    		ADI_RT_STREAMING_START|
    		ADI_RT_STREAMING_STOP|
    		ADI_GENERIC_STREAMING_DONE|
    		ADI_GENERIC_STREAMING_START|
    		ADI_GENERIC_STREAMING_STOP|
    		ADI_BURST_STREAMING_DONE|
    		ADI_BURST_STREAMING_START|
    		ADI_BURST_STREAMING_STOP;
    uint32_t eventFlag;

    /* Initialize UART debugging */
    AdiDebugInit ();

    /* Initialize the ADI application */
    AdiAppInit ();

    for (;;)
    {
    	//Wait for event handler flags to occur and handle them
    	if (CyU3PEventGet(&eventHandler, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag, CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
    	{
			//Handle real-time stream commands
			if (eventFlag & ADI_RT_STREAMING_START)
			{
				AdiRealTimeStreamStart();
				CyU3PDebugPrint (4, "Real time stream started.\r\n");
			}
			if (eventFlag & ADI_RT_STREAMING_STOP)
			{
				AdiStopAnyDataStream();
				CyU3PDebugPrint (4, "Stop real time stream command detected.\r\n");
			}
			if (eventFlag & ADI_RT_STREAMING_DONE)
			{
				AdiRealTimeStreamFinished();
				CyU3PDebugPrint (4, "Real time stream finished.\r\n");
			}

			//Handle generic data stream commands
			if (eventFlag & ADI_GENERIC_STREAMING_START)
			{
				AdiGenericStreamStart();
				CyU3PDebugPrint (4, "Generic data stream started.\r\n");
			}
			if (eventFlag & ADI_GENERIC_STREAMING_STOP)
			{
				AdiStopAnyDataStream();
				CyU3PDebugPrint (4, "Stop generic stream command detected.\r\n");
			}
			if (eventFlag & ADI_GENERIC_STREAMING_DONE)
			{
				AdiGenericStreamFinished();
				CyU3PDebugPrint (4, "Generic data stream finished.\r\n");
			}

			//Handle burst data stream commands
			if (eventFlag & ADI_BURST_STREAMING_START)
			{
				AdiBurstStreamStart();
				CyU3PDebugPrint (4, "Burst data stream started.\r\n");
			}
			if (eventFlag & ADI_BURST_STREAMING_STOP)
			{
				AdiStopAnyDataStream();
				CyU3PDebugPrint (4, "Stop burst stream command detected.\r\n");
			}
			if (eventFlag & ADI_BURST_STREAMING_DONE)
			{
				AdiBurstStreamFinished();
				CyU3PDebugPrint (4, "Burst data stream finished.\r\n");
			}

    	}
        /* Allow other ready threads to run. */
        CyU3PThreadRelinquish ();
    }
}

/*
 * Function CyFxApplicationDefine(void)
 *
 * This function is automatically called by the RTOS kernel after booting and
 * creates all the threads used in the application.
 *
 * Returns: void
 */
void CyFxApplicationDefine (void)
{
    void *ptr = NULL;
    uint32_t retThrdCreate = CY_U3P_SUCCESS;

    /* Create application (main) thread */
    ptr = CyU3PMemAlloc (APPTHREAD_STACK);

    /* Create the thread for the application */
    retThrdCreate = CyU3PThreadCreate (&appThread, /* Thread structure. */
            "21:AppThread",                        /* Thread ID and name. */
            AppThread_Entry,                       /* Thread entry function. */
            0,                                     /* Thread input parameter. */
            ptr,                                   /* Pointer to the allocated thread stack. */
            APPTHREAD_STACK,                       /* Allocated thread stack size. */
            APPTHREAD_PRIORITY,                    /* Thread priority. */
            APPTHREAD_PRIORITY,                    /* Thread pre-emption threshold: No preemption. */
            CYU3P_NO_TIME_SLICE,                   /* No time slice. Thread will run until task is
                                                      completed or until the higher priority
                                                      thread gets active. */
            CYU3P_AUTO_START                       /* Start the thread immediately. */
            );

    /* Check if creating thread succeeded */
    if (retThrdCreate != CY_U3P_SUCCESS)
    {
    	/* Thread creation failed. Fatal error. Cannot continue. */
    	while(1);
    }

    /* Create the thread for streaming data */
    ptr = CyU3PMemAlloc (STREAMINGTHREAD_STACK);

    /* Create the streaming thread */
    retThrdCreate = CyU3PThreadCreate (&streamingThread, 	/* Thread structure. */
            "22:StreamingThread",                 			/* Thread ID and name. */
            AdiDataStream_Entry,              				/* Thread entry function. */
            0,                                     			/* Thread input parameter. */
            ptr,                                   			/* Pointer to the allocated thread stack. */
            STREAMINGTHREAD_STACK,                       	/* Allocated thread stack size. */
            STREAMINGTHREAD_PRIORITY,                    	/* Thread priority. */
            STREAMINGTHREAD_PRIORITY,                    	/* Thread pre-emption threshold: No preemption. */
            CYU3P_NO_TIME_SLICE,                   			/* No time slice. Thread will run until task is
                                                      	  	   completed or until the higher priority
                                                      	  	   thread gets active. */
            CYU3P_AUTO_START                      			/* Start the thread immediately. */
            );

    /* Check if creating thread succeeded */
    if (retThrdCreate != CY_U3P_SUCCESS)
    {
    	/* Thread creation failed. Fatal error. Cannot continue. */
    	while(1);
    }
}

/*
 * Function: main(void)
 *
 * This is the main entry point function which is executed when the part first powers on.
 * It initializes the device, memory, and IO matrix, and then boots the RTOS kernel.
 *
 * Returns: 0
 */
int main (void)
{
    CyU3PIoMatrixConfig_t io_cfg;
    CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
    CyU3PSysClockConfig_t sysclk_cfg;

    /* Configure system clocks */
    sysclk_cfg.setSysClk400 = CyTrue;
    sysclk_cfg.useStandbyClk = CyFalse;
    sysclk_cfg.clkSrc = CY_U3P_SYS_CLK;
    sysclk_cfg.cpuClkDiv = 2;
    sysclk_cfg.dmaClkDiv = 2;
    sysclk_cfg.mmioClkDiv = 2;

    /* Initialize the device */
    status = CyU3PDeviceInit (&sysclk_cfg);
    if (status != CY_U3P_SUCCESS)
    {
        goto handle_fatal_error;
    }
    /* Initialize the caches. Enable both Instruction and Data Caches. */
    status = CyU3PDeviceCacheControl (CyTrue, CyTrue, CyTrue);
    if (status != CY_U3P_SUCCESS)
    {
        goto handle_fatal_error;
    }

    /* Configure the io matrix to implement SPI and enable UART
     * debugging on DQ30 and DQ31 (GPIO48 and GPIO49).
     */
    CyU3PMemSet ((uint8_t *)&io_cfg, 0, sizeof(io_cfg));
    io_cfg.isDQ32Bit = CyFalse;
    io_cfg.s0Mode = CY_U3P_SPORT_INACTIVE;
    io_cfg.s1Mode = CY_U3P_SPORT_INACTIVE;
    io_cfg.useUart   = CyTrue;
    io_cfg.useI2C    = CyFalse;
    io_cfg.useI2S    = CyFalse;
    io_cfg.useSpi    = CyTrue;
    io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_DEFAULT;
    io_cfg.gpioSimpleEn[0]  = 0;
    io_cfg.gpioSimpleEn[1]  = 0;
    io_cfg.gpioComplexEn[0] = 0;
    io_cfg.gpioComplexEn[1] = 0;
    status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
    if (status != CY_U3P_SUCCESS)
    {
        goto handle_fatal_error;
    }

    /* This is a non returnable call for initializing the RTOS kernel */
    CyU3PKernelEntry();

    /* Dummy return to make the compiler happy */
    return 0;

handle_fatal_error:

	/* Cannot recover from this error. */
	while (1);

}
