<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADI iSensor FX3 Firmware: C:/Users/anolan3/Documents/iSensor-FX3-Firmware/FX3_Firmware/PinFunctions.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Analog-Devices-Logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADI iSensor FX3 Firmware
   &#160;<span id="projectnumber">v2.7.0-pub</span>
   </div>
   <div id="projectbrief">Firmware for the Analog Devices iSensor FX3 Evaluation Platform. This firmware is built upon libraries provided by Cypress, and can be compiled using the Cypress EZ USB Suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a6f5bf3126ac94fe2cad71d1f6aa3d6b.html">FX3_Firmware</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">PinFunctions.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains all pin and timing function implementations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_pin_functions_8h_source.html">PinFunctions.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade1f67847c31165327c6b5b0f1344858"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#ade1f67847c31165327c6b5b0f1344858">AdiSetPinResistor</a> (uint16_t pin, <a class="el" href="_pin_functions_8h.html#a23c6c642230aec03a2bcdebaf93e3ef8">PinResistorSetting</a> setting)</td></tr>
<tr class="memdesc:ade1f67847c31165327c6b5b0f1344858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure GPIO input stage pull up / pull down resistor.  <a href="#ade1f67847c31165327c6b5b0f1344858">More...</a><br /></td></tr>
<tr class="separator:ade1f67847c31165327c6b5b0f1344858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ae87598bfdb8c548e237ddc3bb0c6c"><td class="memItemLeft" align="right" valign="top">CyBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a81ae87598bfdb8c548e237ddc3bb0c6c">AdiIsValidGPIO</a> (uint16_t GpioId)</td></tr>
<tr class="memdesc:a81ae87598bfdb8c548e237ddc3bb0c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a GPIO pin is valid for the FX3 Application firmware to set.  <a href="#a81ae87598bfdb8c548e237ddc3bb0c6c">More...</a><br /></td></tr>
<tr class="separator:a81ae87598bfdb8c548e237ddc3bb0c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5e62a753e1f2ca61c308c36e87b8ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#aea5e62a753e1f2ca61c308c36e87b8ae">AdiReturnBulkEndpointData</a> (CyU3PReturnStatus_t status, uint16_t length)</td></tr>
<tr class="memdesc:aea5e62a753e1f2ca61c308c36e87b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a function result to the PC via the ChannelToPC endpoint.  <a href="#aea5e62a753e1f2ca61c308c36e87b8ae">More...</a><br /></td></tr>
<tr class="separator:aea5e62a753e1f2ca61c308c36e87b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a74bae6a0d231d72f6c4f88f31ed982"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a0a74bae6a0d231d72f6c4f88f31ed982">AdiMeasurePinDelay</a> (uint16_t transferLength)</td></tr>
<tr class="memdesc:a0a74bae6a0d231d72f6c4f88f31ed982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the delay from a trigger pin edge (sync) to a busy pin edge.  <a href="#a0a74bae6a0d231d72f6c4f88f31ed982">More...</a><br /></td></tr>
<tr class="separator:a0a74bae6a0d231d72f6c4f88f31ed982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b44440abc8a978f29eb87e5fc609dda"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a2b44440abc8a978f29eb87e5fc609dda">AdiMeasureBusyPulse</a> (uint16_t transferLength)</td></tr>
<tr class="memdesc:a2b44440abc8a978f29eb87e5fc609dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user configurable trigger condition and then measures the following GPIO pulse.  <a href="#a2b44440abc8a978f29eb87e5fc609dda">More...</a><br /></td></tr>
<tr class="separator:a2b44440abc8a978f29eb87e5fc609dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2e0a316ab7aa9e42e0ddab3ab8668"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a90e2e0a316ab7aa9e42e0ddab3ab8668">AdiConfigurePWM</a> (CyBool_t EnablePWM)</td></tr>
<tr class="memdesc:a90e2e0a316ab7aa9e42e0ddab3ab8668"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the FX3 PWM outputs (enable or disable).  <a href="#a90e2e0a316ab7aa9e42e0ddab3ab8668">More...</a><br /></td></tr>
<tr class="separator:a90e2e0a316ab7aa9e42e0ddab3ab8668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb362851b7a8aaed044318ffb040ecd1"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#aeb362851b7a8aaed044318ffb040ecd1">AdiPulseDrive</a> ()</td></tr>
<tr class="memdesc:aeb362851b7a8aaed044318ffb040ecd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function drives a GPIO pin for a specified number of milliseconds, then returns it to the starting polarity.  <a href="#aeb362851b7a8aaed044318ffb040ecd1">More...</a><br /></td></tr>
<tr class="separator:aeb362851b7a8aaed044318ffb040ecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d45b48894730356608880d0850cb452"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a6d45b48894730356608880d0850cb452">AdiPulseWait</a> (uint16_t transferLength)</td></tr>
<tr class="memdesc:a6d45b48894730356608880d0850cb452"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function waits for a pin to reach a selected logic level. The PulseWait parameters are passed in the USB buffer, and are retrieved with a call to GetEP0Data.  <a href="#a6d45b48894730356608880d0850cb452">More...</a><br /></td></tr>
<tr class="separator:a6d45b48894730356608880d0850cb452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee5cedbbf5f529f17f4b504b6f7937c"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#abee5cedbbf5f529f17f4b504b6f7937c">AdiSetDutSupply</a> (<a class="el" href="_pin_functions_8h.html#ad59527647b27d713cbb6009f201e0cd6">DutVoltage</a> SupplyMode)</td></tr>
<tr class="memdesc:abee5cedbbf5f529f17f4b504b6f7937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the DUT supply voltage.  <a href="#abee5cedbbf5f529f17f4b504b6f7937c">More...</a><br /></td></tr>
<tr class="separator:abee5cedbbf5f529f17f4b504b6f7937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc8f76636a3cadcb3d0f4121bfeb154"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#aefc8f76636a3cadcb3d0f4121bfeb154">AdiSetPin</a> (uint16_t pinNumber, CyBool_t polarity)</td></tr>
<tr class="memdesc:aefc8f76636a3cadcb3d0f4121bfeb154"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the specified pin as an output and drives it with the desired value.  <a href="#aefc8f76636a3cadcb3d0f4121bfeb154">More...</a><br /></td></tr>
<tr class="separator:aefc8f76636a3cadcb3d0f4121bfeb154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191f362f953cee5a7ad6170349760c0"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a4191f362f953cee5a7ad6170349760c0">AdiSleepForMicroSeconds</a> (uint32_t numMicroSeconds)</td></tr>
<tr class="memdesc:a4191f362f953cee5a7ad6170349760c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function blocks thread execution for a specified number of microseconds.  <a href="#a4191f362f953cee5a7ad6170349760c0">More...</a><br /></td></tr>
<tr class="separator:a4191f362f953cee5a7ad6170349760c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d30ded78cc1f92727b2bc2ec89ecf0b"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a2d30ded78cc1f92727b2bc2ec89ecf0b">AdiWaitForPin</a> (uint32_t pinNumber, CyU3PGpioIntrMode_t interruptSetting, uint32_t timeoutTicks)</td></tr>
<tr class="memdesc:a2d30ded78cc1f92727b2bc2ec89ecf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function blocks the execution of the current thread until an event happens on the specified GPIO pin.  <a href="#a2d30ded78cc1f92727b2bc2ec89ecf0b">More...</a><br /></td></tr>
<tr class="separator:a2d30ded78cc1f92727b2bc2ec89ecf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950069afeb9e581176aeededce914d2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a2950069afeb9e581176aeededce914d2">AdiMStoTicks</a> (uint32_t timeInMS)</td></tr>
<tr class="memdesc:a2950069afeb9e581176aeededce914d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts milliseconds to number of ticks and adjusts the resulting offset if below the measurable minimum.  <a href="#a2950069afeb9e581176aeededce914d2">More...</a><br /></td></tr>
<tr class="separator:a2950069afeb9e581176aeededce914d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbc30db6ed8f5e4b7ddbf348c7c55e5"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#acbbc30db6ed8f5e4b7ddbf348c7c55e5">AdiPinRead</a> (uint16_t pin)</td></tr>
<tr class="memdesc:acbbc30db6ed8f5e4b7ddbf348c7c55e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles Pin read control end point requests.  <a href="#acbbc30db6ed8f5e4b7ddbf348c7c55e5">More...</a><br /></td></tr>
<tr class="separator:acbbc30db6ed8f5e4b7ddbf348c7c55e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5625dbcdebf4e5a6bd279e922b099be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#af5625dbcdebf4e5a6bd279e922b099be">AdiReadTimerRegValue</a> ()</td></tr>
<tr class="memdesc:af5625dbcdebf4e5a6bd279e922b099be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current value of the 10MHz timer (32 bit)  <a href="#af5625dbcdebf4e5a6bd279e922b099be">More...</a><br /></td></tr>
<tr class="separator:af5625dbcdebf4e5a6bd279e922b099be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84d4ba67148ed3a892f467ca2fe5441"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#ae84d4ba67148ed3a892f467ca2fe5441">AdiReadTimerValue</a> ()</td></tr>
<tr class="memdesc:ae84d4ba67148ed3a892f467ca2fe5441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current value from the complex GPIO timer and then sends the value over the control endpoint.  <a href="#ae84d4ba67148ed3a892f467ca2fe5441">More...</a><br /></td></tr>
<tr class="separator:ae84d4ba67148ed3a892f467ca2fe5441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013157d27a8853f3c42a90cc988c72b6"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a013157d27a8853f3c42a90cc988c72b6">AdiMeasurePinFreq</a> ()</td></tr>
<tr class="memdesc:a013157d27a8853f3c42a90cc988c72b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the data ready frequency for a user specified pin.  <a href="#a013157d27a8853f3c42a90cc988c72b6">More...</a><br /></td></tr>
<tr class="separator:a013157d27a8853f3c42a90cc988c72b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c19cd7624851187c6343b9990de817"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#aa3c19cd7624851187c6343b9990de817">AdiConfigurePinInterrupt</a> (uint16_t pin, CyBool_t polarity)</td></tr>
<tr class="memdesc:aa3c19cd7624851187c6343b9990de817"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected pin as an interrupt with edge triggering based on polarity  <a href="#aa3c19cd7624851187c6343b9990de817">More...</a><br /></td></tr>
<tr class="separator:aa3c19cd7624851187c6343b9990de817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a495399a2f10b8f42901a3e592759685b"><td class="memItemLeft" align="right" valign="top">CyU3PDmaBuffer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a495399a2f10b8f42901a3e592759685b">ManualDMABuffer</a></td></tr>
<tr class="separator:a495399a2f10b8f42901a3e592759685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5735a48942c795b3be33a17c14eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_board_state.html">BoardState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#aadb5735a48942c795b3be33a17c14eb4">FX3State</a></td></tr>
<tr class="separator:aadb5735a48942c795b3be33a17c14eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a8ef2d4ec57f12b5985072f5cf000bbc0">ChannelToPC</a></td></tr>
<tr class="separator:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1de7c08a7670541c2253aac304c83"><td class="memItemLeft" align="right" valign="top">CyU3PEvent&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#ae5d1de7c08a7670541c2253aac304c83">GpioHandler</a></td></tr>
<tr class="separator:ae5d1de7c08a7670541c2253aac304c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61156727a983c3f2ebfd9ae0e5bac71"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#af61156727a983c3f2ebfd9ae0e5bac71">USBBuffer</a> [4096]</td></tr>
<tr class="separator:af61156727a983c3f2ebfd9ae0e5bac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdf81ae537b704b7df976b5b2d57706"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_pin_functions_8c.html#a9cdf81ae537b704b7df976b5b2d57706">BulkBuffer</a> [12288]</td></tr>
<tr class="separator:a9cdf81ae537b704b7df976b5b2d57706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains all pin and timing function implementations. </p>
<p>Copyright (c) Analog Devices Inc, 2018 - 2020 All Rights Reserved.</p>
<p>THIS SOFTWARE UTILIZES LIBRARIES DEVELOPED AND MAINTAINED BY CYPRESS INC. THE LICENSE INCLUDED IN THIS REPOSITORY DOES NOT EXTEND TO CYPRESS PROPERTY.</p>
<p>Use of this file is governed by the license agreement included in this repository.</p>
<dl class="section date"><dt>Date</dt><dd>8/1/2019 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>A. Nolan (<a href="#" onclick="location.href='mai'+'lto:'+'ale'+'x.'+'nol'+'an'+'@an'+'al'+'og.'+'co'+'m'; return false;">alex.<span style="display: none;">.nosp@m.</span>nola<span style="display: none;">.nosp@m.</span>n@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd>
<dd>
J. Chong (<a href="#" onclick="location.href='mai'+'lto:'+'jua'+'n.'+'cho'+'ng'+'@an'+'al'+'og.'+'co'+'m'; return false;">juan.<span style="display: none;">.nosp@m.</span>chon<span style="display: none;">.nosp@m.</span>g@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa3c19cd7624851187c6343b9990de817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c19cd7624851187c6343b9990de817">&#9670;&nbsp;</a></span>AdiConfigurePinInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiConfigurePinInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CyBool_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>configures the selected pin as an interrupt with edge triggering based on polarity </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polarity</td><td>The edge to trigger on (true -&gt; rising edge, false -&gt; falling edge)</td></tr>
    <tr><td class="paramname">pin</td><td>The GPIO pin number to configure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The success of the pin configuration operation. </dd></dl>

</div>
</div>
<a id="a90e2e0a316ab7aa9e42e0ddab3ab8668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e2e0a316ab7aa9e42e0ddab3ab8668">&#9670;&nbsp;</a></span>AdiConfigurePWM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiConfigurePWM </td>
          <td>(</td>
          <td class="paramtype">CyBool_t&#160;</td>
          <td class="paramname"><em>EnablePWM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the FX3 PWM outputs (enable or disable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EnablePWM</td><td>If the PWM should be enabled or disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>The pin number, threshold value, and period are provided in the USBBuffer, and are calculated in the FX3Api. This mitigates any potential math/rounding errors. The PWM pins are driven by a 100MHz clock. The output is artificially capped at 10MHz. </p>

</div>
</div>
<a id="a81ae87598bfdb8c548e237ddc3bb0c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ae87598bfdb8c548e237ddc3bb0c6c">&#9670;&nbsp;</a></span>AdiIsValidGPIO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyBool_t AdiIsValidGPIO </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>GpioId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a GPIO pin is valid for the FX3 Application firmware to set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GpioId</td><td>The GPIO matrix index for the pin to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the GPIO is valid or not.</dd></dl>
<p>This function is called before all interfacing functions. This prevents invalid GPIO access, or unintended modifications to the power supply management pins. </p>

</div>
</div>
<a id="a2b44440abc8a978f29eb87e5fc609dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b44440abc8a978f29eb87e5fc609dda">&#9670;&nbsp;</a></span>AdiMeasureBusyPulse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiMeasureBusyPulse </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>transferLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a user configurable trigger condition and then measures the following GPIO pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transferLength</td><td>The amount of data (in bytes) to read from the USB buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the measure pulse operation</dd></dl>
<p>This function is approx. microsecond accurate. It can be used for timing measurements which require a high degree of accuracy since it avoids the overhead of having a USB transaction (200us) between the initial trigger condition and the pulse measurement. This function is primarily intended for use with the ADcmXL series of condition monitoring modules. </p>

</div>
</div>
<a id="a0a74bae6a0d231d72f6c4f88f31ed982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a74bae6a0d231d72f6c4f88f31ed982">&#9670;&nbsp;</a></span>AdiMeasurePinDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiMeasurePinDelay </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>transferLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the delay from a trigger pin edge (sync) to a busy pin edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transferLength</td><td>The amount of data (in bytes) to read from the USB buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the pin delay measure operation</dd></dl>
<p>This function is approx. microsecond accurate. It can be used for timing measurements which require a high degree of accuracy since it avoids the overhead of having a USB transaction (200us) between the initial pin drive condition and the pulse measurement. This function is primarily intended to be used for measuring the latency between a sync edge and data ready toggle on the ADIS IMU series of products. </p>

</div>
</div>
<a id="a013157d27a8853f3c42a90cc988c72b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013157d27a8853f3c42a90cc988c72b6">&#9670;&nbsp;</a></span>AdiMeasurePinFreq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiMeasurePinFreq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the data ready frequency for a user specified pin. </p>
<dl class="section return"><dt>Returns</dt><dd>The status of the pin drive operation</dd></dl>
<p>This function measures two data ready pulses on a user-specified pin and reports back the delta-time in ticks. The function also transmits the tick scale factor and a timeout counter to notify the interface of timeouts that may have occurred due to missing pulses. Data is transmitted over USB via the bulk endpoint. Inputs are provided through the control endpoint. This function can be expanded to capture as many samples as required. pin: The GPIO pin number to measure polarity: The polarity of the pin (1 - Low-to-High, 0 - High-to-Low) timeoutInMs: The specified timeout in milliseconds </p>

</div>
</div>
<a id="a2950069afeb9e581176aeededce914d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2950069afeb9e581176aeededce914d2">&#9670;&nbsp;</a></span>AdiMStoTicks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t AdiMStoTicks </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeInMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts milliseconds to number of ticks and adjusts the resulting offset if below the measurable minimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeInMS</td><td>The real stall time (in ms) desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of timer ticks representing that MS value. </dd></dl>

</div>
</div>
<a id="acbbc30db6ed8f5e4b7ddbf348c7c55e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbc30db6ed8f5e4b7ddbf348c7c55e5">&#9670;&nbsp;</a></span>AdiPinRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiPinRead </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles Pin read control end point requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO matrix number of the pin to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The success of the pin read operation</dd></dl>
<p>This function reads the value of a specified GPIO pin, and sends that value over the control endpoint to the host PC. The pin read status is also attached. </p>

</div>
</div>
<a id="aeb362851b7a8aaed044318ffb040ecd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb362851b7a8aaed044318ffb040ecd1">&#9670;&nbsp;</a></span>AdiPulseDrive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiPulseDrive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function drives a GPIO pin for a specified number of milliseconds, then returns it to the starting polarity. </p>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>If the selected GPIO pin is not configured as an output, this function configures the pin. If you want the pin to stay at a given logic level, use <a class="el" href="_pin_functions_8c.html#aefc8f76636a3cadcb3d0f4121bfeb154" title="This function configures the specified pin as an output and drives it with the desired value.">AdiSetPin()</a> instead. The arguments to this function are passed in through USBBuffer. pin: The GPIO pin number to drive polarity: The polarity of the pin (True - High, False - Low) driveTime: The number of milliseconds to drive the pin for </p>

</div>
</div>
<a id="a6d45b48894730356608880d0850cb452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d45b48894730356608880d0850cb452">&#9670;&nbsp;</a></span>AdiPulseWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiPulseWait </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>transferLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function waits for a pin to reach a selected logic level. The PulseWait parameters are passed in the USB buffer, and are retrieved with a call to GetEP0Data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transferLength</td><td>How many bytes to read from the USBBuffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>The time waited and status information are sent to the PC over the bulk out endpoint at the end of this function. If you want to collect very accurate timing measurements using the FX3, consider using the AdiMeasureBusyPulse function instead. pin is the GPIO pin number to poll polarity is the pin polarity which will trigger an exit condition delay is the wait time (in ms) from when the function starts before pin polling starts timeout is the time (in ms) to wait for the pin level before exiting </p>

</div>
</div>
<a id="af5625dbcdebf4e5a6bd279e922b099be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5625dbcdebf4e5a6bd279e922b099be">&#9670;&nbsp;</a></span>AdiReadTimerRegValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t AdiReadTimerRegValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current value of the 10MHz timer (32 bit) </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elapsed timer ticks </dd></dl>

</div>
</div>
<a id="ae84d4ba67148ed3a892f467ca2fe5441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84d4ba67148ed3a892f467ca2fe5441">&#9670;&nbsp;</a></span>AdiReadTimerValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiReadTimerValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current value from the complex GPIO timer and then sends the value over the control endpoint. </p>
<dl class="section return"><dt>Returns</dt><dd>The success of the timer read operation.</dd></dl>
<p>This function handles timer read control endpoint requests specifically. May be changed to return the actual timer value eventually. </p>

</div>
</div>
<a id="aea5e62a753e1f2ca61c308c36e87b8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5e62a753e1f2ca61c308c36e87b8ae">&#9670;&nbsp;</a></span>AdiReturnBulkEndpointData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiReturnBulkEndpointData </td>
          <td>(</td>
          <td class="paramtype">CyU3PReturnStatus_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a function result to the PC via the ChannelToPC endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The status code to place in the BulkEndpointBuffer (0 - 3)</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to send to the PC over the bulk endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function is used to allow early returns out of long functions in the case where an invalid setting or operation is detected. Once this function is called, and the result sent to the PC, the function can be safely exited. </p>

</div>
</div>
<a id="abee5cedbbf5f529f17f4b504b6f7937c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee5cedbbf5f529f17f4b504b6f7937c">&#9670;&nbsp;</a></span>AdiSetDutSupply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiSetDutSupply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pin_functions_8h.html#ad59527647b27d713cbb6009f201e0cd6">DutVoltage</a>&#160;</td>
          <td class="paramname"><em>SupplyMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the DUT supply voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SupplyMode</td><td>The DUT Voltage to set (Off, 3.3V, 5V)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the functions.</dd></dl>
<p>This function sets the control pins on the LTC1470 power switch IC. This IC allows software to power cycle a DUT or give it 3.3V/5V to Vdd. This feature only works on the in-house ADI iSensors FX3 Eval board. It does not function on the iSensor FX3 Eval board based on the Cypress Explorer kit. </p>

</div>
</div>
<a id="aefc8f76636a3cadcb3d0f4121bfeb154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc8f76636a3cadcb3d0f4121bfeb154">&#9670;&nbsp;</a></span>AdiSetPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiSetPin </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CyBool_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the specified pin as an output and drives it with the desired value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinNumber</td><td>The GPIO index of the pin to be set</td></tr>
    <tr><td class="paramname">polarity</td><td>The polarity of the pin to be set (True - High, False - Low)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the pin set operation.</dd></dl>
<p>Take care when using this function. If a valid GPIO which has not been configured as an output is selected, that pin will be forced to act as an output. This will cause pins which have functionality beyond just a simple GPIO can lose that functionality (e.g. UART Debug, SPI, etc). </p>

</div>
</div>
<a id="ade1f67847c31165327c6b5b0f1344858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1f67847c31165327c6b5b0f1344858">&#9670;&nbsp;</a></span>AdiSetPinResistor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiSetPinResistor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pin_functions_8h.html#a23c6c642230aec03a2bcdebaf93e3ef8">PinResistorSetting</a>&#160;</td>
          <td class="paramname"><em>setting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure GPIO input stage pull up / pull down resistor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO matrix index for the pin to configure (0 - 63)</td></tr>
    <tr><td class="paramname">setting</td><td>The PinResistorSetting to apply to the selected pin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the operation</dd></dl>
<p>This function configures the "weak" pull up or pull down setting which the FX3 micro provides for each GPIO. </p>

</div>
</div>
<a id="a4191f362f953cee5a7ad6170349760c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4191f362f953cee5a7ad6170349760c0">&#9670;&nbsp;</a></span>AdiSleepForMicroSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiSleepForMicroSeconds </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMicroSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function blocks thread execution for a specified number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numMicroSeconds</td><td>The number of microseconds to stall for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function. </dd></dl>

</div>
</div>
<a id="a2d30ded78cc1f92727b2bc2ec89ecf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d30ded78cc1f92727b2bc2ec89ecf0b">&#9670;&nbsp;</a></span>AdiWaitForPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiWaitForPin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CyU3PGpioIntrMode_t&#160;</td>
          <td class="paramname"><em>interruptSetting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function blocks the execution of the current thread until an event happens on the specified GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinNumber</td><td>The GPIO pin number to poll</td></tr>
    <tr><td class="paramname">interruptSetting</td><td>The simple GPIO interrupt mode that the selected pin is configured with.</td></tr>
    <tr><td class="paramname">timeoutTicks</td><td>The number of GPIO timer ticks (10MHz) to wait for before timing out and returning.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the pin wait function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9cdf81ae537b704b7df976b5b2d57706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdf81ae537b704b7df976b5b2d57706">&#9670;&nbsp;</a></span>BulkBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t BulkBuffer[12288]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global USB Buffer (Bulk Endpoints) </p>

</div>
</div>
<a id="a8ef2d4ec57f12b5985072f5cf000bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2d4ec57f12b5985072f5cf000bbc0">&#9670;&nbsp;</a></span>ChannelToPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel ChannelToPC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for BULK-IN endpoint 0x82 (FX3 to PC) </p>

</div>
</div>
<a id="aadb5735a48942c795b3be33a17c14eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5735a48942c795b3be33a17c14eb4">&#9670;&nbsp;</a></span>FX3State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_board_state.html">BoardState</a> FX3State</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct. which stores all run time configurable FX3 settings </p>

</div>
</div>
<a id="ae5d1de7c08a7670541c2253aac304c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d1de7c08a7670541c2253aac304c83">&#9670;&nbsp;</a></span>GpioHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PEvent GpioHandler</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADI GPIO event structure (RTOS handles GPIO ISR) </p>

</div>
</div>
<a id="a495399a2f10b8f42901a3e592759685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495399a2f10b8f42901a3e592759685b">&#9670;&nbsp;</a></span>ManualDMABuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaBuffer_t ManualDMABuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA buffer structure for output buffer </p>

</div>
</div>
<a id="af61156727a983c3f2ebfd9ae0e5bac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61156727a983c3f2ebfd9ae0e5bac71">&#9670;&nbsp;</a></span>USBBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBBuffer[4096]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Global USB Buffer (Control Endpoint) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
