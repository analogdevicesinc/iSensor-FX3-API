<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADI iSensor FX3 Firmware: C:/Users/anolan3/Documents/iSensor-FX3-Firmware/FX3_Firmware/SpiFunctions.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Analog-Devices-Logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADI iSensor FX3 Firmware
   &#160;<span id="projectnumber">v2.4.0-pub</span>
   </div>
   <div id="projectbrief">Firmware for the Analog Devices iSensor FX3 Evaluation Platform. This firmware is built upon libraries provided by Cypress, and can be compiled using the Cypress EZ USB Suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a6f5bf3126ac94fe2cad71d1f6aa3d6b.html">FX3_Firmware</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SpiFunctions.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains all generic SPI read/write function implementations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_spi_functions_8h_source.html">SpiFunctions.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72c5344f6d7ce3000731bd79737be26d"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a72c5344f6d7ce3000731bd79737be26d">AdiRestartSpi</a> ()</td></tr>
<tr class="memdesc:a72c5344f6d7ce3000731bd79737be26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function restarts the SPI controller.  <a href="#a72c5344f6d7ce3000731bd79737be26d">More...</a><br /></td></tr>
<tr class="separator:a72c5344f6d7ce3000731bd79737be26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9515c0308c76a45b338c9c3e47890017"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a9515c0308c76a45b338c9c3e47890017">AdiBitBangSpiHandler</a> ()</td></tr>
<tr class="memdesc:a9515c0308c76a45b338c9c3e47890017"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles bit bang SPI requests from the control endpoint.  <a href="#a9515c0308c76a45b338c9c3e47890017">More...</a><br /></td></tr>
<tr class="separator:a9515c0308c76a45b338c9c3e47890017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad9c35efa0de2b518ac623c35ca9de2"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#acad9c35efa0de2b518ac623c35ca9de2">AdiBitBangSpiSetup</a> (<a class="el" href="struct_bit_bang_spi_conf.html">BitBangSpiConf</a> config)</td></tr>
<tr class="memdesc:acad9c35efa0de2b518ac623c35ca9de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures all pins and timers needed to bitbang a SPI connection.  <a href="#acad9c35efa0de2b518ac623c35ca9de2">More...</a><br /></td></tr>
<tr class="separator:acad9c35efa0de2b518ac623c35ca9de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341777b3be0c5885b2b76566e7827f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a1341777b3be0c5885b2b76566e7827f2">AdiBitBangSpiTransfer</a> (uint8_t *MOSI, uint8_t *MISO, uint32_t BitCount, <a class="el" href="struct_bit_bang_spi_conf.html">BitBangSpiConf</a> config)</td></tr>
<tr class="memdesc:a1341777b3be0c5885b2b76566e7827f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a single bit banged SPI transfer. Pins must already be configured as needed.  <a href="#a1341777b3be0c5885b2b76566e7827f2">More...</a><br /></td></tr>
<tr class="separator:a1341777b3be0c5885b2b76566e7827f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9219b41ae6d89a54e2d37696c64a6b"><td class="memItemLeft" align="right" valign="top">CyU3PSpiConfig_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#ada9219b41ae6d89a54e2d37696c64a6b">AdiGetSpiConfig</a> ()</td></tr>
<tr class="memdesc:ada9219b41ae6d89a54e2d37696c64a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses the SPI control registers into an easier to work with config struct.  <a href="#ada9219b41ae6d89a54e2d37696c64a6b">More...</a><br /></td></tr>
<tr class="separator:ada9219b41ae6d89a54e2d37696c64a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b6e4f6710b6e1c9f7eee02eb6613ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a91b6e4f6710b6e1c9f7eee02eb6613ca">AdiPrintSpiConfig</a> (CyU3PSpiConfig_t config)</td></tr>
<tr class="memdesc:a91b6e4f6710b6e1c9f7eee02eb6613ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a given SPI config over the UART debug port.  <a href="#a91b6e4f6710b6e1c9f7eee02eb6613ca">More...</a><br /></td></tr>
<tr class="separator:a91b6e4f6710b6e1c9f7eee02eb6613ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5254848805c4b8e74cbc8e94fa78307f"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a5254848805c4b8e74cbc8e94fa78307f">AdiTransferBytes</a> (uint32_t writeData)</td></tr>
<tr class="memdesc:a5254848805c4b8e74cbc8e94fa78307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a protocol agnostic SPI bi-directional SPI transfer of (1, 2, 4) bytes.  <a href="#a5254848805c4b8e74cbc8e94fa78307f">More...</a><br /></td></tr>
<tr class="separator:a5254848805c4b8e74cbc8e94fa78307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c7fc11222c453959c72eec1aa8afa2"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a57c7fc11222c453959c72eec1aa8afa2">AdiReadRegBytes</a> (uint16_t addr)</td></tr>
<tr class="memdesc:a57c7fc11222c453959c72eec1aa8afa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads a single 16 bit SPI word from a slave device.  <a href="#a57c7fc11222c453959c72eec1aa8afa2">More...</a><br /></td></tr>
<tr class="separator:a57c7fc11222c453959c72eec1aa8afa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c91fa11a171844d59e40a4d0fee7cf"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a09c91fa11a171844d59e40a4d0fee7cf">AdiWriteRegByte</a> (uint16_t addr, uint8_t data)</td></tr>
<tr class="memdesc:a09c91fa11a171844d59e40a4d0fee7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a single byte of data over the SPI bus.  <a href="#a09c91fa11a171844d59e40a4d0fee7cf">More...</a><br /></td></tr>
<tr class="separator:a09c91fa11a171844d59e40a4d0fee7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fad4317c94479eaf852e5b22ea4d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a46fad4317c94479eaf852e5b22ea4d2a">AdiSetSpiWordLength</a> (uint8_t wordLength)</td></tr>
<tr class="memdesc:a46fad4317c94479eaf852e5b22ea4d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the SPI controller word length (4 - 32 bits)  <a href="#a46fad4317c94479eaf852e5b22ea4d2a">More...</a><br /></td></tr>
<tr class="separator:a46fad4317c94479eaf852e5b22ea4d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d5ab32e1256b10aa2f6e2c7ebede7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a46d5ab32e1256b10aa2f6e2c7ebede7a">AdiWaitForSpiNotBusy</a> ()</td></tr>
<tr class="memdesc:a46d5ab32e1256b10aa2f6e2c7ebede7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the SPI controller busy bit to be not set.  <a href="#a46d5ab32e1256b10aa2f6e2c7ebede7a">More...</a><br /></td></tr>
<tr class="separator:a46d5ab32e1256b10aa2f6e2c7ebede7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa083144a6203655613621a89d8e809e1"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#aa083144a6203655613621a89d8e809e1">AdiSpiResetFifo</a> (CyBool_t isTx, CyBool_t isRx)</td></tr>
<tr class="memdesc:aa083144a6203655613621a89d8e809e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the SPI FIFO and disables the SPI block after completion.  <a href="#aa083144a6203655613621a89d8e809e1">More...</a><br /></td></tr>
<tr class="separator:aa083144a6203655613621a89d8e809e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788c3bd92096e55b7fde4da3a0308f5c"><td class="memItemLeft" align="right" valign="top">CyU3PReturnStatus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a788c3bd92096e55b7fde4da3a0308f5c">AdiGetSpiSettings</a> ()</td></tr>
<tr class="memdesc:a788c3bd92096e55b7fde4da3a0308f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles vendor commands to get the current SPI configuration from the FX3.  <a href="#a788c3bd92096e55b7fde4da3a0308f5c">More...</a><br /></td></tr>
<tr class="separator:a788c3bd92096e55b7fde4da3a0308f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa715a94cb680f243e03c7d6d2d93503c"><td class="memItemLeft" align="right" valign="top">CyBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#aa715a94cb680f243e03c7d6d2d93503c">AdiSpiUpdate</a> (uint16_t index, uint16_t value, uint16_t length)</td></tr>
<tr class="memdesc:aa715a94cb680f243e03c7d6d2d93503c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles a vendor command request to update the SPI/DR Pin configuration.  <a href="#aa715a94cb680f243e03c7d6d2d93503c">More...</a><br /></td></tr>
<tr class="separator:aa715a94cb680f243e03c7d6d2d93503c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af61156727a983c3f2ebfd9ae0e5bac71"><td class="memItemLeft" align="right" valign="top"><a id="af61156727a983c3f2ebfd9ae0e5bac71"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>USBBuffer</b> [4096]</td></tr>
<tr class="separator:af61156727a983c3f2ebfd9ae0e5bac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdf81ae537b704b7df976b5b2d57706"><td class="memItemLeft" align="right" valign="top"><a id="a9cdf81ae537b704b7df976b5b2d57706"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>BulkBuffer</b> [12288]</td></tr>
<tr class="separator:a9cdf81ae537b704b7df976b5b2d57706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb5735a48942c795b3be33a17c14eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_board_state.html">BoardState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#aadb5735a48942c795b3be33a17c14eb4">FX3State</a></td></tr>
<tr class="separator:aadb5735a48942c795b3be33a17c14eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98693015cd59e2346ce44ac5af02a4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_stream_state.html">StreamState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a98693015cd59e2346ce44ac5af02a4c0">StreamThreadState</a></td></tr>
<tr class="separator:a98693015cd59e2346ce44ac5af02a4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495399a2f10b8f42901a3e592759685b"><td class="memItemLeft" align="right" valign="top">CyU3PDmaBuffer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a495399a2f10b8f42901a3e592759685b">ManualDMABuffer</a></td></tr>
<tr class="separator:a495399a2f10b8f42901a3e592759685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memItemLeft" align="right" valign="top">CyU3PDmaChannel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_spi_functions_8c.html#a8ef2d4ec57f12b5985072f5cf000bbc0">ChannelToPC</a></td></tr>
<tr class="separator:a8ef2d4ec57f12b5985072f5cf000bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains all generic SPI read/write function implementations. </p>
<p>Copyright (c) Analog Devices Inc, 2018 - 2019 All Rights Reserved.</p>
<p>THIS SOFTWARE UTILIZES LIBRARIES DEVELOPED AND MAINTAINED BY CYPRESS INC. THE LICENSE INCLUDED IN THIS REPOSITORY DOES NOT EXTEND TO CYPRESS PROPERTY.</p>
<p>Use of this file is governed by the license agreement included in this repository.</p>
<dl class="section date"><dt>Date</dt><dd>8/1/2019 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>A. Nolan (<a href="#" onclick="location.href='mai'+'lto:'+'ale'+'x.'+'nol'+'an'+'@an'+'al'+'og.'+'co'+'m'; return false;">alex.<span style="display: none;">.nosp@m.</span>nola<span style="display: none;">.nosp@m.</span>n@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd>
<dd>
J. Chong (<a href="#" onclick="location.href='mai'+'lto:'+'jua'+'n.'+'cho'+'ng'+'@an'+'al'+'og.'+'co'+'m'; return false;">juan.<span style="display: none;">.nosp@m.</span>chon<span style="display: none;">.nosp@m.</span>g@ana<span style="display: none;">.nosp@m.</span>log.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9515c0308c76a45b338c9c3e47890017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9515c0308c76a45b338c9c3e47890017">&#9670;&nbsp;</a></span>AdiBitBangSpiHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiBitBangSpiHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles bit bang SPI requests from the control endpoint. </p>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the SPI bitbang operation.</dd></dl>
<p>This function requires all data to have been retrieved from the control endpoint before being called. It parses all the parameters about the current bit bang SPI operation to perform from the transaction. The pins/timing/config is sent from the FX3 API to the firmware with each bitbang SPI transaction. </p>

</div>
</div>
<a id="acad9c35efa0de2b518ac623c35ca9de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9c35efa0de2b518ac623c35ca9de2">&#9670;&nbsp;</a></span>AdiBitBangSpiSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiBitBangSpiSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bit_bang_spi_conf.html">BitBangSpiConf</a>&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures all pins and timers needed to bitbang a SPI connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A structure containing all the relevant bit banged SPI configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the bitbang SPI setup process. </dd></dl>

</div>
</div>
<a id="a1341777b3be0c5885b2b76566e7827f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1341777b3be0c5885b2b76566e7827f2">&#9670;&nbsp;</a></span>AdiBitBangSpiTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiBitBangSpiTransfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>MOSI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>MISO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>BitCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bit_bang_spi_conf.html">BitBangSpiConf</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a single bit banged SPI transfer. Pins must already be configured as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MOSI</td><td>A pointer to the master out data buffer. This data will be transmitted MSB first, over the MOSI line in config.</td></tr>
    <tr><td class="paramname">MISO</td><td>A pointer to the data receive (rx) buffer. The data received from a slave will be placed here.</td></tr>
    <tr><td class="paramname">BitCount</td><td>The number of bits to transfer.</td></tr>
    <tr><td class="paramname">config</td><td>The configuration settings to use for the transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a user to use any pins on the FX3 as a low speed SPI master. The API provided is similar to the Cypress API for the hardware SPI. </p>

</div>
</div>
<a id="ada9219b41ae6d89a54e2d37696c64a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9219b41ae6d89a54e2d37696c64a6b">&#9670;&nbsp;</a></span>AdiGetSpiConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PSpiConfig_t AdiGetSpiConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses the SPI control registers into an easier to work with config struct. </p>
<dl class="section return"><dt>Returns</dt><dd>The current SPI config, as set in the SPI controller hardware.</dd></dl>
<p>This function can be used to ensure synchronization between the SPI controller and the SPI settings in firmware, without having to perform a SPI controller reset operation. Resetting the SPI controller can cause undesired effects on the SPI lines. </p>

</div>
</div>
<a id="a788c3bd92096e55b7fde4da3a0308f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788c3bd92096e55b7fde4da3a0308f5c">&#9670;&nbsp;</a></span>AdiGetSpiSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiGetSpiSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles vendor commands to get the current SPI configuration from the FX3. </p>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>This function allows the FX3 API to verify that the FX3 board has the same SPI settings as the current FX3 connection instance. The current configuration is sent to the PC via EP0. </p>

</div>
</div>
<a id="a91b6e4f6710b6e1c9f7eee02eb6613ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b6e4f6710b6e1c9f7eee02eb6613ca">&#9670;&nbsp;</a></span>AdiPrintSpiConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiPrintSpiConfig </td>
          <td>(</td>
          <td class="paramtype">CyU3PSpiConfig_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a given SPI config over the UART debug port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The SPI config structure to print out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a57c7fc11222c453959c72eec1aa8afa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c7fc11222c453959c72eec1aa8afa2">&#9670;&nbsp;</a></span>AdiReadRegBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiReadRegBytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads a single 16 bit SPI word from a slave device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to send to the DUT in the first SPI transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>This function reads a single word over SPI. Note that reads are not "full duplex" and will require a discrete read to set the address to be read from (two 16 bit transactions per read). </p>

</div>
</div>
<a id="a72c5344f6d7ce3000731bd79737be26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c5344f6d7ce3000731bd79737be26d">&#9670;&nbsp;</a></span>AdiRestartSpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiRestartSpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function restarts the SPI controller. </p>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the setConfig call after re-initialization.</dd></dl>
<p>This function can be used to restore hardware SPI functionality after overriding the SPI pins to act as a bit-banged SPI port. This function can be called before or after the SPI controller has been initialized without causing problems. This function may cause erroneous toggles on the SPI lines during the initialization process - be careful to ensure that the connected DUT is not particularly sensitive to extra toggles. </p>

</div>
</div>
<a id="a46fad4317c94479eaf852e5b22ea4d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fad4317c94479eaf852e5b22ea4d2a">&#9670;&nbsp;</a></span>AdiSetSpiWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiSetSpiWordLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>wordLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the SPI controller word length (4 - 32 bits) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordLength</td><td>The number of bits to transfer in a single SPI transaction</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes directly to the SPI control register. It does not cause the toggle on the chip select line seen using the cypress API for setting the SPI word length. </p>

</div>
</div>
<a id="aa083144a6203655613621a89d8e809e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa083144a6203655613621a89d8e809e1">&#9670;&nbsp;</a></span>AdiSpiResetFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiSpiResetFifo </td>
          <td>(</td>
          <td class="paramtype">CyBool_t&#160;</td>
          <td class="paramname"><em>isTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CyBool_t&#160;</td>
          <td class="paramname"><em>isRx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the SPI FIFO and disables the SPI block after completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isTx</td><td>Boolean to indicate if you're clearing the TX FIFO</td></tr>
    <tr><td class="paramname">isRx</td><td>Boolean to indicate if you're clearing the RX FIFO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The success of the SPI reset FIFO operation.</dd></dl>
<p>It is a copy of the private CyU3PSpiResetFifo() function which bypasses some input sanitization which the Cypress libraries perform. This is required due to our high-speed, register-initiated transfers. </p>

</div>
</div>
<a id="aa715a94cb680f243e03c7d6d2d93503c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa715a94cb680f243e03c7d6d2d93503c">&#9670;&nbsp;</a></span>AdiSpiUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyBool_t AdiSpiUpdate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles a vendor command request to update the SPI/DR Pin configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The wIndex from the control endpoint transaction which indicates which parameter to update</td></tr>
    <tr><td class="paramname">value</td><td>The wValue from the control endpoint transaction which holds the SPI value to set for the selected parameter.</td></tr>
    <tr><td class="paramname">length</td><td>The length of the Data In phase of the control endpoint transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if the SPI configuration was a success</dd></dl>
<p>This function provides an API for maintaining synchronicity in SPI and data ready triggering settings between the FX3 API and the firmware. Any time a setting is changed on the FX3 API, this function will be invoked to reflect that change. </p>

</div>
</div>
<a id="a5254848805c4b8e74cbc8e94fa78307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5254848805c4b8e74cbc8e94fa78307f">&#9670;&nbsp;</a></span>AdiTransferBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiTransferBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a protocol agnostic SPI bi-directional SPI transfer of (1, 2, 4) bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeData</td><td>The data to transmit on the MOSI line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>This function performs a bi-directional SPI transfer, on up to 4 bytes of data. The transfer length is determined by the current SPI config word length setting. The status and data received on the MISO line are sent to the PC over EP0 following the transfer. </p>

</div>
</div>
<a id="a46d5ab32e1256b10aa2f6e2c7ebede7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d5ab32e1256b10aa2f6e2c7ebede7a">&#9670;&nbsp;</a></span>AdiWaitForSpiNotBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AdiWaitForSpiNotBusy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the SPI controller busy bit to be not set. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a09c91fa11a171844d59e40a4d0fee7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c91fa11a171844d59e40a4d0fee7cf">&#9670;&nbsp;</a></span>AdiWriteRegByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PReturnStatus_t AdiWriteRegByte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a single byte of data over the SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The DUT address to write data to (7 bits).</td></tr>
    <tr><td class="paramname">data</td><td>The byte of data to write to the address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code indicating the success of the function.</dd></dl>
<p>This function uses the standard iSensor SPI protocol to issue a write command. For the standard iSensor SPI parts, a write is performed in a single 16 bit command, where the first bit clocked out is the write bit (high) followed by the address and data. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8ef2d4ec57f12b5985072f5cf000bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2d4ec57f12b5985072f5cf000bbc0">&#9670;&nbsp;</a></span>ChannelToPC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaChannel ChannelToPC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA channel for BULK-IN endpoint 0x82 (FX3 to PC) </p>

</div>
</div>
<a id="aadb5735a48942c795b3be33a17c14eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5735a48942c795b3be33a17c14eb4">&#9670;&nbsp;</a></span>FX3State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_board_state.html">BoardState</a> FX3State</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct. which stores all run time configurable FX3 settings </p>

</div>
</div>
<a id="a495399a2f10b8f42901a3e592759685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495399a2f10b8f42901a3e592759685b">&#9670;&nbsp;</a></span>ManualDMABuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CyU3PDmaBuffer_t ManualDMABuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA buffer structure for output buffer </p>

</div>
</div>
<a id="a98693015cd59e2346ce44ac5af02a4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98693015cd59e2346ce44ac5af02a4c0">&#9670;&nbsp;</a></span>StreamThreadState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_stream_state.html">StreamState</a> StreamThreadState</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Struct of data used to synchronize the data streaming / app threads </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
